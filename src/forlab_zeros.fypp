#:include 'common.fypp'
#:set RANKS = range(1, 4)
submodule(forlab) forlab_zeros
    !! Version: experimental
    !!## zeros: `szeros(zeros)/dzeros/qzeros`
    !! `zeros` creates array all of zeros.
    !!
    !!### Syntax
    !!    x = zeros(dim1)                
    !!    A = zeros(dim1, dim2)          
    !!    X = zeros(dim1, dim2, dim3)    
    !! 
    !!### Description
    !! 
    !! Unlike other dynamic languages, Fortran has a variety of precisions, 
    !! using integer input and outputting polymorphic return 
    !! values is difficult to achieve, so we set three `zeros` functions: 
    !! `szeros(zeros)/dzeros/qzeros`.
    !!
    !! `x = (s)zeros(dim1)` returns a dim1 vector of zeros with single precision.
    !! `x = dzeros(dim1)` returns a dim1 vector of zeros with double precision.
    !! `x = qzeros(dim1)` returns a dim1 vector of zeros with quadruple precision.
    !!
    !! `A = zeros(dim1, dim2)` returns a dim1-by-dim2 matrix of zeros.
    !!
    !! `X = zeros(dim1, dim2, dim3)` returns a dim1-by-dim2-by-dim3
    !! 3-dimensional matrix of zeros.
    !!
    !!### Examples
    !!    x = zeros(3)  
    !!    x =  
    !!        0.  0.  0.  
    !!
    !!    A = zeros(3, 3)  
    !!    A =  
    !!        0.  0.  0.  
    !!        0.  0.  0.  
    !!        0.  0.  0.
    use forlab_kinds
    implicit none
contains
    #:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES + INT_KINDS_TYPES
    #:for k1, t1 in RCI_KINDS_TYPES
    module procedure zeros_${t1[0]}$${k1}$   
        #:if t1[0] == 'r' 
        X = 0.0_${k1}$
        #:elif t1[0] == 'i'
        X = 0
        #:elif t1[0] == 'c'
        X = cmplx(0.0_${k1}$, 0.0_${k1}$, ${k1}$)
        #:endif
        return
    end procedure

    #:endfor
end submodule
