
#:include 'common.fypp'

submodule(forlab) forlab_tri
    !! Version: expermental
    !!
    !! tril extracts the lower triangular part of a matrix.
    !!
    !!## Syntax
    !!
    !!      B = tril(A)
    !!      B = tril(A, k)
    !!
    !!## Description
    !!
    !!  `B = tril(A)` returns the lower triangular part of matrix A.
    !!
    !!  `B = tril(A, k)` returns the elements on and below the kth diagonal of
    !!      matrix X:
    !!
    !!      -   k = 0 is the main diagonal,
    !!      -   k > 0 is above the main diagonal,
    !!      -   k < 0 is below the main diagonal.
    !!
    !!## Examples
    !!
    !!      A = ones(4, 4)
    !!      B = tril(A, -1)
    !!          0.  0.  0.  0.
    !!          1.  0.  0.  0.
    !!          1.  1.  0.  0.
    !!          1.  1.  1.  0.
    !! Version: expermental
    !!
    !! triu extracts the upper triangular part of a matrix.
    !!
    !!## Syntax
    !!
    !!      B = triu(A)
    !!      B = triu(A, k)
    !!
    !!## Description
    !!
    !!  `B = triu(A)` returns the upper triangular part of matrix A.
    !!
    !!  `B = triu(A, k)` returns the elements on and above the kth diagonal of
    !!
    !!      matrix X:
    !!      -   k = 0 is the main diagonal,
    !!      -   k > 0 is above the main diagonal,
    !!      -   k < 0 is below the main diagonal.
    !!
    !!## Examples
    !!
    !!      A = ones(4, 4)
    !!      B = triu(A, -1)
    !!          1.  1.  1.  1.
    !!          1.  1.  1.  1.
    !!          0.  1.  1.  1.
    !!          0.  0.  1.  1.
    use forlab_kinds
    implicit none
contains
    #:for k1,t1 in INT_KINDS_TYPES
    module procedure tril_${k1}$
        integer::opt_k,i,m,n
        opt_k = 0
        if (present(k)) opt_k = k
        m = size(A, 1)
        n = size(A, 2)
        tril_${k1}$ = A
        do i = 1, min(m, n)
            tril_${k1}$(:i - opt_k - 1, i) = 0_${k1}$
        end do
    end procedure tril_${k1}$

    #:endfor

    #:for k1,t1 in REAL_KINDS_TYPES
    module procedure tril_${k1}$
        integer::opt_k,i,m,n
        opt_k = 0
        if (present(k)) opt_k = k
        m = size(A, 1)
        n = size(A, 2)
        tril_${k1}$ = A
        do i = 1, min(m, n)
            tril_${k1}$(:i - opt_k - 1, i) = 0.0_${k1}$
        end do
    end procedure tril_${k1}$

    #:endfor
    #:for k1,t1 in CMPLX_KINDS_TYPES
    module procedure tril_c${k1}$
        integer::opt_k,i,m,n
        opt_k = 0
        if (present(k)) opt_k = k
        m = size(A, 1)
        n = size(A, 2)
        tril_c${k1}$ = A
        do i = 1, min(m, n)
            tril_c${k1}$(:i - opt_k - 1, i) =cmplx(0.0_${k1}$,0.0_${k1}$,kind=${k1}$)
        end do
    end procedure tril_c${k1}$


    #:endfor
    #:for k1,t1 in INT_KINDS_TYPES
    module procedure triu_${k1}$
        integer::opt_k,i,m,n
        opt_k = 0
        if (present(k)) opt_k = k
        m = size(A, 1)
        n = size(A, 2)
        triu_${k1}$ = A
        do i = 1, min(m, n)
            triu_${k1}$(i - opt_k + 1:, i) = 0_${k1}$
        end do
    end procedure triu_${k1}$

    #:endfor

    #:for k1,t1 in REAL_KINDS_TYPES
    module procedure triu_${k1}$
        integer::opt_k,i,m,n
        opt_k = 0
        if (present(k)) opt_k = k
        m = size(A, 1)
        n = size(A, 2)
        triu_${k1}$ = A
        do i = 1, min(m, n)
            triu_${k1}$(i - opt_k + 1:, i) = 0.0_${k1}$
        end do
    end procedure triu_${k1}$

    #:endfor
    #:for k1,t1 in CMPLX_KINDS_TYPES
    module procedure triu_c${k1}$
        integer::opt_k,i,m,n
        opt_k = 0
        if (present(k)) opt_k = k
        m = size(A, 1)
        n = size(A, 2)
        triu_c${k1}$ = A
        do i = 1, min(m, n)
            triu_c${k1}$(i - opt_k + 1:, i) =cmplx(0.0_${k1}$,0.0_${k1}$,kind=${k1}$)
        end do
    end procedure triu_c${k1}$

    #:endfor

end submodule
