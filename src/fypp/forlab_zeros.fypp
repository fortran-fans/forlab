#:include 'common.fypp'

#:def ranksuffix(RANK)
$:'' if RANK == 0 else '(' + ':' + ',:' * (RANK - 1) + ')'
#:enddef ranksuffix

#:set RANKS = range(1, 4)
submodule(forlab) forlab_zeros
    !! Version: experimental
    !!
    !! zeros creates array all of zeros.
    !!
    !!## Syntax
    !!    x = zeros(dim1)                
    !!    A = zeros(dim1, dim2)          
    !!    X = zeros(dim1, dim2, dim3)    
    !! 
    !!## Description
    !! The precision of the flag variable should be consistent with 
    !! the return value of the function.  
    !! Unlike dynamic scripting languages, static languages generally
    !! have multiple precision variables, so we need to explicitly provide precision hints.
    !!
    !! `x = zeros(dim1)` returns a dim1 vector of zeros.
    !!
    !! `A = zeros(dim1, dim2)` returns a dim1-by-dim2 matrix of zeros.
    !!
    !! `X = zeros(dim1, dim2, dim3)` returns a dim1-by-dim2-by-dim3
    !! 3-dimensional matrix of zeros.
    !!
    !!## Examples
    !!    x = zeros(3)  
    !!    x =  
    !!        0.  0.  0.  
    !!
    !!    A = zeros(3, 3)  
    !!    A =  
    !!        0.  0.  0.  
    !!        0.  0.  0.  
    !!        0.  0.  0.
    use forlab_kinds
    implicit none
contains
    #:for k1, t1 in REAL_KINDS_TYPES
    #:for RANK in RANKS
    module procedure zeros_${RANK}$_${k1}$
        integer :: ierr
        #:if RANK == 1
        allocate (zeros_${RANK}$_${k1}$ (dim1), stat=ierr)
        #:elif RANK == 2
        allocate (zeros_${RANK}$_${k1}$ (dim1, dim2), stat=ierr)
        #:elif RANK == 3
        allocate (zeros_${RANK}$_${k1}$ (dim1, dim2, dim3), stat=ierr)
        #:endif
        if (ierr .ne. 0) then
            print *, "Error: in zeros, could not allocate array."
            stop
        else
            zeros_${RANK}$_${k1}$ = 0.0_${k1}$
        end if
        return
    end procedure

    #:endfor
    #:endfor
end submodule
