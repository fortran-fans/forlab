#:include 'common.fypp'
#:set RANKS = range(1, 4)
submodule(forlab) forlab_zeros
    !! Version: experimental
    !!## zeros: `szeros(zeros)/dzeros/qzeros`
    !! `zeros` creates array all of zeros.
    !!
    !!### Syntax
    !!    x = zeros(dim1)                
    !!    A = zeros(dim1, dim2)          
    !!    X = zeros(dim1, dim2, dim3)    
    !! 
    !!### Description
    !! 
    !! Unlike other dynamic languages, Fortran has a variety of precisions, 
    !! using integer input and outputting polymorphic return 
    !! values is difficult to achieve, so we set three `zeros` functions: 
    !! `szeros(zeros)/dzeros/qzeros`.
    !!
    !! `x = (s)zeros(dim1)` returns a dim1 vector of zeros with single precision.
    !! `x = dzeros(dim1)` returns a dim1 vector of zeros with double precision.
    !! `x = qzeros(dim1)` returns a dim1 vector of zeros with quadruple precision.
    !!
    !! `A = zeros(dim1, dim2)` returns a dim1-by-dim2 matrix of zeros.
    !!
    !! `X = zeros(dim1, dim2, dim3)` returns a dim1-by-dim2-by-dim3
    !! 3-dimensional matrix of zeros.
    !!
    !!### Examples
    !!    x = zeros(3)  
    !!    x =  
    !!        0.  0.  0.  
    !!
    !!    A = zeros(3, 3)  
    !!    A =  
    !!        0.  0.  0.  
    !!        0.  0.  0.  
    !!        0.  0.  0.
    use forlab_kinds
    implicit none
contains
    #:for k1, t1 in REAL_KINDS_TYPES
    #:for RANK in RANKS
    module procedure zeros_${RANK}$_${k1}$
        integer :: ierr
        #:if RANK == 1
        allocate (zeros_${RANK}$_${k1}$ (dim1), stat=ierr)
        #:elif RANK == 2
        allocate (zeros_${RANK}$_${k1}$ (dim1, dim2), stat=ierr)
        #:elif RANK == 3
        allocate (zeros_${RANK}$_${k1}$ (dim1, dim2, dim3), stat=ierr)
        #:endif
        if (ierr .ne. 0) then
            call disp("Error: in (s/d/q)zeros, could not allocate array.")
            stop
        else
            zeros_${RANK}$_${k1}$ = 0.0_${k1}$
        end if
        return
    end procedure

    #:endfor
    #:endfor
end submodule
