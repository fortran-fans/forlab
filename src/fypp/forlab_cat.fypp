#:include 'common.fypp'
submodule(forlab) forlab_cat
    ! horzcat
    !-----------------------------------------------------------------------
    ! horzcat concatenates arrays horizontally.
    !
    ! Syntax
    !-----------------------------------------------------------------------
    ! A = horzcat(x1, x2)
    ! A = horzcat(A1, A2)
    ! B = horzcat(x1, A2)
    ! B = horzcat(A1, x2)
    !
    ! Description
    !-----------------------------------------------------------------------
    ! A = horzcat(x1, x2) concatenates the vectors x1 and x2 treated as
    ! column vectors along the dimension 1. If the length of x1 and x2 are
    ! not equal, empty elements will be filled with zeros.
    !
    ! A = horzcat(A1, A2) concatenates the matrices A1 and A2 along the
    ! dimension 1. If the first dimensions of A1 and A2 are not equal, empty
    ! elements will be filled with zeros.
    !
    ! B = horzcat(x1, A2) concatenates the vector x treated as column vector
    ! and the matrix A along the dimension 1. If the length of x and the
    ! first dimension of A are not equal, empty elements will be filled with
    ! zeros.
    !
    ! B = horzcat(A1, x2) concatenates the matrix A and the vector x treated
    ! as column vector along the dimension 1. If the first dimension o A and
    ! the length of x are not equal, empty elements will be filled with
    ! zeros.
    !
    ! Examples
    !-----------------------------------------------------------------------
    ! A1 = reshape([ 1., 2., 3., 4. ], [ 2, 2 ], order = [ 2, 1 ])
    ! A2 = reshape([ 5., 6., 7., 8. ], [ 2, 2 ], order = [ 2, 1 ])
    ! A = horzcat(A1, A2)
    !     1.  2.  5.  6.
    !     3.  4.  7.  8.
    
    use forlab_kinds
    implicit none

contains

    function horzcat_i1(x1, x2)
        integer(kind=IPRE), dimension(:, :), allocatable :: horzcat_i1
        integer(kind=IPRE), dimension(:), intent(in) :: x1, x2
        integer(kind=IPRE) :: m1, m2

        m1 = size(x1)
        m2 = size(x2)

        horzcat_i1 = zeros(max(m1, m2), 2)
        horzcat_i1(1:m1, 1) = x1
        horzcat_i1(1:m2, 2) = x2
        return
    end function horzcat_i1

    function horzcat_r1(x1, x2)
        real(kind=RPRE), dimension(:, :), allocatable :: horzcat_r1
        real(kind=RPRE), dimension(:), intent(in) :: x1, x2
        integer(kind=IPRE) :: m1, m2

        m1 = size(x1)
        m2 = size(x2)

        horzcat_r1 = zeros(max(m1, m2), 2)
        horzcat_r1(1:m1, 1) = x1
        horzcat_r1(1:m2, 2) = x2
        return
    end function horzcat_r1

    function horzcat_i2(A1, A2)
        integer(kind=IPRE), dimension(:, :), allocatable :: horzcat_i2
        integer(kind=IPRE), dimension(:, :), intent(in) :: A1, A2
        integer(kind=IPRE) :: m1, n1, m2, n2

        m1 = size(A1, 1)
        n1 = size(A1, 2)
        m2 = size(A2, 1)
        n2 = size(A2, 2)

        horzcat_i2 = zeros(max(m1, m2), n1 + n2)
        horzcat_i2(1:m1, 1:n1) = A1
        horzcat_i2(1:m2, n1 + 1:) = A2
        return
    end function horzcat_i2

    function horzcat_r2(A1, A2)
        real(kind=RPRE), dimension(:, :), allocatable :: horzcat_r2
        real(kind=RPRE), dimension(:, :), intent(in) :: A1, A2
        integer(kind=IPRE) :: m1, n1, m2, n2

        m1 = size(A1, 1)
        n1 = size(A1, 2)
        m2 = size(A2, 1)
        n2 = size(A2, 2)

        horzcat_r2 = zeros(max(m1, m2), n1 + n2)
        horzcat_r2(1:m1, 1:n1) = A1
        horzcat_r2(1:m2, n1 + 1:) = A2
        return
    end function horzcat_r2

    function horzcat_i12(x1, A2)
        integer(kind=IPRE), dimension(:, :), allocatable :: horzcat_i12
        integer(kind=IPRE), dimension(:), intent(in) :: x1
        integer(kind=IPRE), dimension(:, :), intent(in) :: A2
        integer(kind=IPRE) :: m1, m2, n2

        m1 = size(x1)
        m2 = size(A2, 1)
        n2 = size(A2, 2)

        horzcat_i12 = zeros(max(m1, m2), n2 + 1)
        horzcat_i12(1:m1, 1) = x1
        horzcat_i12(1:m2, 2:) = A2
        return
    end function horzcat_i12

    function horzcat_r12(x1, A2)
        real(kind=RPRE), dimension(:, :), allocatable :: horzcat_r12
        real(kind=RPRE), dimension(:), intent(in) :: x1
        real(kind=RPRE), dimension(:, :), intent(in) :: A2
        integer(kind=IPRE) :: m1, m2, n2

        m1 = size(x1)
        m2 = size(A2, 1)
        n2 = size(A2, 2)

        horzcat_r12 = zeros(max(m1, m2), n2 + 1)
        horzcat_r12(1:m1, 1) = x1
        horzcat_r12(1:m2, 2:) = A2
        return
    end function horzcat_r12

    function horzcat_i21(A1, x2)
        integer(kind=IPRE), dimension(:, :), allocatable :: horzcat_i21
        integer(kind=IPRE), dimension(:, :), intent(in) :: A1
        integer(kind=IPRE), dimension(:), intent(in) :: x2
        integer(kind=IPRE) :: m1, n1, m2

        m1 = size(A1, 1)
        n1 = size(A1, 2)
        m2 = size(x2)

        horzcat_i21 = zeros(max(m1, m2), n1 + 1)
        horzcat_i21(1:m1, 1:n1) = A1
        horzcat_i21(1:m2, n1 + 1) = x2
        return
    end function horzcat_i21

    function horzcat_r21(A1, x2)
        real(kind=RPRE), dimension(:, :), allocatable :: horzcat_r21
        real(kind=RPRE), dimension(:, :), intent(in) :: A1
        real(kind=RPRE), dimension(:), intent(in) :: x2
        integer(kind=IPRE) :: m1, n1, m2

        m1 = size(A1, 1)
        n1 = size(A1, 2)
        m2 = size(x2)

        horzcat_r21 = zeros(max(m1, m2), n1 + 1)
        horzcat_r21(1:m1, 1:n1) = A1
        horzcat_r21(1:m2, n1 + 1) = x2
        return
    end function horzcat_r21

    ! vertcat
    !-----------------------------------------------------------------------
    ! vertcat concatenates arrays vertically.
    !
    ! Syntax
    !-----------------------------------------------------------------------
    ! A = vertcat(x1, x2)
    ! A = vertcat(A1, A2)
    ! B = vertcat(x1, A2)
    ! B = vertcat(A1, x2)
    !
    ! Description
    !-----------------------------------------------------------------------
    ! A = vertcat(x1, x2) concatenates the vectors x1 and x2 treated as line
    ! vectors along the dimension 2. If the length of x1 and x2 are not
    ! equal, empty elements will be filled with zeros.
    !
    ! A = vertcat(A1, A2) concatenates the matrices A1 and A2 along the
    ! dimension 2. If the second dimension of A1 and A2 are not equal, empty
    ! elements will be filled with zeros.
    !
    ! B = vertcat(x1, A2) concatenates the vector x treated as line vector
    ! and the matrix A along the dimension 2. If the length of x and the
    ! second dimension of A are not equal, empty elements will be filled
    ! with zeros.
    !
    ! B = vertcat(A1, x2) concatenates the matrix A and the vector x treated
    ! as a line vector along the dimension 2. If the second dimension of A
    ! and the length of x are not equal, empty elements will be filled with
    ! zeros.
    !
    ! Examples
    !-----------------------------------------------------------------------
    ! A1 = reshape([ 1., 2., 3., 4. ], [ 2, 2 ], order = [ 2, 1 ])
    ! A2 = reshape([ 5., 6., 7., 8. ], [ 2, 2 ], order = [ 2, 1 ])
    ! A = vertcat(A1, A2)
    !     1.  2.
    !     3.  4.
    !     5.  6.
    !     7.  8.
    function vertcat_r1(x1, x2)
        real(kind=RPRE), dimension(:, :), allocatable :: vertcat_r1
        real(kind=RPRE), dimension(:), intent(in) :: x1, x2
        integer(kind=IPRE) :: n1, n2

        n1 = size(x1)
        n2 = size(x2)

        vertcat_r1 = zeros(2, max(n1, n2))
        vertcat_r1(1, 1:n1) = x1
        vertcat_r1(2, 1:n2) = x2
        return
    end function vertcat_r1

    function vertcat_r2(A1, A2)
        real(kind=RPRE), dimension(:, :), allocatable :: vertcat_r2
        real(kind=RPRE), dimension(:, :), intent(in) :: A1, A2
        integer(kind=IPRE) :: m1, n1, m2, n2

        m1 = size(A1, 1)
        n1 = size(A1, 2)
        m2 = size(A2, 1)
        n2 = size(A2, 2)

        vertcat_r2 = zeros(m1 + m2, max(n1, n2))
        vertcat_r2(1:m1, 1:n1) = A1
        vertcat_r2(m1 + 1:, 1:n2) = A2
        return
    end function vertcat_r2

    function vertcat_c2(A1, A2)
        complex(kind=RPRE), dimension(:, :), allocatable :: vertcat_c2
        complex(kind=RPRE), dimension(:, :), intent(in) :: A1, A2
        integer(kind=IPRE) :: m1, n1, m2, n2

        m1 = size(A1, 1)
        n1 = size(A1, 2)
        m2 = size(A2, 1)
        n2 = size(A2, 2)

        vertcat_c2 = zeros(m1 + m2, max(n1, n2))
        vertcat_c2(1:m1, 1:n1) = A1
        vertcat_c2(m1 + 1:, 1:n2) = A2
        return
    end function vertcat_c2

    function vertcat_r12(x1, A2)
        real(kind=RPRE), dimension(:, :), allocatable :: vertcat_r12
        real(kind=RPRE), dimension(:), intent(in) :: x1
        real(kind=RPRE), dimension(:, :), intent(in) :: A2
        integer(kind=IPRE) :: n1, m1, n2

        n1 = size(x1)
        m1 = size(A2, 1)
        n2 = size(A2, 2)

        vertcat_r12 = zeros(m1 + 1, max(n1, n2))
        vertcat_r12(1, 1:n1) = x1
        vertcat_r12(2:, 1:n2) = A2
        return
    end function vertcat_r12

    function vertcat_r21(A1, x2)
        real(kind=RPRE), dimension(:, :), allocatable :: vertcat_r21
        real(kind=RPRE), dimension(:, :), intent(in) :: A1
        real(kind=RPRE), dimension(:), intent(in) :: x2
        integer(kind=IPRE) :: m1, n1, n2

        m1 = size(A1, 1)
        n1 = size(A1, 2)
        n2 = size(x2)

        vertcat_r21 = zeros(m1 + 1, max(n1, n2))
        vertcat_r21(1:m1, 1:n1) = A1
        vertcat_r21(m1 + 1, 1:n2) = x2
        return
    end function vertcat_r21
end submodule
