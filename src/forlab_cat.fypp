#:include 'common.fypp'
#:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES + INT_KINDS_TYPES
submodule(forlab) forlab_cat
    !## horzcat
    !-----------------------------------------------------------------------
    ! horzcat concatenates arrays horizontally.
    !
    ! Syntax
    !-----------------------------------------------------------------------
    ! A = horzcat(x1, x2)
    ! A = horzcat(A1, A2)
    ! B = horzcat(x1, A2)
    ! B = horzcat(A1, x2)
    !
    ! Description
    !-----------------------------------------------------------------------
    ! A = horzcat(x1, x2) concatenates the vectors x1 and x2 treated as
    ! column vectors along the dimension 1. If the length of x1 and x2 are
    ! not equal, empty elements will be filled with zeros.
    !
    ! A = horzcat(A1, A2) concatenates the matrices A1 and A2 along the
    ! dimension 1. If the first dimensions of A1 and A2 are not equal, empty
    ! elements will be filled with zeros.
    !
    ! B = horzcat(x1, A2) concatenates the vector x treated as column vector
    ! and the matrix A along the dimension 1. If the length of x and the
    ! first dimension of A are not equal, empty elements will be filled with
    ! zeros.
    !
    ! B = horzcat(A1, x2) concatenates the matrix A and the vector x treated
    ! as column vector along the dimension 1. If the first dimension o A and
    ! the length of x are not equal, empty elements will be filled with
    ! zeros.
    !
    ! Examples
    !-----------------------------------------------------------------------
    ! A1 = reshape([ 1., 2., 3., 4. ], [ 2, 2 ], order = [ 2, 1 ])
    ! A2 = reshape([ 5., 6., 7., 8. ], [ 2, 2 ], order = [ 2, 1 ])
    ! A = horzcat(A1, A2)
    !     1.  2.  5.  6.
    !     3.  4.  7.  8.

    !## vertcat
    !-----------------------------------------------------------------------
    ! vertcat concatenates arrays vertically.
    !
    ! Syntax
    !-----------------------------------------------------------------------
    ! A = vertcat(x1, x2)
    ! A = vertcat(A1, A2)
    ! B = vertcat(x1, A2)
    ! B = vertcat(A1, x2)
    !
    ! Description
    !-----------------------------------------------------------------------
    ! A = vertcat(x1, x2) concatenates the vectors x1 and x2 treated as line
    ! vectors along the dimension 2. If the length of x1 and x2 are not
    ! equal, empty elements will be filled with zeros.
    !
    ! A = vertcat(A1, A2) concatenates the matrices A1 and A2 along the
    ! dimension 2. If the second dimension of A1 and A2 are not equal, empty
    ! elements will be filled with zeros.
    !
    ! B = vertcat(x1, A2) concatenates the vector x treated as line vector
    ! and the matrix A along the dimension 2. If the length of x and the
    ! second dimension of A are not equal, empty elements will be filled
    ! with zeros.
    !
    ! B = vertcat(A1, x2) concatenates the matrix A and the vector x treated
    ! as a line vector along the dimension 2. If the second dimension of A
    ! and the length of x are not equal, empty elements will be filled with
    ! zeros.
    !
    ! Examples
    !-----------------------------------------------------------------------
    ! A1 = reshape([ 1., 2., 3., 4. ], [ 2, 2 ], order = [ 2, 1 ])
    ! A2 = reshape([ 5., 6., 7., 8. ], [ 2, 2 ], order = [ 2, 1 ])
    ! A = vertcat(A1, A2)
    !     1.  2.
    !     3.  4.
    !     5.  6.
    !     7.  8.
    
    use forlab_kinds
    implicit none

contains
    #:set CATTYPE = ['horzcat', 'vertcat']
    #:for c1 in CATTYPE
    #:for k1, t1 in RCI_KINDS_TYPES
    module procedure ${c1}$_${t1[0]}$_1_${k1}$
        integer :: m1, m2

        m1 = size(x1)
        m2 = size(x2)
        #:if c1 == 'horzcat'
        allocate(${c1}$_${t1[0]}$_1_${k1}$(max(m1, m2), 2))
        call zeros(${c1}$_${t1[0]}$_1_${k1}$)
        ${c1}$_${t1[0]}$_1_${k1}$(1:m1, 1) = x1
        ${c1}$_${t1[0]}$_1_${k1}$(1:m2, 2) = x2
        #:elif c1 == 'vertcat'
        allocate(${c1}$_${t1[0]}$_1_${k1}$(m1+m2, 1))
        call zeros(${c1}$_${t1[0]}$_1_${k1}$)
        ${c1}$_${t1[0]}$_1_${k1}$(1:m1, 1) = x1
        ${c1}$_${t1[0]}$_1_${k1}$(m1+1:m1+m2, 1) = x2
        #:endif
        return
    end procedure

    module procedure ${c1}$_${t1[0]}$_2_${k1}$
        integer :: m1, n1, m2, n2

        m1 = size(A1, 1)
        n1 = size(A1, 2)
        m2 = size(A2, 1)
        n2 = size(A2, 2)
        #:if c1 == 'horzcat'
        allocate(${c1}$_${t1[0]}$_2_${k1}$(max(m1, m2), n1 + n2))
        call zeros(${c1}$_${t1[0]}$_2_${k1}$)
        ${c1}$_${t1[0]}$_2_${k1}$(1:m1, 1:n1) = A1
        ${c1}$_${t1[0]}$_2_${k1}$(1:m2, n1 + 1:) = A2
        #:elif c1 == 'vertcat'
        allocate(${c1}$_${t1[0]}$_2_${k1}$(m1+m2, max(n1,n2)))
        call zeros(${c1}$_${t1[0]}$_2_${k1}$)
        ${c1}$_${t1[0]}$_2_${k1}$(1:m1, 1:n1) = A1
        ${c1}$_${t1[0]}$_2_${k1}$(m1+1:m1+m2, 1:n2) = A2
        #:endif
        return
    end procedure

    module procedure ${c1}$_${t1[0]}$_21_${k1}$
        integer :: m1, n1, m2

        m1 = size(A1, 1)
        n1 = size(A1, 2)
        m2 = size(x2)
        #:if c1 == 'horzcat'
        allocate(${c1}$_${t1[0]}$_21_${k1}$(max(m1, m2), n1 + 1))
        call zeros(${c1}$_${t1[0]}$_21_${k1}$)
        ${c1}$_${t1[0]}$_21_${k1}$(1:m1, 1:n1) = A1
        ${c1}$_${t1[0]}$_21_${k1}$(1:m2, n1 + 1) = x2
        #:elif c1 == 'vertcat'
        allocate(${c1}$_${t1[0]}$_21_${k1}$(m1+m2, n1))
        call zeros(${c1}$_${t1[0]}$_21_${k1}$)
        ${c1}$_${t1[0]}$_21_${k1}$(1:m1, 1:n1) = A1
        ${c1}$_${t1[0]}$_21_${k1}$(m1+1:m1+m2, 1) = x2
        #:endif
        return
    end procedure

    module procedure ${c1}$_${t1[0]}$_12_${k1}$
        integer :: m1, m2, n2

        m1 = size(x1)
        m2 = size(A2, 1)
        n2 = size(A2, 2)
        #:if c1 == 'horzcat'
        allocate(${c1}$_${t1[0]}$_12_${k1}$(max(m1, m2), n2 + 1))
        call zeros(${c1}$_${t1[0]}$_12_${k1}$)
        ${c1}$_${t1[0]}$_12_${k1}$(1:m1, 1) = x1
        ${c1}$_${t1[0]}$_12_${k1}$(1:m2, 2:) = A2
        #:elif c1 == 'vertcat'
        allocate(${c1}$_${t1[0]}$_12_${k1}$(m1+m2, n2))
        call zeros(${c1}$_${t1[0]}$_12_${k1}$)
        ${c1}$_${t1[0]}$_12_${k1}$(1:m1, 1) = x1
        ${c1}$_${t1[0]}$_12_${k1}$(m1+1:m1+m2, 1:n2) = A2
        #:endif
        return
    end procedure
    #:endfor
    #:endfor
end submodule
