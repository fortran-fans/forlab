

#:include "common.fypp"

submodule(forlab) forlab_norm
    !! norm computes vector and matrix norms.
    !!([Interface](../interface/norm.html))
    !!## Syntax
    !!
    !!      y = norm(x)
    !!      y = norm(x, p)
    !!      x = norm(A)
    !!      x = norm(A, p)
    !!
    !!## Description
    !!
    !! `y = norm(x)` returns the 2-norm or Euclidian norm of vector x.
    !!
    !! `y = norm(x, p)` returns the p-norm of vector x, where p is any positive
    !! real value.
    !!
    !! `x = norm(A)` returns the 2-norm of matrix A (largest singular value).
    !!
    !! `x = norm(A, p)` returns the p-norm of matrix A, where p is {1, 2}.
    !!
    !!## Examples
    !!
    !!      x = [ 1., 2., 3. ]
    !!      y = norm(x)
    !!          3.74165750
    !!      y = norm(x, 3.)
    !!          3.30192733
    use forlab_kinds
    implicit none
    
contains
    #:for k1,t1 in REAL_KINDS_TYPES
    module procedure norm1_${k1}$
        ${t1}$::temp
        if (.not. present(p))then
            temp =2.0_${k1}$
        else
            temp = p
        end if

        if(temp == 2.0_${k1}$) then
            norm1 = sqrt(sum(abs(x)**2))
        elseif (temp == 1.0_${k1}$) then
            norm1 = sum(abs(x))
        else
            norm1 = (sum(abs(x)**p))**(1.0_${k1}$/p)
        end if
    end procedure norm1_${k1}$

    module procedure norm2_${k1}$
        ${t1}$::temp
        ${t1}$, dimension(:), allocatable :: w
        if (.not. present(p))then
            temp =2.0_${k1}$
        else
            temp = p
        end if
        if(temp==2.0_${k1}$)then
            call svd(A, w)
            norm2 = maxval(w)
        elseif (temp == 1.0_${k1}$) then
            norm2 = maxval(sum(abs(A), dim=2))
        end if
    end procedure norm2_${k1}$
    #:endfor
end submodule

