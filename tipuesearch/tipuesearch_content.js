var tipuesearch = {"pages":[{"title":" FORLAB ","text":"FORLAB Fortran FORLAB API Documentation Goals and Motivation Scope License Warning This API documentation for the fortran-fans/FORLAB v1.0 is a work in progress Note Use the navigation bar at the top of the screen to browse modules, procedures, source files, etc.\nThe listings near the bottom of the page are incomplete. Fortran FORLAB API Documentation This is the main API documentation landing page generated by FORD .\nThe documentation for comment markup in source code, running FORD and the FORD project file are all maintained on the FORD wiki . Goals and Motivation The Fortran FORLAB v1.0 is a Fortran module that provides a lot of functions for scientific computing mostly inspired by Matlab and Python's module NumPy. FORLAB is mainly developed by Keurfon Luu. (see keurfonluu/Forlab ) Scope The goal of the FORLAB is to achieve the following general scope: forlab easy-to-use interface ford-api-doc multi-precision forlab benchmarks License FORLAB is released under the MIT License. Developer Info FORLAB v1.0 contributors","tags":"home","loc":"index.html"},{"title":"forlab_color.f90 – FORLAB","text":"Contents Modules forlab_color Source Code forlab_color.f90 Source Code module forlab_color ! Some parameters for our ANSI escape codes character ( * ), parameter :: esc = achar ( 27 ) ! Escape character. character ( * ), parameter :: default = esc // '[0m' ! Terminates an ANSI code. ! Foreground(font) Colours character ( * ), parameter :: red = esc // '[31m' character ( * ), parameter :: green = esc // '[32m' character ( * ), parameter :: yellow = esc // '[33m' character ( * ), parameter :: blue = esc // '[34m' character ( * ), parameter :: magenta = esc // '[35m' character ( * ), parameter :: cyan = esc // '[36m' character ( * ), parameter :: grey = esc // '[90m' !Bright-Black ! One background colour character ( * ), parameter :: background_green = esc // '[42m' ! Some other formatting character ( * ), parameter :: bold = esc // '[1m' character ( * ), parameter :: bold_blink = esc // '[1;5m' end module forlab_color","tags":"","loc":"sourcefile/forlab_color.f90.html"},{"title":"forlab_linalg_outer.f90 – FORLAB","text":"Contents Submodules forlab_linalg_outer Source Code forlab_linalg_outer.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_outer implicit none contains module procedure outer_int8 integer :: m , n m = size ( x ) n = size ( y ) allocate ( outer_int8 , & source = spread ( x , 2 , n ) * spread ( y , 1 , m )) end procedure outer_int8 module procedure outer_int16 integer :: m , n m = size ( x ) n = size ( y ) allocate ( outer_int16 , & source = spread ( x , 2 , n ) * spread ( y , 1 , m )) end procedure outer_int16 module procedure outer_int32 integer :: m , n m = size ( x ) n = size ( y ) allocate ( outer_int32 , & source = spread ( x , 2 , n ) * spread ( y , 1 , m )) end procedure outer_int32 module procedure outer_int64 integer :: m , n m = size ( x ) n = size ( y ) allocate ( outer_int64 , & source = spread ( x , 2 , n ) * spread ( y , 1 , m )) end procedure outer_int64 module procedure outer_sp integer :: m , n m = size ( x ) n = size ( y ) allocate ( outer_sp , & source = spread ( x , 2 , n ) * spread ( y , 1 , m )) end procedure outer_sp module procedure outer_dp integer :: m , n m = size ( x ) n = size ( y ) allocate ( outer_dp , & source = spread ( x , 2 , n ) * spread ( y , 1 , m )) end procedure outer_dp module procedure outer_qp integer :: m , n m = size ( x ) n = size ( y ) allocate ( outer_qp , & source = spread ( x , 2 , n ) * spread ( y , 1 , m )) end procedure outer_qp end submodule forlab_linalg_outer","tags":"","loc":"sourcefile/forlab_linalg_outer.f90.html"},{"title":"forlab_io_bin.f90 – FORLAB","text":"Contents Submodules forlab_io_bin Source Code forlab_io_bin.f90 Source Code submodule ( forlab_io ) forlab_io_bin implicit none contains module procedure loadbin_1_rsp type ( file ) :: infile character ( * ), parameter :: type = 'rsp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 1 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 1 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_1_rsp module procedure loadbin_1_rdp type ( file ) :: infile character ( * ), parameter :: type = 'rdp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 1 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 1 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_1_rdp module procedure loadbin_1_rqp type ( file ) :: infile character ( * ), parameter :: type = 'rqp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 1 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 1 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_1_rqp module procedure loadbin_1_iint8 type ( file ) :: infile character ( * ), parameter :: type = 'iint8' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 1 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 1 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_1_iint8 module procedure loadbin_1_iint16 type ( file ) :: infile character ( * ), parameter :: type = 'iint16' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 1 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 1 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_1_iint16 module procedure loadbin_1_iint32 type ( file ) :: infile character ( * ), parameter :: type = 'iint32' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 1 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 1 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_1_iint32 module procedure loadbin_1_iint64 type ( file ) :: infile character ( * ), parameter :: type = 'iint64' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 1 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 1 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_1_iint64 module procedure loadbin_1_csp type ( file ) :: infile character ( * ), parameter :: type = 'csp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim real ( sp ), allocatable :: rp (:), ip (:) infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 1 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 1 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ))) allocate ( rp ( nsize ( 1 ))) allocate ( ip ( nsize ( 1 ))) read ( infile % unit ) rp , ip X = cmplx ( rp , ip , sp ) call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_1_csp module procedure loadbin_1_cdp type ( file ) :: infile character ( * ), parameter :: type = 'cdp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim real ( dp ), allocatable :: rp (:), ip (:) infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 1 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 1 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ))) allocate ( rp ( nsize ( 1 ))) allocate ( ip ( nsize ( 1 ))) read ( infile % unit ) rp , ip X = cmplx ( rp , ip , dp ) call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_1_cdp module procedure loadbin_1_cqp type ( file ) :: infile character ( * ), parameter :: type = 'cqp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim real ( qp ), allocatable :: rp (:), ip (:) infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 1 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 1 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ))) allocate ( rp ( nsize ( 1 ))) allocate ( ip ( nsize ( 1 ))) read ( infile % unit ) rp , ip X = cmplx ( rp , ip , qp ) call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_1_cqp module procedure loadbin_2_rsp type ( file ) :: infile character ( * ), parameter :: type = 'rsp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 2 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 2 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_2_rsp module procedure loadbin_2_rdp type ( file ) :: infile character ( * ), parameter :: type = 'rdp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 2 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 2 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_2_rdp module procedure loadbin_2_rqp type ( file ) :: infile character ( * ), parameter :: type = 'rqp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 2 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 2 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_2_rqp module procedure loadbin_2_iint8 type ( file ) :: infile character ( * ), parameter :: type = 'iint8' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 2 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 2 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_2_iint8 module procedure loadbin_2_iint16 type ( file ) :: infile character ( * ), parameter :: type = 'iint16' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 2 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 2 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_2_iint16 module procedure loadbin_2_iint32 type ( file ) :: infile character ( * ), parameter :: type = 'iint32' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 2 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 2 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_2_iint32 module procedure loadbin_2_iint64 type ( file ) :: infile character ( * ), parameter :: type = 'iint64' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 2 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 2 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_2_iint64 module procedure loadbin_2_csp type ( file ) :: infile character ( * ), parameter :: type = 'csp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim real ( sp ), allocatable :: rp (:,:), ip (:,:) infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 2 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 2 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) allocate ( rp ( nsize ( 1 ), nsize ( 2 ))) allocate ( ip ( nsize ( 1 ), nsize ( 2 ))) read ( infile % unit ) rp , ip X = cmplx ( rp , ip , sp ) call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_2_csp module procedure loadbin_2_cdp type ( file ) :: infile character ( * ), parameter :: type = 'cdp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim real ( dp ), allocatable :: rp (:,:), ip (:,:) infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 2 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 2 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) allocate ( rp ( nsize ( 1 ), nsize ( 2 ))) allocate ( ip ( nsize ( 1 ), nsize ( 2 ))) read ( infile % unit ) rp , ip X = cmplx ( rp , ip , dp ) call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_2_cdp module procedure loadbin_2_cqp type ( file ) :: infile character ( * ), parameter :: type = 'cqp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim real ( qp ), allocatable :: rp (:,:), ip (:,:) infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 2 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 2 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) allocate ( rp ( nsize ( 1 ), nsize ( 2 ))) allocate ( ip ( nsize ( 1 ), nsize ( 2 ))) read ( infile % unit ) rp , ip X = cmplx ( rp , ip , qp ) call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_2_cqp module procedure loadbin_3_rsp type ( file ) :: infile character ( * ), parameter :: type = 'rsp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 3 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 3 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 3 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_3_rsp module procedure loadbin_3_rdp type ( file ) :: infile character ( * ), parameter :: type = 'rdp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 3 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 3 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 3 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_3_rdp module procedure loadbin_3_rqp type ( file ) :: infile character ( * ), parameter :: type = 'rqp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 3 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 3 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 3 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_3_rqp module procedure loadbin_3_iint8 type ( file ) :: infile character ( * ), parameter :: type = 'iint8' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 3 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 3 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 3 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_3_iint8 module procedure loadbin_3_iint16 type ( file ) :: infile character ( * ), parameter :: type = 'iint16' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 3 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 3 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 3 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_3_iint16 module procedure loadbin_3_iint32 type ( file ) :: infile character ( * ), parameter :: type = 'iint32' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 3 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 3 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 3 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_3_iint32 module procedure loadbin_3_iint64 type ( file ) :: infile character ( * ), parameter :: type = 'iint64' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 3 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 3 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 3 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) read ( infile % unit ) X call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_3_iint64 module procedure loadbin_3_csp type ( file ) :: infile character ( * ), parameter :: type = 'csp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim real ( sp ), allocatable :: rp (:,:,:), ip (:,:,:) infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 3 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 3 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 3 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) allocate ( rp ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) allocate ( ip ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) read ( infile % unit ) rp , ip X = cmplx ( rp , ip , sp ) call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_3_csp module procedure loadbin_3_cdp type ( file ) :: infile character ( * ), parameter :: type = 'cdp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim real ( dp ), allocatable :: rp (:,:,:), ip (:,:,:) infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 3 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 3 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 3 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) allocate ( rp ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) allocate ( ip ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) read ( infile % unit ) rp , ip X = cmplx ( rp , ip , dp ) call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_3_cdp module procedure loadbin_3_cqp type ( file ) :: infile character ( * ), parameter :: type = 'cqp' integer , allocatable :: nsize (:) character ( 8 ) :: datatype integer :: data_dim real ( qp ), allocatable :: rp (:,:,:), ip (:,:,:) infile = file ( filename , 'r b' ) if ( infile % exist ()) then call infile % open () read ( infile % unit ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call disp ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & ' stored an array with a ' // datatype // '.' ) stop endif if ( data_dim /= 3 ) then call disp ( 'Error: The program failed to read the ' & // to_string ( 3 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions ' & // to_string ( data_dim ) // '.' ) stop endif allocate ( nsize ( 3 )) read ( infile % unit ) nsize (:) allocate ( X ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) allocate ( rp ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) allocate ( ip ( nsize ( 1 ), nsize ( 2 ), nsize ( 3 ))) read ( infile % unit ) rp , ip X = cmplx ( rp , ip , qp ) call infile % close () else print * , \"Error: '\" // trim ( filename ) // \"' not found\" stop end if return end procedure loadbin_3_cqp module procedure savebin_1_rsp type ( File ) :: outfile character ( 8 ), parameter :: type = 'rsp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 1 , 4 ) write ( outfile % unit ) size ( X , 1 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_1_rsp module procedure savebin_1_rdp type ( File ) :: outfile character ( 8 ), parameter :: type = 'rdp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 1 , 4 ) write ( outfile % unit ) size ( X , 1 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_1_rdp module procedure savebin_1_rqp type ( File ) :: outfile character ( 8 ), parameter :: type = 'rqp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 1 , 4 ) write ( outfile % unit ) size ( X , 1 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_1_rqp module procedure savebin_1_iint8 type ( File ) :: outfile character ( 8 ), parameter :: type = 'iint8' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 1 , 4 ) write ( outfile % unit ) size ( X , 1 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_1_iint8 module procedure savebin_1_iint16 type ( File ) :: outfile character ( 8 ), parameter :: type = 'iint16' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 1 , 4 ) write ( outfile % unit ) size ( X , 1 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_1_iint16 module procedure savebin_1_iint32 type ( File ) :: outfile character ( 8 ), parameter :: type = 'iint32' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 1 , 4 ) write ( outfile % unit ) size ( X , 1 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_1_iint32 module procedure savebin_1_iint64 type ( File ) :: outfile character ( 8 ), parameter :: type = 'iint64' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 1 , 4 ) write ( outfile % unit ) size ( X , 1 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_1_iint64 module procedure savebin_1_csp type ( File ) :: outfile character ( 8 ), parameter :: type = 'csp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 1 , 4 ) write ( outfile % unit ) size ( X , 1 ) write ( outfile % unit ) real ( X ), imag ( X ) !! Precision call outfile % close () return end procedure savebin_1_csp module procedure savebin_1_cdp type ( File ) :: outfile character ( 8 ), parameter :: type = 'cdp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 1 , 4 ) write ( outfile % unit ) size ( X , 1 ) write ( outfile % unit ) real ( X ), imag ( X ) !! Precision call outfile % close () return end procedure savebin_1_cdp module procedure savebin_1_cqp type ( File ) :: outfile character ( 8 ), parameter :: type = 'cqp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 1 , 4 ) write ( outfile % unit ) size ( X , 1 ) write ( outfile % unit ) real ( X ), imag ( X ) !! Precision call outfile % close () return end procedure savebin_1_cqp module procedure savebin_2_rsp type ( File ) :: outfile character ( 8 ), parameter :: type = 'rsp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 2 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_2_rsp module procedure savebin_2_rdp type ( File ) :: outfile character ( 8 ), parameter :: type = 'rdp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 2 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_2_rdp module procedure savebin_2_rqp type ( File ) :: outfile character ( 8 ), parameter :: type = 'rqp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 2 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_2_rqp module procedure savebin_2_iint8 type ( File ) :: outfile character ( 8 ), parameter :: type = 'iint8' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 2 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_2_iint8 module procedure savebin_2_iint16 type ( File ) :: outfile character ( 8 ), parameter :: type = 'iint16' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 2 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_2_iint16 module procedure savebin_2_iint32 type ( File ) :: outfile character ( 8 ), parameter :: type = 'iint32' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 2 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_2_iint32 module procedure savebin_2_iint64 type ( File ) :: outfile character ( 8 ), parameter :: type = 'iint64' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 2 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_2_iint64 module procedure savebin_2_csp type ( File ) :: outfile character ( 8 ), parameter :: type = 'csp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 2 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ) write ( outfile % unit ) real ( X ), imag ( X ) !! Precision call outfile % close () return end procedure savebin_2_csp module procedure savebin_2_cdp type ( File ) :: outfile character ( 8 ), parameter :: type = 'cdp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 2 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ) write ( outfile % unit ) real ( X ), imag ( X ) !! Precision call outfile % close () return end procedure savebin_2_cdp module procedure savebin_2_cqp type ( File ) :: outfile character ( 8 ), parameter :: type = 'cqp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 2 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ) write ( outfile % unit ) real ( X ), imag ( X ) !! Precision call outfile % close () return end procedure savebin_2_cqp module procedure savebin_3_rsp type ( File ) :: outfile character ( 8 ), parameter :: type = 'rsp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 3 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ), size ( X , 3 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_3_rsp module procedure savebin_3_rdp type ( File ) :: outfile character ( 8 ), parameter :: type = 'rdp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 3 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ), size ( X , 3 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_3_rdp module procedure savebin_3_rqp type ( File ) :: outfile character ( 8 ), parameter :: type = 'rqp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 3 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ), size ( X , 3 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_3_rqp module procedure savebin_3_iint8 type ( File ) :: outfile character ( 8 ), parameter :: type = 'iint8' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 3 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ), size ( X , 3 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_3_iint8 module procedure savebin_3_iint16 type ( File ) :: outfile character ( 8 ), parameter :: type = 'iint16' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 3 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ), size ( X , 3 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_3_iint16 module procedure savebin_3_iint32 type ( File ) :: outfile character ( 8 ), parameter :: type = 'iint32' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 3 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ), size ( X , 3 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_3_iint32 module procedure savebin_3_iint64 type ( File ) :: outfile character ( 8 ), parameter :: type = 'iint64' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 3 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ), size ( X , 3 ) write ( outfile % unit ) X call outfile % close () return end procedure savebin_3_iint64 module procedure savebin_3_csp type ( File ) :: outfile character ( 8 ), parameter :: type = 'csp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 3 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ), size ( X , 3 ) write ( outfile % unit ) real ( X ), imag ( X ) !! Precision call outfile % close () return end procedure savebin_3_csp module procedure savebin_3_cdp type ( File ) :: outfile character ( 8 ), parameter :: type = 'cdp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 3 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ), size ( X , 3 ) write ( outfile % unit ) real ( X ), imag ( X ) !! Precision call outfile % close () return end procedure savebin_3_cdp module procedure savebin_3_cqp type ( File ) :: outfile character ( 8 ), parameter :: type = 'cqp' outfile = file ( filename , 'w b' ) call outfile % open () write ( outfile % unit ) type , int ( 3 , 4 ) write ( outfile % unit ) size ( X , 1 ), size ( X , 2 ), size ( X , 3 ) write ( outfile % unit ) real ( X ), imag ( X ) !! Precision call outfile % close () return end procedure savebin_3_cqp end submodule","tags":"","loc":"sourcefile/forlab_io_bin.f90.html"},{"title":"forlab_math_arange.f90 – FORLAB","text":"Contents Submodules forlab_math_arange Source Code forlab_math_arange.f90 Source Code submodule ( forlab_math ) forlab_math_arange contains pure module function arange_r_sp ( start , end , step ) result ( result ) real ( sp ), intent ( in ) :: start real ( sp ), intent ( in ), optional :: end , step real ( sp ), allocatable :: result (:) real ( sp ) :: start_ , end_ , step_ integer :: i start_ = merge ( start , 1.0_sp , present ( end )) end_ = optval ( end , start ) step_ = optval ( step , 1.0_sp ) step_ = sign ( merge ( step_ , 1.0_sp , step_ /= 0.0_sp ), end_ - start_ ) allocate ( result ( floor (( end_ - start_ ) / step_ ) + 1 )) result = [( start_ + ( i - 1 ) * step_ , i = 1 , size ( result ), 1 )] end function arange_r_sp pure module function arange_r_dp ( start , end , step ) result ( result ) real ( dp ), intent ( in ) :: start real ( dp ), intent ( in ), optional :: end , step real ( dp ), allocatable :: result (:) real ( dp ) :: start_ , end_ , step_ integer :: i start_ = merge ( start , 1.0_dp , present ( end )) end_ = optval ( end , start ) step_ = optval ( step , 1.0_dp ) step_ = sign ( merge ( step_ , 1.0_dp , step_ /= 0.0_dp ), end_ - start_ ) allocate ( result ( floor (( end_ - start_ ) / step_ ) + 1 )) result = [( start_ + ( i - 1 ) * step_ , i = 1 , size ( result ), 1 )] end function arange_r_dp pure module function arange_r_qp ( start , end , step ) result ( result ) real ( qp ), intent ( in ) :: start real ( qp ), intent ( in ), optional :: end , step real ( qp ), allocatable :: result (:) real ( qp ) :: start_ , end_ , step_ integer :: i start_ = merge ( start , 1.0_qp , present ( end )) end_ = optval ( end , start ) step_ = optval ( step , 1.0_qp ) step_ = sign ( merge ( step_ , 1.0_qp , step_ /= 0.0_qp ), end_ - start_ ) allocate ( result ( floor (( end_ - start_ ) / step_ ) + 1 )) result = [( start_ + ( i - 1 ) * step_ , i = 1 , size ( result ), 1 )] end function arange_r_qp !> `arange` creates a vector of the `integer(int8)` type !>  with evenly spaced values within a given interval. pure module function arange_i_int8 ( start , end , step ) result ( result ) integer ( int8 ), intent ( in ) :: start integer ( int8 ), intent ( in ), optional :: end , step integer ( int8 ), allocatable :: result (:) integer ( int8 ) :: start_ , end_ , step_ integer ( int8 ) :: i start_ = merge ( start , 1_int8 , present ( end )) end_ = optval ( end , start ) step_ = optval ( step , 1_int8 ) step_ = sign ( merge ( step_ , 1_int8 , step_ /= 0_int8 ), end_ - start_ ) allocate ( result (( end_ - start_ ) / step_ + 1_int8 )) result = [( i , i = start_ , end_ , step_ )] end function arange_i_int8 !> `arange` creates a vector of the `integer(int16)` type !>  with evenly spaced values within a given interval. pure module function arange_i_int16 ( start , end , step ) result ( result ) integer ( int16 ), intent ( in ) :: start integer ( int16 ), intent ( in ), optional :: end , step integer ( int16 ), allocatable :: result (:) integer ( int16 ) :: start_ , end_ , step_ integer ( int16 ) :: i start_ = merge ( start , 1_int16 , present ( end )) end_ = optval ( end , start ) step_ = optval ( step , 1_int16 ) step_ = sign ( merge ( step_ , 1_int16 , step_ /= 0_int16 ), end_ - start_ ) allocate ( result (( end_ - start_ ) / step_ + 1_int16 )) result = [( i , i = start_ , end_ , step_ )] end function arange_i_int16 !> `arange` creates a vector of the `integer(int32)` type !>  with evenly spaced values within a given interval. pure module function arange_i_int32 ( start , end , step ) result ( result ) integer ( int32 ), intent ( in ) :: start integer ( int32 ), intent ( in ), optional :: end , step integer ( int32 ), allocatable :: result (:) integer ( int32 ) :: start_ , end_ , step_ integer ( int32 ) :: i start_ = merge ( start , 1_int32 , present ( end )) end_ = optval ( end , start ) step_ = optval ( step , 1_int32 ) step_ = sign ( merge ( step_ , 1_int32 , step_ /= 0_int32 ), end_ - start_ ) allocate ( result (( end_ - start_ ) / step_ + 1_int32 )) result = [( i , i = start_ , end_ , step_ )] end function arange_i_int32 !> `arange` creates a vector of the `integer(int64)` type !>  with evenly spaced values within a given interval. pure module function arange_i_int64 ( start , end , step ) result ( result ) integer ( int64 ), intent ( in ) :: start integer ( int64 ), intent ( in ), optional :: end , step integer ( int64 ), allocatable :: result (:) integer ( int64 ) :: start_ , end_ , step_ integer ( int64 ) :: i start_ = merge ( start , 1_int64 , present ( end )) end_ = optval ( end , start ) step_ = optval ( step , 1_int64 ) step_ = sign ( merge ( step_ , 1_int64 , step_ /= 0_int64 ), end_ - start_ ) allocate ( result (( end_ - start_ ) / step_ + 1_int64 )) result = [( i , i = start_ , end_ , step_ )] end function arange_i_int64 end submodule forlab_math_arange","tags":"","loc":"sourcefile/forlab_math_arange.f90.html"},{"title":"forlab_math_all_close.f90 – FORLAB","text":"Contents Submodules forlab_math_all_close Source Code forlab_math_all_close.f90 Source Code submodule ( forlab_math ) forlab_math_all_close implicit none character ( * ), parameter :: error_1 = \"*<ERROR>* The ranks of `a` and `b` in `all_close` are not equal.\" character ( * ), parameter :: error_2 = \"*<ERROR>* The rank of `a` in `all_close` is too large to be supported.\" contains logical module function all_close_rsp ( a , b , rel_tol , abs_tol ) result ( close ) real ( sp ), intent ( in ) :: a (..), b (..) real ( sp ), intent ( in ), optional :: rel_tol , abs_tol select rank ( a ) rank ( 1 ) select rank ( b ) rank ( 1 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 2 ) select rank ( b ) rank ( 2 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 3 ) select rank ( b ) rank ( 3 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 4 ) select rank ( b ) rank ( 4 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank default error stop error_2 end select end function all_close_rsp logical module function all_close_rdp ( a , b , rel_tol , abs_tol ) result ( close ) real ( dp ), intent ( in ) :: a (..), b (..) real ( dp ), intent ( in ), optional :: rel_tol , abs_tol select rank ( a ) rank ( 1 ) select rank ( b ) rank ( 1 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 2 ) select rank ( b ) rank ( 2 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 3 ) select rank ( b ) rank ( 3 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 4 ) select rank ( b ) rank ( 4 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank default error stop error_2 end select end function all_close_rdp logical module function all_close_rqp ( a , b , rel_tol , abs_tol ) result ( close ) real ( qp ), intent ( in ) :: a (..), b (..) real ( qp ), intent ( in ), optional :: rel_tol , abs_tol select rank ( a ) rank ( 1 ) select rank ( b ) rank ( 1 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 2 ) select rank ( b ) rank ( 2 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 3 ) select rank ( b ) rank ( 3 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 4 ) select rank ( b ) rank ( 4 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank default error stop error_2 end select end function all_close_rqp logical module function all_close_csp ( a , b , rel_tol , abs_tol ) result ( close ) complex ( sp ), intent ( in ) :: a (..), b (..) real ( sp ), intent ( in ), optional :: rel_tol , abs_tol select rank ( a ) rank ( 1 ) select rank ( b ) rank ( 1 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 2 ) select rank ( b ) rank ( 2 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 3 ) select rank ( b ) rank ( 3 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 4 ) select rank ( b ) rank ( 4 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank default error stop error_2 end select end function all_close_csp logical module function all_close_cdp ( a , b , rel_tol , abs_tol ) result ( close ) complex ( dp ), intent ( in ) :: a (..), b (..) real ( dp ), intent ( in ), optional :: rel_tol , abs_tol select rank ( a ) rank ( 1 ) select rank ( b ) rank ( 1 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 2 ) select rank ( b ) rank ( 2 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 3 ) select rank ( b ) rank ( 3 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 4 ) select rank ( b ) rank ( 4 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank default error stop error_2 end select end function all_close_cdp logical module function all_close_cqp ( a , b , rel_tol , abs_tol ) result ( close ) complex ( qp ), intent ( in ) :: a (..), b (..) real ( qp ), intent ( in ), optional :: rel_tol , abs_tol select rank ( a ) rank ( 1 ) select rank ( b ) rank ( 1 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 2 ) select rank ( b ) rank ( 2 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 3 ) select rank ( b ) rank ( 3 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank ( 4 ) select rank ( b ) rank ( 4 ) close = all ( is_close ( a , b , rel_tol , abs_tol )) rank default error stop error_1 end select rank default error stop error_2 end select end function all_close_cqp end submodule forlab_math_all_close","tags":"","loc":"sourcefile/forlab_math_all_close.f90.html"},{"title":"forlab_math.f90 – FORLAB","text":"Contents Modules forlab_math Source Code forlab_math.f90 Source Code module forlab_math use stdlib_kinds , only : sp , dp , qp , int8 , int16 , int32 , int64 use stdlib_optval , only : optval implicit none private public :: angle public :: cosd , sind , tand public :: acosd , asind , atand public :: arange , signum public :: is_close , all_close interface acosd !! degree circular functions pure elemental module function acosd_sp ( x ) real ( sp ), intent ( in ) :: x real ( sp ) :: acosd_sp end function acosd_sp pure elemental module function acosd_dp ( x ) real ( dp ), intent ( in ) :: x real ( dp ) :: acosd_dp end function acosd_dp pure elemental module function acosd_qp ( x ) real ( qp ), intent ( in ) :: x real ( qp ) :: acosd_qp end function acosd_qp end interface acosd interface asind !! degree circular functions pure elemental module function asind_sp ( x ) real ( sp ), intent ( in ) :: x real ( sp ) :: asind_sp end function asind_sp pure elemental module function asind_dp ( x ) real ( dp ), intent ( in ) :: x real ( dp ) :: asind_dp end function asind_dp pure elemental module function asind_qp ( x ) real ( qp ), intent ( in ) :: x real ( qp ) :: asind_qp end function asind_qp end interface asind interface atand !! degree circular functions pure elemental module function atand_sp ( x ) real ( sp ), intent ( in ) :: x real ( sp ) :: atand_sp end function atand_sp pure elemental module function atand_dp ( x ) real ( dp ), intent ( in ) :: x real ( dp ) :: atand_dp end function atand_dp pure elemental module function atand_qp ( x ) real ( qp ), intent ( in ) :: x real ( qp ) :: atand_qp end function atand_qp end interface atand interface cosd pure elemental module function cosd_sp ( x ) real ( sp ), intent ( in ) :: x real ( sp ) :: cosd_sp end function cosd_sp pure elemental module function cosd_dp ( x ) real ( dp ), intent ( in ) :: x real ( dp ) :: cosd_dp end function cosd_dp pure elemental module function cosd_qp ( x ) real ( qp ), intent ( in ) :: x real ( qp ) :: cosd_qp end function cosd_qp end interface cosd interface sind pure elemental module function sind_sp ( x ) real ( sp ), intent ( in ) :: x real ( sp ) :: sind_sp end function sind_sp pure elemental module function sind_dp ( x ) real ( dp ), intent ( in ) :: x real ( dp ) :: sind_dp end function sind_dp pure elemental module function sind_qp ( x ) real ( qp ), intent ( in ) :: x real ( qp ) :: sind_qp end function sind_qp end interface sind interface tand pure elemental module function tand_sp ( x ) real ( sp ), intent ( in ) :: x real ( sp ) :: tand_sp end function tand_sp pure elemental module function tand_dp ( x ) real ( dp ), intent ( in ) :: x real ( dp ) :: tand_dp end function tand_dp pure elemental module function tand_qp ( x ) real ( qp ), intent ( in ) :: x real ( qp ) :: tand_qp end function tand_qp end interface tand interface angle !! Version: experimental !! !! angle compute the phase angle. !!([Interface](../interface/angle.html)) procedure :: angle_sp procedure :: angle_dp procedure :: angle_qp end interface angle !> Version: experimental !> !> Returns a boolean scalar/array where two scalar/arrays are element-wise equal within a tolerance. !> ([Specification](../page/specs/forlab_math.html#is_close)) interface is_close elemental module function is_close_rsp ( a , b , rel_tol , abs_tol ) result ( close ) real ( sp ), intent ( in ) :: a , b real ( sp ), intent ( in ), optional :: rel_tol , abs_tol logical :: close end function is_close_rsp elemental module function is_close_rdp ( a , b , rel_tol , abs_tol ) result ( close ) real ( dp ), intent ( in ) :: a , b real ( dp ), intent ( in ), optional :: rel_tol , abs_tol logical :: close end function is_close_rdp elemental module function is_close_rqp ( a , b , rel_tol , abs_tol ) result ( close ) real ( qp ), intent ( in ) :: a , b real ( qp ), intent ( in ), optional :: rel_tol , abs_tol logical :: close end function is_close_rqp elemental module function is_close_csp ( a , b , rel_tol , abs_tol ) result ( close ) complex ( sp ), intent ( in ) :: a , b real ( sp ), intent ( in ), optional :: rel_tol , abs_tol logical :: close end function is_close_csp elemental module function is_close_cdp ( a , b , rel_tol , abs_tol ) result ( close ) complex ( dp ), intent ( in ) :: a , b real ( dp ), intent ( in ), optional :: rel_tol , abs_tol logical :: close end function is_close_cdp elemental module function is_close_cqp ( a , b , rel_tol , abs_tol ) result ( close ) complex ( qp ), intent ( in ) :: a , b real ( qp ), intent ( in ), optional :: rel_tol , abs_tol logical :: close end function is_close_cqp end interface is_close !> Version: experimental !> !> Returns a boolean scalar where two arrays are element-wise equal within a tolerance. !> ([Specification](../page/specs/forlab_math.html#all_close)) interface all_close logical module function all_close_rsp ( a , b , rel_tol , abs_tol ) result ( close ) real ( sp ), intent ( in ) :: a (..), b (..) real ( sp ), intent ( in ), optional :: rel_tol , abs_tol end function all_close_rsp logical module function all_close_rdp ( a , b , rel_tol , abs_tol ) result ( close ) real ( dp ), intent ( in ) :: a (..), b (..) real ( dp ), intent ( in ), optional :: rel_tol , abs_tol end function all_close_rdp logical module function all_close_rqp ( a , b , rel_tol , abs_tol ) result ( close ) real ( qp ), intent ( in ) :: a (..), b (..) real ( qp ), intent ( in ), optional :: rel_tol , abs_tol end function all_close_rqp logical module function all_close_csp ( a , b , rel_tol , abs_tol ) result ( close ) complex ( sp ), intent ( in ) :: a (..), b (..) real ( sp ), intent ( in ), optional :: rel_tol , abs_tol end function all_close_csp logical module function all_close_cdp ( a , b , rel_tol , abs_tol ) result ( close ) complex ( dp ), intent ( in ) :: a (..), b (..) real ( dp ), intent ( in ), optional :: rel_tol , abs_tol end function all_close_cdp logical module function all_close_cqp ( a , b , rel_tol , abs_tol ) result ( close ) complex ( qp ), intent ( in ) :: a (..), b (..) real ( qp ), intent ( in ), optional :: rel_tol , abs_tol end function all_close_cqp end interface all_close !> Version: experimental !> !> `arange` creates a rank-1 `array` of the `integer/real` type !>  with fixed-spaced values of given spacing, within a given interval. !> ([Specification](../page/specs/forlab_math.html#arange)) interface arange pure module function arange_r_sp ( start , end , step ) result ( result ) real ( sp ), intent ( in ) :: start real ( sp ), intent ( in ), optional :: end , step real ( sp ), allocatable :: result (:) end function arange_r_sp pure module function arange_r_dp ( start , end , step ) result ( result ) real ( dp ), intent ( in ) :: start real ( dp ), intent ( in ), optional :: end , step real ( dp ), allocatable :: result (:) end function arange_r_dp pure module function arange_r_qp ( start , end , step ) result ( result ) real ( qp ), intent ( in ) :: start real ( qp ), intent ( in ), optional :: end , step real ( qp ), allocatable :: result (:) end function arange_r_qp pure module function arange_i_int8 ( start , end , step ) result ( result ) integer ( int8 ), intent ( in ) :: start integer ( int8 ), intent ( in ), optional :: end , step integer ( int8 ), allocatable :: result (:) end function arange_i_int8 pure module function arange_i_int16 ( start , end , step ) result ( result ) integer ( int16 ), intent ( in ) :: start integer ( int16 ), intent ( in ), optional :: end , step integer ( int16 ), allocatable :: result (:) end function arange_i_int16 pure module function arange_i_int32 ( start , end , step ) result ( result ) integer ( int32 ), intent ( in ) :: start integer ( int32 ), intent ( in ), optional :: end , step integer ( int32 ), allocatable :: result (:) end function arange_i_int32 pure module function arange_i_int64 ( start , end , step ) result ( result ) integer ( int64 ), intent ( in ) :: start integer ( int64 ), intent ( in ), optional :: end , step integer ( int64 ), allocatable :: result (:) end function arange_i_int64 end interface arange !> Version: experimental !> !> `signum` returns the sign of variables. !> ([Specification](../page/specs/forlab_math.html#signum)) interface signum real ( sp ) elemental module function signum_rsp ( x ) result ( sign ) real ( sp ), intent ( in ) :: x end function signum_rsp real ( dp ) elemental module function signum_rdp ( x ) result ( sign ) real ( dp ), intent ( in ) :: x end function signum_rdp real ( qp ) elemental module function signum_rqp ( x ) result ( sign ) real ( qp ), intent ( in ) :: x end function signum_rqp integer ( int8 ) elemental module function signum_iint8 ( x ) result ( sign ) integer ( int8 ), intent ( in ) :: x end function signum_iint8 integer ( int16 ) elemental module function signum_iint16 ( x ) result ( sign ) integer ( int16 ), intent ( in ) :: x end function signum_iint16 integer ( int32 ) elemental module function signum_iint32 ( x ) result ( sign ) integer ( int32 ), intent ( in ) :: x end function signum_iint32 integer ( int64 ) elemental module function signum_iint64 ( x ) result ( sign ) integer ( int64 ), intent ( in ) :: x end function signum_iint64 complex ( sp ) elemental module function signum_csp ( x ) result ( sign ) complex ( sp ), intent ( in ) :: x end function signum_csp complex ( dp ) elemental module function signum_cdp ( x ) result ( sign ) complex ( dp ), intent ( in ) :: x end function signum_cdp complex ( qp ) elemental module function signum_cqp ( x ) result ( sign ) complex ( qp ), intent ( in ) :: x end function signum_cqp end interface signum contains elemental function angle_sp ( value ) result ( angle ) real ( sp ) :: angle complex ( sp ), intent ( in ) :: value angle = aimag ( log ( value )) end function angle_sp elemental function angle_dp ( value ) result ( angle ) real ( dp ) :: angle complex ( dp ), intent ( in ) :: value angle = aimag ( log ( value )) end function angle_dp elemental function angle_qp ( value ) result ( angle ) real ( qp ) :: angle complex ( qp ), intent ( in ) :: value angle = aimag ( log ( value )) end function angle_qp end module forlab_math","tags":"","loc":"sourcefile/forlab_math.f90.html"},{"title":"forlab_stats_rng.f90 – FORLAB","text":"Contents Submodules forlab_stats_rng Source Code forlab_stats_rng.f90 Source Code submodule ( forlab_stats ) forlab_stats_rng implicit none contains module procedure rng integer :: seed_size , values ( 8 ) integer , dimension (:), allocatable :: seed_put call random_seed ( size = seed_size ) allocate ( seed_put ( seed_size )) if ( present ( seed )) then seed_put = seed else call date_and_time ( values = values ) seed_put = values ( 8 ) * values ( 7 ) * values ( 6 ) end if call random_seed ( put = seed_put ) return end procedure rng end submodule forlab_stats_rng","tags":"","loc":"sourcefile/forlab_stats_rng.f90.html"},{"title":"forlab_linalg_qr.f90 – FORLAB","text":"Contents Submodules forlab_linalg_qr Source Code forlab_linalg_qr.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_qr implicit none contains module procedure qr_sp real ( sp ), allocatable :: v (:) integer :: i , j , k , m , n , nn , templ real ( sp ) :: alpha , t , u real ( sp ), parameter :: eps = epsilon ( 1.0_sp ), zero = 0.0_sp , one = 1.0_sp m = size ( a , 1 ) n = size ( a , 2 ) if ( m < n ) then call error_stop ( \"Error:Matrix a dimension m < n \" ) end if if ( present ( l )) then templ = l else templ = 1 end if select case ( templ ) case ( 1 ) r = a allocate ( q ( m , m )) q = zero r = a forall ( i = 1 : m ) q ( i , i ) = one end forall nn = n if ( m == n ) nn = m - 1 do k = 1 , nn u = zero do i = k , m if ( abs ( r ( i , k )) > u ) u = abs ( r ( i , k )) end do alpha = dot_product ( r ( k : m , k ), r ( k : m , k )) / ( u * u ) if ( r ( k , k ) > 0 ) u =- u alpha = u * sqrt ( alpha ) if ( abs ( alpha ) < eps ) then call error_stop ( \"Error:matrix r linearly dependent\" ) end if u = sqrt ( 2 * alpha * ( alpha - r ( k , k ))) if ( abs ( u ) > eps ) then r ( k , k ) = ( r ( k , k ) - alpha ) / u r ( k + 1 : m , k ) = r ( k + 1 : m , k ) / u do j = 1 , m t = dot_product ( r ( k : m , k ), q ( k : m , j )) q ( k : m , j ) = q ( k : m , j ) - 2 * r ( k : m , k ) * t end do do j = k + 1 , n t = dot_product ( r ( k : m , k ), r ( k : m , j )) r ( k : m , j ) = r ( k : m , j ) - 2 * r ( k : m , k ) * t end do r ( k , k ) = alpha r ( k + 1 : m , k ) = zero end if end do do i = 1 , m - 1 do j = i + 1 , m t = q ( i , j ) q ( i , j ) = q ( j , i ) q ( j , i ) = t end do end do case ( 2 ) allocate ( r ( n , n )) r = zero q = a v = q (:, 1 ) alpha = norm2 ( v ) q (:, 1 ) = v / alpha r ( 1 , 1 ) = alpha do i = 2 , n v = q (:, i ) do j = 1 , i - 1 alpha = dot_product ( q (:, i ), q (:, j )) v = v - alpha * q (:, j ) r ( j , i ) = alpha end do alpha = norm2 ( v ) if ( abs ( alpha ) < eps ) then call error_stop ( \"Error:Matrix q linearly dependent\" ) end if q (:, i ) = v / alpha r ( i , i ) = alpha end do case default call Error_stop ( \"Error: QR decomposition Type must be 1 or 2\" ) end select end procedure qr_sp module procedure qr_dp real ( dp ), allocatable :: v (:) integer :: i , j , k , m , n , nn , templ real ( dp ) :: alpha , t , u real ( dp ), parameter :: eps = epsilon ( 1.0_dp ), zero = 0.0_dp , one = 1.0_dp m = size ( a , 1 ) n = size ( a , 2 ) if ( m < n ) then call error_stop ( \"Error:Matrix a dimension m < n \" ) end if if ( present ( l )) then templ = l else templ = 1 end if select case ( templ ) case ( 1 ) r = a allocate ( q ( m , m )) q = zero r = a forall ( i = 1 : m ) q ( i , i ) = one end forall nn = n if ( m == n ) nn = m - 1 do k = 1 , nn u = zero do i = k , m if ( abs ( r ( i , k )) > u ) u = abs ( r ( i , k )) end do alpha = dot_product ( r ( k : m , k ), r ( k : m , k )) / ( u * u ) if ( r ( k , k ) > 0 ) u =- u alpha = u * sqrt ( alpha ) if ( abs ( alpha ) < eps ) then call error_stop ( \"Error:matrix r linearly dependent\" ) end if u = sqrt ( 2 * alpha * ( alpha - r ( k , k ))) if ( abs ( u ) > eps ) then r ( k , k ) = ( r ( k , k ) - alpha ) / u r ( k + 1 : m , k ) = r ( k + 1 : m , k ) / u do j = 1 , m t = dot_product ( r ( k : m , k ), q ( k : m , j )) q ( k : m , j ) = q ( k : m , j ) - 2 * r ( k : m , k ) * t end do do j = k + 1 , n t = dot_product ( r ( k : m , k ), r ( k : m , j )) r ( k : m , j ) = r ( k : m , j ) - 2 * r ( k : m , k ) * t end do r ( k , k ) = alpha r ( k + 1 : m , k ) = zero end if end do do i = 1 , m - 1 do j = i + 1 , m t = q ( i , j ) q ( i , j ) = q ( j , i ) q ( j , i ) = t end do end do case ( 2 ) allocate ( r ( n , n )) r = zero q = a v = q (:, 1 ) alpha = norm2 ( v ) q (:, 1 ) = v / alpha r ( 1 , 1 ) = alpha do i = 2 , n v = q (:, i ) do j = 1 , i - 1 alpha = dot_product ( q (:, i ), q (:, j )) v = v - alpha * q (:, j ) r ( j , i ) = alpha end do alpha = norm2 ( v ) if ( abs ( alpha ) < eps ) then call error_stop ( \"Error:Matrix q linearly dependent\" ) end if q (:, i ) = v / alpha r ( i , i ) = alpha end do case default call Error_stop ( \"Error: QR decomposition Type must be 1 or 2\" ) end select end procedure qr_dp module procedure qr_qp real ( qp ), allocatable :: v (:) integer :: i , j , k , m , n , nn , templ real ( qp ) :: alpha , t , u real ( qp ), parameter :: eps = epsilon ( 1.0_qp ), zero = 0.0_qp , one = 1.0_qp m = size ( a , 1 ) n = size ( a , 2 ) if ( m < n ) then call error_stop ( \"Error:Matrix a dimension m < n \" ) end if if ( present ( l )) then templ = l else templ = 1 end if select case ( templ ) case ( 1 ) r = a allocate ( q ( m , m )) q = zero r = a forall ( i = 1 : m ) q ( i , i ) = one end forall nn = n if ( m == n ) nn = m - 1 do k = 1 , nn u = zero do i = k , m if ( abs ( r ( i , k )) > u ) u = abs ( r ( i , k )) end do alpha = dot_product ( r ( k : m , k ), r ( k : m , k )) / ( u * u ) if ( r ( k , k ) > 0 ) u =- u alpha = u * sqrt ( alpha ) if ( abs ( alpha ) < eps ) then call error_stop ( \"Error:matrix r linearly dependent\" ) end if u = sqrt ( 2 * alpha * ( alpha - r ( k , k ))) if ( abs ( u ) > eps ) then r ( k , k ) = ( r ( k , k ) - alpha ) / u r ( k + 1 : m , k ) = r ( k + 1 : m , k ) / u do j = 1 , m t = dot_product ( r ( k : m , k ), q ( k : m , j )) q ( k : m , j ) = q ( k : m , j ) - 2 * r ( k : m , k ) * t end do do j = k + 1 , n t = dot_product ( r ( k : m , k ), r ( k : m , j )) r ( k : m , j ) = r ( k : m , j ) - 2 * r ( k : m , k ) * t end do r ( k , k ) = alpha r ( k + 1 : m , k ) = zero end if end do do i = 1 , m - 1 do j = i + 1 , m t = q ( i , j ) q ( i , j ) = q ( j , i ) q ( j , i ) = t end do end do case ( 2 ) allocate ( r ( n , n )) r = zero q = a v = q (:, 1 ) alpha = norm2 ( v ) q (:, 1 ) = v / alpha r ( 1 , 1 ) = alpha do i = 2 , n v = q (:, i ) do j = 1 , i - 1 alpha = dot_product ( q (:, i ), q (:, j )) v = v - alpha * q (:, j ) r ( j , i ) = alpha end do alpha = norm2 ( v ) if ( abs ( alpha ) < eps ) then call error_stop ( \"Error:Matrix q linearly dependent\" ) end if q (:, i ) = v / alpha r ( i , i ) = alpha end do case default call Error_stop ( \"Error: QR decomposition Type must be 1 or 2\" ) end select end procedure qr_qp end submodule forlab_linalg_qr","tags":"","loc":"sourcefile/forlab_linalg_qr.f90.html"},{"title":"forlab_stats_randn.f90 – FORLAB","text":"Contents Submodules forlab_stats_randn Source Code forlab_stats_randn.f90 Source Code submodule ( forlab_stats ) forlab_stats_randn implicit none contains module function randn_0_sp ( mean , std ) result ( random ) real ( sp ), intent ( in ) :: mean , std real ( sp ) :: random real ( sp ) :: u , v , s do call random_number ( u ) call random_number ( v ) u = 2._sp * u - 1._sp v = 2._sp * v - 1._sp s = u * u + v * v if (( s > 0._sp ) . and . ( s < 1._sp )) exit end do random = mean + u * sqrt ( - 2.0_sp * log ( s ) / s ) * std end function randn_0_sp module function randn_1_sp ( mean , std , ndim ) result ( random ) real ( sp ), intent ( in ) :: mean , std integer , intent ( in ) :: ndim real ( sp ) :: random ( ndim ) integer :: i do i = 1 , ndim random ( i ) = randn_0_sp ( mean , std ) end do end function randn_1_sp module function randn_0_dp ( mean , std ) result ( random ) real ( dp ), intent ( in ) :: mean , std real ( dp ) :: random real ( dp ) :: u , v , s do call random_number ( u ) call random_number ( v ) u = 2._dp * u - 1._dp v = 2._dp * v - 1._dp s = u * u + v * v if (( s > 0._dp ) . and . ( s < 1._dp )) exit end do random = mean + u * sqrt ( - 2.0_dp * log ( s ) / s ) * std end function randn_0_dp module function randn_1_dp ( mean , std , ndim ) result ( random ) real ( dp ), intent ( in ) :: mean , std integer , intent ( in ) :: ndim real ( dp ) :: random ( ndim ) integer :: i do i = 1 , ndim random ( i ) = randn_0_dp ( mean , std ) end do end function randn_1_dp module function randn_0_qp ( mean , std ) result ( random ) real ( qp ), intent ( in ) :: mean , std real ( qp ) :: random real ( qp ) :: u , v , s do call random_number ( u ) call random_number ( v ) u = 2._qp * u - 1._qp v = 2._qp * v - 1._qp s = u * u + v * v if (( s > 0._qp ) . and . ( s < 1._qp )) exit end do random = mean + u * sqrt ( - 2.0_qp * log ( s ) / s ) * std end function randn_0_qp module function randn_1_qp ( mean , std , ndim ) result ( random ) real ( qp ), intent ( in ) :: mean , std integer , intent ( in ) :: ndim real ( qp ) :: random ( ndim ) integer :: i do i = 1 , ndim random ( i ) = randn_0_qp ( mean , std ) end do end function randn_1_qp end submodule forlab_stats_randn","tags":"","loc":"sourcefile/forlab_stats_randn.f90.html"},{"title":"forlab_linalg_matpow.f90 – FORLAB","text":"Contents Submodules forlab_linalg_matpow Source Code forlab_linalg_matpow.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_matpow implicit none contains module procedure matpow_sp real ( sp ), allocatable :: a1 (:,:) real ( sp ), parameter :: zero = 0.0_sp , one = 1.0_sp integer :: i , n , m if (. not . is_square ( a )) then call error_stop ( \"Error:A must be a square matrix\" ) end if m = num if ( m < 0 ) then call error_stop ( \"Error: num must be a positive number\" ) end if n = size ( a , 1 ) allocate ( a1 ( n , n ), source = a ) allocate ( c ( n , n )) c = zero forall ( i = 1 : n ) c ( i , i ) = one end forall do if ( mod ( m , 2 ) == 1 ) then c = matmul ( c , a1 ) end if m = shiftr ( m , 1 ) if ( m == 0 ) exit a1 = matmul ( a1 , a1 ) end do deallocate ( a1 ) end procedure matpow_sp module procedure matpow_dp real ( dp ), allocatable :: a1 (:,:) real ( dp ), parameter :: zero = 0.0_dp , one = 1.0_dp integer :: i , n , m if (. not . is_square ( a )) then call error_stop ( \"Error:A must be a square matrix\" ) end if m = num if ( m < 0 ) then call error_stop ( \"Error: num must be a positive number\" ) end if n = size ( a , 1 ) allocate ( a1 ( n , n ), source = a ) allocate ( c ( n , n )) c = zero forall ( i = 1 : n ) c ( i , i ) = one end forall do if ( mod ( m , 2 ) == 1 ) then c = matmul ( c , a1 ) end if m = shiftr ( m , 1 ) if ( m == 0 ) exit a1 = matmul ( a1 , a1 ) end do deallocate ( a1 ) end procedure matpow_dp module procedure matpow_qp real ( qp ), allocatable :: a1 (:,:) real ( qp ), parameter :: zero = 0.0_qp , one = 1.0_qp integer :: i , n , m if (. not . is_square ( a )) then call error_stop ( \"Error:A must be a square matrix\" ) end if m = num if ( m < 0 ) then call error_stop ( \"Error: num must be a positive number\" ) end if n = size ( a , 1 ) allocate ( a1 ( n , n ), source = a ) allocate ( c ( n , n )) c = zero forall ( i = 1 : n ) c ( i , i ) = one end forall do if ( mod ( m , 2 ) == 1 ) then c = matmul ( c , a1 ) end if m = shiftr ( m , 1 ) if ( m == 0 ) exit a1 = matmul ( a1 , a1 ) end do deallocate ( a1 ) end procedure matpow_qp end submodule forlab_linalg_matpow","tags":"","loc":"sourcefile/forlab_linalg_matpow.f90.html"},{"title":"forlab_sorting_argsort.f90 – FORLAB","text":"Contents Submodules forlab_sorting_argsort Source Code forlab_sorting_argsort.f90 Source Code submodule ( forlab_sorting ) forlab_sorting_argsort implicit none contains module procedure argsort_int8 integer :: i , n integer ( int8 ), allocatable :: xsort (:) integer :: order1 n = size ( x ) xsort = x argsort_int8 = [( i , i = 1 , n )] if (. not . present ( order )) then order1 = 1 else order1 = order end if call quickargsort_int8 ( xsort , argsort_int8 , n , order1 ) end procedure argsort_int8 recursive subroutine quickargsort_int8 ( x , idx , n , order ) integer ( int8 ), dimension ( n ), intent ( inout ) :: x integer , dimension ( n ), intent ( inout ) :: idx integer , intent ( in ) :: n , order integer :: left , right , marker integer ( int8 ) :: pivot , tmp1 integer :: tmp2 if ( n > 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) < pivot ) left = left + 1 end do do while ( x ( right ) > pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case ( 2 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) > pivot ) left = left + 1 end do do while ( x ( right ) < pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left == right ) then marker = left + 1 else marker = left end if call quickargsort_int8 ( x (: marker - 1 ), idx (: marker - 1 ), marker - 1 , order ) call quickargsort_int8 ( x ( marker :), idx ( marker :), n - marker + 1 , order ) end if end subroutine quickargsort_int8 module procedure argsort_int16 integer :: i , n integer ( int16 ), allocatable :: xsort (:) integer :: order1 n = size ( x ) xsort = x argsort_int16 = [( i , i = 1 , n )] if (. not . present ( order )) then order1 = 1 else order1 = order end if call quickargsort_int16 ( xsort , argsort_int16 , n , order1 ) end procedure argsort_int16 recursive subroutine quickargsort_int16 ( x , idx , n , order ) integer ( int16 ), dimension ( n ), intent ( inout ) :: x integer , dimension ( n ), intent ( inout ) :: idx integer , intent ( in ) :: n , order integer :: left , right , marker integer ( int16 ) :: pivot , tmp1 integer :: tmp2 if ( n > 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) < pivot ) left = left + 1 end do do while ( x ( right ) > pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case ( 2 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) > pivot ) left = left + 1 end do do while ( x ( right ) < pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left == right ) then marker = left + 1 else marker = left end if call quickargsort_int16 ( x (: marker - 1 ), idx (: marker - 1 ), marker - 1 , order ) call quickargsort_int16 ( x ( marker :), idx ( marker :), n - marker + 1 , order ) end if end subroutine quickargsort_int16 module procedure argsort_int32 integer :: i , n integer ( int32 ), allocatable :: xsort (:) integer :: order1 n = size ( x ) xsort = x argsort_int32 = [( i , i = 1 , n )] if (. not . present ( order )) then order1 = 1 else order1 = order end if call quickargsort_int32 ( xsort , argsort_int32 , n , order1 ) end procedure argsort_int32 recursive subroutine quickargsort_int32 ( x , idx , n , order ) integer ( int32 ), dimension ( n ), intent ( inout ) :: x integer , dimension ( n ), intent ( inout ) :: idx integer , intent ( in ) :: n , order integer :: left , right , marker integer ( int32 ) :: pivot , tmp1 integer :: tmp2 if ( n > 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) < pivot ) left = left + 1 end do do while ( x ( right ) > pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case ( 2 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) > pivot ) left = left + 1 end do do while ( x ( right ) < pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left == right ) then marker = left + 1 else marker = left end if call quickargsort_int32 ( x (: marker - 1 ), idx (: marker - 1 ), marker - 1 , order ) call quickargsort_int32 ( x ( marker :), idx ( marker :), n - marker + 1 , order ) end if end subroutine quickargsort_int32 module procedure argsort_int64 integer :: i , n integer ( int64 ), allocatable :: xsort (:) integer :: order1 n = size ( x ) xsort = x argsort_int64 = [( i , i = 1 , n )] if (. not . present ( order )) then order1 = 1 else order1 = order end if call quickargsort_int64 ( xsort , argsort_int64 , n , order1 ) end procedure argsort_int64 recursive subroutine quickargsort_int64 ( x , idx , n , order ) integer ( int64 ), dimension ( n ), intent ( inout ) :: x integer , dimension ( n ), intent ( inout ) :: idx integer , intent ( in ) :: n , order integer :: left , right , marker integer ( int64 ) :: pivot , tmp1 integer :: tmp2 if ( n > 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) < pivot ) left = left + 1 end do do while ( x ( right ) > pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case ( 2 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) > pivot ) left = left + 1 end do do while ( x ( right ) < pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left == right ) then marker = left + 1 else marker = left end if call quickargsort_int64 ( x (: marker - 1 ), idx (: marker - 1 ), marker - 1 , order ) call quickargsort_int64 ( x ( marker :), idx ( marker :), n - marker + 1 , order ) end if end subroutine quickargsort_int64 module procedure argsort_sp integer :: i , n real ( sp ), allocatable :: xsort (:) integer :: order1 n = size ( x ) xsort = x argsort_sp = [( i , i = 1 , n )] if (. not . present ( order )) then order1 = 1 else order1 = order end if call quickargsort_sp ( xsort , argsort_sp , n , order1 ) end procedure argsort_sp recursive subroutine quickargsort_sp ( x , idx , n , order ) real ( sp ), dimension ( n ), intent ( inout ) :: x integer , dimension ( n ), intent ( inout ) :: idx integer , intent ( in ) :: n , order integer :: left , right , marker real ( sp ) :: pivot , tmp1 integer :: tmp2 if ( n > 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) < pivot ) left = left + 1 end do do while ( x ( right ) > pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case ( 2 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) > pivot ) left = left + 1 end do do while ( x ( right ) < pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left == right ) then marker = left + 1 else marker = left end if call quickargsort_sp ( x (: marker - 1 ), idx (: marker - 1 ), marker - 1 , order ) call quickargsort_sp ( x ( marker :), idx ( marker :), n - marker + 1 , order ) end if end subroutine quickargsort_sp module procedure argsort_dp integer :: i , n real ( dp ), allocatable :: xsort (:) integer :: order1 n = size ( x ) xsort = x argsort_dp = [( i , i = 1 , n )] if (. not . present ( order )) then order1 = 1 else order1 = order end if call quickargsort_dp ( xsort , argsort_dp , n , order1 ) end procedure argsort_dp recursive subroutine quickargsort_dp ( x , idx , n , order ) real ( dp ), dimension ( n ), intent ( inout ) :: x integer , dimension ( n ), intent ( inout ) :: idx integer , intent ( in ) :: n , order integer :: left , right , marker real ( dp ) :: pivot , tmp1 integer :: tmp2 if ( n > 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) < pivot ) left = left + 1 end do do while ( x ( right ) > pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case ( 2 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) > pivot ) left = left + 1 end do do while ( x ( right ) < pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left == right ) then marker = left + 1 else marker = left end if call quickargsort_dp ( x (: marker - 1 ), idx (: marker - 1 ), marker - 1 , order ) call quickargsort_dp ( x ( marker :), idx ( marker :), n - marker + 1 , order ) end if end subroutine quickargsort_dp module procedure argsort_qp integer :: i , n real ( qp ), allocatable :: xsort (:) integer :: order1 n = size ( x ) xsort = x argsort_qp = [( i , i = 1 , n )] if (. not . present ( order )) then order1 = 1 else order1 = order end if call quickargsort_qp ( xsort , argsort_qp , n , order1 ) end procedure argsort_qp recursive subroutine quickargsort_qp ( x , idx , n , order ) real ( qp ), dimension ( n ), intent ( inout ) :: x integer , dimension ( n ), intent ( inout ) :: idx integer , intent ( in ) :: n , order integer :: left , right , marker real ( qp ) :: pivot , tmp1 integer :: tmp2 if ( n > 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) < pivot ) left = left + 1 end do do while ( x ( right ) > pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case ( 2 ) do while ( left < right ) left = left + 1 right = right - 1 do while ( x ( left ) > pivot ) left = left + 1 end do do while ( x ( right ) < pivot ) right = right - 1 end do if ( left < right ) then tmp1 = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp1 tmp2 = idx ( left ) idx ( left ) = idx ( right ) idx ( right ) = tmp2 end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left == right ) then marker = left + 1 else marker = left end if call quickargsort_qp ( x (: marker - 1 ), idx (: marker - 1 ), marker - 1 , order ) call quickargsort_qp ( x ( marker :), idx ( marker :), n - marker + 1 , order ) end if end subroutine quickargsort_qp end submodule forlab_sorting_argsort","tags":"","loc":"sourcefile/forlab_sorting_argsort.f90.html"},{"title":"forlab_io_disp_.f90 – FORLAB","text":"Contents Submodules forlab_io_disp Source Code forlab_io_disp_.f90 Source Code submodule ( forlab_io ) forlab_io_disp use , intrinsic :: iso_fortran_env , only : output_unit use stdlib_string_type , only : char implicit none character ( len =* ), parameter :: rfmt = '(*(g12.4, 1x))' character ( len =* ), parameter :: cfmt = '(*(g25.0, 1x))' character ( len =* ), parameter :: fmt_ = 'g0.4' integer , parameter :: brief_row = 5 integer , parameter :: brief_col = 5 integer , parameter :: default_row = 50 integer , parameter :: default_col = 10 contains module procedure disp_0_rsp integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , rfmt ) x end procedure disp_0_rsp module procedure disp_1_rsp integer :: unit_ logical :: brief_ integer :: n , col unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) n = size ( x , 1 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[vector size: ' // to_string ( n ) // ']' if ( brief_ . and . n > col ) then write ( unit_ , rfmt ) x ( 1 : col - 2 ), '...' , x ( n ) else write ( unit_ , rfmt ) x (:) end if end procedure disp_1_rsp module procedure disp_2_rsp integer :: unit_ logical :: brief_ integer :: i , m , n integer :: row , col character ( len = 1 ) :: colon ( default_col ) unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) row = merge ( brief_row , default_row , present ( brief ) . and . brief_ ) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) m = size ( x , 1 ) n = size ( x , 2 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[matrix size: ' // to_string ( m ) // '×' // to_string ( n ) // ']' if ( brief_ . and . ( m > row . or . n > col )) then colon = ':' if ( m > row . and . n > col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do write ( unit_ , rfmt ) colon ( 1 : col ) write ( unit_ , rfmt ) x ( m , 1 : col - 2 ), '...' , x ( m , n ) elseif ( m > row . and . n <= col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i ,:) end do write ( unit_ , rfmt ) colon ( 1 : n ) write ( unit_ , rfmt ) x ( m ,:) elseif ( m <= row . and . n > col ) then do i = 1 , m write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do end if else do i = 1 , m write ( unit_ , rfmt ) x ( i ,:) end do end if end procedure disp_2_rsp module procedure disp_0_rdp integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , rfmt ) x end procedure disp_0_rdp module procedure disp_1_rdp integer :: unit_ logical :: brief_ integer :: n , col unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) n = size ( x , 1 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[vector size: ' // to_string ( n ) // ']' if ( brief_ . and . n > col ) then write ( unit_ , rfmt ) x ( 1 : col - 2 ), '...' , x ( n ) else write ( unit_ , rfmt ) x (:) end if end procedure disp_1_rdp module procedure disp_2_rdp integer :: unit_ logical :: brief_ integer :: i , m , n integer :: row , col character ( len = 1 ) :: colon ( default_col ) unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) row = merge ( brief_row , default_row , present ( brief ) . and . brief_ ) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) m = size ( x , 1 ) n = size ( x , 2 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[matrix size: ' // to_string ( m ) // '×' // to_string ( n ) // ']' if ( brief_ . and . ( m > row . or . n > col )) then colon = ':' if ( m > row . and . n > col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do write ( unit_ , rfmt ) colon ( 1 : col ) write ( unit_ , rfmt ) x ( m , 1 : col - 2 ), '...' , x ( m , n ) elseif ( m > row . and . n <= col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i ,:) end do write ( unit_ , rfmt ) colon ( 1 : n ) write ( unit_ , rfmt ) x ( m ,:) elseif ( m <= row . and . n > col ) then do i = 1 , m write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do end if else do i = 1 , m write ( unit_ , rfmt ) x ( i ,:) end do end if end procedure disp_2_rdp module procedure disp_0_rqp integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , rfmt ) x end procedure disp_0_rqp module procedure disp_1_rqp integer :: unit_ logical :: brief_ integer :: n , col unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) n = size ( x , 1 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[vector size: ' // to_string ( n ) // ']' if ( brief_ . and . n > col ) then write ( unit_ , rfmt ) x ( 1 : col - 2 ), '...' , x ( n ) else write ( unit_ , rfmt ) x (:) end if end procedure disp_1_rqp module procedure disp_2_rqp integer :: unit_ logical :: brief_ integer :: i , m , n integer :: row , col character ( len = 1 ) :: colon ( default_col ) unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) row = merge ( brief_row , default_row , present ( brief ) . and . brief_ ) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) m = size ( x , 1 ) n = size ( x , 2 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[matrix size: ' // to_string ( m ) // '×' // to_string ( n ) // ']' if ( brief_ . and . ( m > row . or . n > col )) then colon = ':' if ( m > row . and . n > col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do write ( unit_ , rfmt ) colon ( 1 : col ) write ( unit_ , rfmt ) x ( m , 1 : col - 2 ), '...' , x ( m , n ) elseif ( m > row . and . n <= col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i ,:) end do write ( unit_ , rfmt ) colon ( 1 : n ) write ( unit_ , rfmt ) x ( m ,:) elseif ( m <= row . and . n > col ) then do i = 1 , m write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do end if else do i = 1 , m write ( unit_ , rfmt ) x ( i ,:) end do end if end procedure disp_2_rqp module procedure disp_0_iint8 integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , rfmt ) x end procedure disp_0_iint8 module procedure disp_1_iint8 integer :: unit_ logical :: brief_ integer :: n , col unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) n = size ( x , 1 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[vector size: ' // to_string ( n ) // ']' if ( brief_ . and . n > col ) then write ( unit_ , rfmt ) x ( 1 : col - 2 ), '...' , x ( n ) else write ( unit_ , rfmt ) x (:) end if end procedure disp_1_iint8 module procedure disp_2_iint8 integer :: unit_ logical :: brief_ integer :: i , m , n integer :: row , col character ( len = 1 ) :: colon ( default_col ) unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) row = merge ( brief_row , default_row , present ( brief ) . and . brief_ ) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) m = size ( x , 1 ) n = size ( x , 2 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[matrix size: ' // to_string ( m ) // '×' // to_string ( n ) // ']' if ( brief_ . and . ( m > row . or . n > col )) then colon = ':' if ( m > row . and . n > col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do write ( unit_ , rfmt ) colon ( 1 : col ) write ( unit_ , rfmt ) x ( m , 1 : col - 2 ), '...' , x ( m , n ) elseif ( m > row . and . n <= col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i ,:) end do write ( unit_ , rfmt ) colon ( 1 : n ) write ( unit_ , rfmt ) x ( m ,:) elseif ( m <= row . and . n > col ) then do i = 1 , m write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do end if else do i = 1 , m write ( unit_ , rfmt ) x ( i ,:) end do end if end procedure disp_2_iint8 module procedure disp_0_iint16 integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , rfmt ) x end procedure disp_0_iint16 module procedure disp_1_iint16 integer :: unit_ logical :: brief_ integer :: n , col unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) n = size ( x , 1 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[vector size: ' // to_string ( n ) // ']' if ( brief_ . and . n > col ) then write ( unit_ , rfmt ) x ( 1 : col - 2 ), '...' , x ( n ) else write ( unit_ , rfmt ) x (:) end if end procedure disp_1_iint16 module procedure disp_2_iint16 integer :: unit_ logical :: brief_ integer :: i , m , n integer :: row , col character ( len = 1 ) :: colon ( default_col ) unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) row = merge ( brief_row , default_row , present ( brief ) . and . brief_ ) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) m = size ( x , 1 ) n = size ( x , 2 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[matrix size: ' // to_string ( m ) // '×' // to_string ( n ) // ']' if ( brief_ . and . ( m > row . or . n > col )) then colon = ':' if ( m > row . and . n > col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do write ( unit_ , rfmt ) colon ( 1 : col ) write ( unit_ , rfmt ) x ( m , 1 : col - 2 ), '...' , x ( m , n ) elseif ( m > row . and . n <= col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i ,:) end do write ( unit_ , rfmt ) colon ( 1 : n ) write ( unit_ , rfmt ) x ( m ,:) elseif ( m <= row . and . n > col ) then do i = 1 , m write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do end if else do i = 1 , m write ( unit_ , rfmt ) x ( i ,:) end do end if end procedure disp_2_iint16 module procedure disp_0_iint32 integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , rfmt ) x end procedure disp_0_iint32 module procedure disp_1_iint32 integer :: unit_ logical :: brief_ integer :: n , col unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) n = size ( x , 1 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[vector size: ' // to_string ( n ) // ']' if ( brief_ . and . n > col ) then write ( unit_ , rfmt ) x ( 1 : col - 2 ), '...' , x ( n ) else write ( unit_ , rfmt ) x (:) end if end procedure disp_1_iint32 module procedure disp_2_iint32 integer :: unit_ logical :: brief_ integer :: i , m , n integer :: row , col character ( len = 1 ) :: colon ( default_col ) unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) row = merge ( brief_row , default_row , present ( brief ) . and . brief_ ) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) m = size ( x , 1 ) n = size ( x , 2 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[matrix size: ' // to_string ( m ) // '×' // to_string ( n ) // ']' if ( brief_ . and . ( m > row . or . n > col )) then colon = ':' if ( m > row . and . n > col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do write ( unit_ , rfmt ) colon ( 1 : col ) write ( unit_ , rfmt ) x ( m , 1 : col - 2 ), '...' , x ( m , n ) elseif ( m > row . and . n <= col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i ,:) end do write ( unit_ , rfmt ) colon ( 1 : n ) write ( unit_ , rfmt ) x ( m ,:) elseif ( m <= row . and . n > col ) then do i = 1 , m write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do end if else do i = 1 , m write ( unit_ , rfmt ) x ( i ,:) end do end if end procedure disp_2_iint32 module procedure disp_0_iint64 integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , rfmt ) x end procedure disp_0_iint64 module procedure disp_1_iint64 integer :: unit_ logical :: brief_ integer :: n , col unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) n = size ( x , 1 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[vector size: ' // to_string ( n ) // ']' if ( brief_ . and . n > col ) then write ( unit_ , rfmt ) x ( 1 : col - 2 ), '...' , x ( n ) else write ( unit_ , rfmt ) x (:) end if end procedure disp_1_iint64 module procedure disp_2_iint64 integer :: unit_ logical :: brief_ integer :: i , m , n integer :: row , col character ( len = 1 ) :: colon ( default_col ) unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) row = merge ( brief_row , default_row , present ( brief ) . and . brief_ ) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) m = size ( x , 1 ) n = size ( x , 2 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[matrix size: ' // to_string ( m ) // '×' // to_string ( n ) // ']' if ( brief_ . and . ( m > row . or . n > col )) then colon = ':' if ( m > row . and . n > col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do write ( unit_ , rfmt ) colon ( 1 : col ) write ( unit_ , rfmt ) x ( m , 1 : col - 2 ), '...' , x ( m , n ) elseif ( m > row . and . n <= col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i ,:) end do write ( unit_ , rfmt ) colon ( 1 : n ) write ( unit_ , rfmt ) x ( m ,:) elseif ( m <= row . and . n > col ) then do i = 1 , m write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do end if else do i = 1 , m write ( unit_ , rfmt ) x ( i ,:) end do end if end procedure disp_2_iint64 module procedure disp_0_llk integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , rfmt ) x end procedure disp_0_llk module procedure disp_1_llk integer :: unit_ logical :: brief_ integer :: n , col unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) n = size ( x , 1 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[vector size: ' // to_string ( n ) // ']' if ( brief_ . and . n > col ) then write ( unit_ , rfmt ) x ( 1 : col - 2 ), '...' , x ( n ) else write ( unit_ , rfmt ) x (:) end if end procedure disp_1_llk module procedure disp_2_llk integer :: unit_ logical :: brief_ integer :: i , m , n integer :: row , col character ( len = 1 ) :: colon ( default_col ) unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) row = merge ( brief_row , default_row , present ( brief ) . and . brief_ ) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) m = size ( x , 1 ) n = size ( x , 2 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[matrix size: ' // to_string ( m ) // '×' // to_string ( n ) // ']' if ( brief_ . and . ( m > row . or . n > col )) then colon = ':' if ( m > row . and . n > col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do write ( unit_ , rfmt ) colon ( 1 : col ) write ( unit_ , rfmt ) x ( m , 1 : col - 2 ), '...' , x ( m , n ) elseif ( m > row . and . n <= col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i ,:) end do write ( unit_ , rfmt ) colon ( 1 : n ) write ( unit_ , rfmt ) x ( m ,:) elseif ( m <= row . and . n > col ) then do i = 1 , m write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do end if else do i = 1 , m write ( unit_ , rfmt ) x ( i ,:) end do end if end procedure disp_2_llk module procedure disp_0_lc_bool integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , rfmt ) x end procedure disp_0_lc_bool module procedure disp_1_lc_bool integer :: unit_ logical :: brief_ integer :: n , col unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) n = size ( x , 1 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[vector size: ' // to_string ( n ) // ']' if ( brief_ . and . n > col ) then write ( unit_ , rfmt ) x ( 1 : col - 2 ), '...' , x ( n ) else write ( unit_ , rfmt ) x (:) end if end procedure disp_1_lc_bool module procedure disp_2_lc_bool integer :: unit_ logical :: brief_ integer :: i , m , n integer :: row , col character ( len = 1 ) :: colon ( default_col ) unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) row = merge ( brief_row , default_row , present ( brief ) . and . brief_ ) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) m = size ( x , 1 ) n = size ( x , 2 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[matrix size: ' // to_string ( m ) // '×' // to_string ( n ) // ']' if ( brief_ . and . ( m > row . or . n > col )) then colon = ':' if ( m > row . and . n > col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do write ( unit_ , rfmt ) colon ( 1 : col ) write ( unit_ , rfmt ) x ( m , 1 : col - 2 ), '...' , x ( m , n ) elseif ( m > row . and . n <= col ) then do i = 1 , row - 2 write ( unit_ , rfmt ) x ( i ,:) end do write ( unit_ , rfmt ) colon ( 1 : n ) write ( unit_ , rfmt ) x ( m ,:) elseif ( m <= row . and . n > col ) then do i = 1 , m write ( unit_ , rfmt ) x ( i , 1 : col - 2 ), '...' , x ( i , n ) end do end if else do i = 1 , m write ( unit_ , rfmt ) x ( i ,:) end do end if end procedure disp_2_lc_bool module procedure disp_0_csp integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , cfmt ) to_string ( x , fmt_ ) end procedure disp_0_csp module procedure disp_1_csp integer :: unit_ logical :: brief_ integer :: i , n , col unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) n = size ( x , 1 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[vector size: ' // to_string ( n ) // ']' if ( brief_ . and . n > col ) then write ( unit_ , cfmt ) ( to_string ( x ( i ), fmt_ ), i = 1 , col - 2 ), '...' , to_string ( x ( n ), fmt_ ) else write ( unit_ , cfmt ) ( to_string ( x ( i ), fmt_ ), i = 1 , n ) end if end procedure disp_1_csp module procedure disp_2_csp integer :: unit_ logical :: brief_ integer :: i , j , m , n integer :: row , col character ( len = 1 ) :: colon ( default_col ) unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) row = merge ( brief_row , default_row , present ( brief ) . and . brief_ ) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) m = size ( x , 1 ) n = size ( x , 2 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[matrix size: ' // to_string ( m ) // '×' // to_string ( n ) // ']' if ( brief_ . and . ( m > row . or . n > col )) then colon = ':' if ( m > row . and . n > col ) then do i = 1 , row - 2 write ( unit_ , cfmt ) ( to_string ( x ( i , j ), fmt_ ), j = 1 , col - 2 ), '...' , to_string ( x ( i , n ), fmt_ ) end do write ( unit_ , cfmt ) colon ( 1 : col ) write ( unit_ , cfmt ) ( to_string ( x ( m , j ), fmt_ ), j = 1 , col - 2 ), '...' , to_string ( x ( m , n ), fmt_ ) elseif ( m > row . and . n <= col ) then do i = 1 , row - 2 write ( unit_ , cfmt ) ( to_string ( x ( i , j ), fmt_ ), j = 1 , n ) end do write ( unit_ , cfmt ) colon ( 1 : n ) write ( unit_ , cfmt ) ( to_string ( x ( m , j ), fmt_ ), j = 1 , n ) elseif ( m <= row . and . n > col ) then do i = 1 , m write ( unit_ , cfmt ) ( to_string ( x ( m , j ), fmt_ ), j = 1 , col - 2 ), '...' , to_string ( x ( m , n ), fmt_ ) end do end if else do i = 1 , m write ( unit_ , cfmt ) ( to_string ( x ( i , j ), fmt_ ), j = 1 , n ) end do end if end procedure disp_2_csp module procedure disp_0_cdp integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , cfmt ) to_string ( x , fmt_ ) end procedure disp_0_cdp module procedure disp_1_cdp integer :: unit_ logical :: brief_ integer :: i , n , col unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) n = size ( x , 1 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[vector size: ' // to_string ( n ) // ']' if ( brief_ . and . n > col ) then write ( unit_ , cfmt ) ( to_string ( x ( i ), fmt_ ), i = 1 , col - 2 ), '...' , to_string ( x ( n ), fmt_ ) else write ( unit_ , cfmt ) ( to_string ( x ( i ), fmt_ ), i = 1 , n ) end if end procedure disp_1_cdp module procedure disp_2_cdp integer :: unit_ logical :: brief_ integer :: i , j , m , n integer :: row , col character ( len = 1 ) :: colon ( default_col ) unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) row = merge ( brief_row , default_row , present ( brief ) . and . brief_ ) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) m = size ( x , 1 ) n = size ( x , 2 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[matrix size: ' // to_string ( m ) // '×' // to_string ( n ) // ']' if ( brief_ . and . ( m > row . or . n > col )) then colon = ':' if ( m > row . and . n > col ) then do i = 1 , row - 2 write ( unit_ , cfmt ) ( to_string ( x ( i , j ), fmt_ ), j = 1 , col - 2 ), '...' , to_string ( x ( i , n ), fmt_ ) end do write ( unit_ , cfmt ) colon ( 1 : col ) write ( unit_ , cfmt ) ( to_string ( x ( m , j ), fmt_ ), j = 1 , col - 2 ), '...' , to_string ( x ( m , n ), fmt_ ) elseif ( m > row . and . n <= col ) then do i = 1 , row - 2 write ( unit_ , cfmt ) ( to_string ( x ( i , j ), fmt_ ), j = 1 , n ) end do write ( unit_ , cfmt ) colon ( 1 : n ) write ( unit_ , cfmt ) ( to_string ( x ( m , j ), fmt_ ), j = 1 , n ) elseif ( m <= row . and . n > col ) then do i = 1 , m write ( unit_ , cfmt ) ( to_string ( x ( m , j ), fmt_ ), j = 1 , col - 2 ), '...' , to_string ( x ( m , n ), fmt_ ) end do end if else do i = 1 , m write ( unit_ , cfmt ) ( to_string ( x ( i , j ), fmt_ ), j = 1 , n ) end do end if end procedure disp_2_cdp module procedure disp_0_cqp integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , cfmt ) to_string ( x , fmt_ ) end procedure disp_0_cqp module procedure disp_1_cqp integer :: unit_ logical :: brief_ integer :: i , n , col unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) n = size ( x , 1 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[vector size: ' // to_string ( n ) // ']' if ( brief_ . and . n > col ) then write ( unit_ , cfmt ) ( to_string ( x ( i ), fmt_ ), i = 1 , col - 2 ), '...' , to_string ( x ( n ), fmt_ ) else write ( unit_ , cfmt ) ( to_string ( x ( i ), fmt_ ), i = 1 , n ) end if end procedure disp_1_cqp module procedure disp_2_cqp integer :: unit_ logical :: brief_ integer :: i , j , m , n integer :: row , col character ( len = 1 ) :: colon ( default_col ) unit_ = optval ( unit , output_unit ) brief_ = optval ( brief , . true .) row = merge ( brief_row , default_row , present ( brief ) . and . brief_ ) col = merge ( brief_col , default_col , present ( brief ) . and . brief_ ) m = size ( x , 1 ) n = size ( x , 2 ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) '[matrix size: ' // to_string ( m ) // '×' // to_string ( n ) // ']' if ( brief_ . and . ( m > row . or . n > col )) then colon = ':' if ( m > row . and . n > col ) then do i = 1 , row - 2 write ( unit_ , cfmt ) ( to_string ( x ( i , j ), fmt_ ), j = 1 , col - 2 ), '...' , to_string ( x ( i , n ), fmt_ ) end do write ( unit_ , cfmt ) colon ( 1 : col ) write ( unit_ , cfmt ) ( to_string ( x ( m , j ), fmt_ ), j = 1 , col - 2 ), '...' , to_string ( x ( m , n ), fmt_ ) elseif ( m > row . and . n <= col ) then do i = 1 , row - 2 write ( unit_ , cfmt ) ( to_string ( x ( i , j ), fmt_ ), j = 1 , n ) end do write ( unit_ , cfmt ) colon ( 1 : n ) write ( unit_ , cfmt ) ( to_string ( x ( m , j ), fmt_ ), j = 1 , n ) elseif ( m <= row . and . n > col ) then do i = 1 , m write ( unit_ , cfmt ) ( to_string ( x ( m , j ), fmt_ ), j = 1 , col - 2 ), '...' , to_string ( x ( m , n ), fmt_ ) end do end if else do i = 1 , m write ( unit_ , cfmt ) ( to_string ( x ( i , j ), fmt_ ), j = 1 , n ) end do end if end procedure disp_2_cqp module procedure disp_character character ( len = :), allocatable :: x_ integer :: unit_ x_ = optval ( x , '' ) unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) x_ end procedure disp_character module procedure disp_string_type integer :: unit_ unit_ = optval ( unit , output_unit ) if ( present ( header )) write ( unit_ , * ) header write ( unit_ , * ) char ( x ) end procedure disp_string_type end submodule forlab_io_disp","tags":"","loc":"sourcefile/forlab_io_disp_.f90.html"},{"title":"forlab_sorting_sort.f90 – FORLAB","text":"Contents Submodules forlab_sorting_sort Source Code forlab_sorting_sort.f90 Source Code submodule ( forlab_sorting ) forlab_sorting_sort implicit none contains module procedure sort_int8 integer :: n , order1 n = size ( x ) sort_int8 = x if (. not . present ( order )) then order1 = 1 else order1 = order end if call quicksort_int8 ( sort_int8 , n , order1 ) end procedure sort_int8 recursive subroutine quicksort_int8 ( x , n , order ) integer ( int8 ), dimension ( n ), intent ( inout ) :: x integer , intent ( in ) :: n , order integer :: left , right , marker integer ( int8 ) :: pivot , tmp if ( n . gt . 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . lt . pivot ) left = left + 1 end do do while ( x ( right ) . gt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case ( 2 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . gt . pivot ) left = left + 1 end do do while ( x ( right ) . lt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left . eq . right ) then marker = left + 1 else marker = left end if call quicksort_int8 ( x (: marker - 1 ), marker - 1 , order ) call quicksort_int8 ( x ( marker :), n - marker + 1 , order ) end if end subroutine quicksort_int8 module procedure sort_int16 integer :: n , order1 n = size ( x ) sort_int16 = x if (. not . present ( order )) then order1 = 1 else order1 = order end if call quicksort_int16 ( sort_int16 , n , order1 ) end procedure sort_int16 recursive subroutine quicksort_int16 ( x , n , order ) integer ( int16 ), dimension ( n ), intent ( inout ) :: x integer , intent ( in ) :: n , order integer :: left , right , marker integer ( int16 ) :: pivot , tmp if ( n . gt . 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . lt . pivot ) left = left + 1 end do do while ( x ( right ) . gt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case ( 2 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . gt . pivot ) left = left + 1 end do do while ( x ( right ) . lt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left . eq . right ) then marker = left + 1 else marker = left end if call quicksort_int16 ( x (: marker - 1 ), marker - 1 , order ) call quicksort_int16 ( x ( marker :), n - marker + 1 , order ) end if end subroutine quicksort_int16 module procedure sort_int32 integer :: n , order1 n = size ( x ) sort_int32 = x if (. not . present ( order )) then order1 = 1 else order1 = order end if call quicksort_int32 ( sort_int32 , n , order1 ) end procedure sort_int32 recursive subroutine quicksort_int32 ( x , n , order ) integer ( int32 ), dimension ( n ), intent ( inout ) :: x integer , intent ( in ) :: n , order integer :: left , right , marker integer ( int32 ) :: pivot , tmp if ( n . gt . 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . lt . pivot ) left = left + 1 end do do while ( x ( right ) . gt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case ( 2 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . gt . pivot ) left = left + 1 end do do while ( x ( right ) . lt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left . eq . right ) then marker = left + 1 else marker = left end if call quicksort_int32 ( x (: marker - 1 ), marker - 1 , order ) call quicksort_int32 ( x ( marker :), n - marker + 1 , order ) end if end subroutine quicksort_int32 module procedure sort_int64 integer :: n , order1 n = size ( x ) sort_int64 = x if (. not . present ( order )) then order1 = 1 else order1 = order end if call quicksort_int64 ( sort_int64 , n , order1 ) end procedure sort_int64 recursive subroutine quicksort_int64 ( x , n , order ) integer ( int64 ), dimension ( n ), intent ( inout ) :: x integer , intent ( in ) :: n , order integer :: left , right , marker integer ( int64 ) :: pivot , tmp if ( n . gt . 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . lt . pivot ) left = left + 1 end do do while ( x ( right ) . gt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case ( 2 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . gt . pivot ) left = left + 1 end do do while ( x ( right ) . lt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left . eq . right ) then marker = left + 1 else marker = left end if call quicksort_int64 ( x (: marker - 1 ), marker - 1 , order ) call quicksort_int64 ( x ( marker :), n - marker + 1 , order ) end if end subroutine quicksort_int64 module procedure sort_sp integer :: n , order1 n = size ( x ) sort_sp = x if (. not . present ( order )) then order1 = 1 else order1 = order end if call quicksort_sp ( sort_sp , n , order1 ) end procedure sort_sp recursive subroutine quicksort_sp ( x , n , order ) real ( sp ), dimension ( n ), intent ( inout ) :: x integer , intent ( in ) :: n , order integer :: left , right , marker real ( sp ) :: pivot , tmp if ( n . gt . 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . lt . pivot ) left = left + 1 end do do while ( x ( right ) . gt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case ( 2 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . gt . pivot ) left = left + 1 end do do while ( x ( right ) . lt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left . eq . right ) then marker = left + 1 else marker = left end if call quicksort_sp ( x (: marker - 1 ), marker - 1 , order ) call quicksort_sp ( x ( marker :), n - marker + 1 , order ) end if end subroutine quicksort_sp module procedure sort_dp integer :: n , order1 n = size ( x ) sort_dp = x if (. not . present ( order )) then order1 = 1 else order1 = order end if call quicksort_dp ( sort_dp , n , order1 ) end procedure sort_dp recursive subroutine quicksort_dp ( x , n , order ) real ( dp ), dimension ( n ), intent ( inout ) :: x integer , intent ( in ) :: n , order integer :: left , right , marker real ( dp ) :: pivot , tmp if ( n . gt . 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . lt . pivot ) left = left + 1 end do do while ( x ( right ) . gt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case ( 2 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . gt . pivot ) left = left + 1 end do do while ( x ( right ) . lt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left . eq . right ) then marker = left + 1 else marker = left end if call quicksort_dp ( x (: marker - 1 ), marker - 1 , order ) call quicksort_dp ( x ( marker :), n - marker + 1 , order ) end if end subroutine quicksort_dp module procedure sort_qp integer :: n , order1 n = size ( x ) sort_qp = x if (. not . present ( order )) then order1 = 1 else order1 = order end if call quicksort_qp ( sort_qp , n , order1 ) end procedure sort_qp recursive subroutine quicksort_qp ( x , n , order ) real ( qp ), dimension ( n ), intent ( inout ) :: x integer , intent ( in ) :: n , order integer :: left , right , marker real ( qp ) :: pivot , tmp if ( n . gt . 1 ) then left = 0 right = n + 1 pivot = x ( randu ( 1 , n )) select case ( order ) case ( 1 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . lt . pivot ) left = left + 1 end do do while ( x ( right ) . gt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case ( 2 ) do while ( left . lt . right ) left = left + 1 right = right - 1 do while ( x ( left ) . gt . pivot ) left = left + 1 end do do while ( x ( right ) . lt . pivot ) right = right - 1 end do if ( left . lt . right ) then tmp = x ( left ) x ( left ) = x ( right ) x ( right ) = tmp end if end do case default error stop \"Error:Sort order MUST be 1 or 2\" end select if ( left . eq . right ) then marker = left + 1 else marker = left end if call quicksort_qp ( x (: marker - 1 ), marker - 1 , order ) call quicksort_qp ( x ( marker :), n - marker + 1 , order ) end if end subroutine quicksort_qp end submodule forlab_sorting_sort","tags":"","loc":"sourcefile/forlab_sorting_sort.f90.html"},{"title":"forlab_time_tioc.f90 – FORLAB","text":"Contents Submodules forlab_time_tioc Source Code forlab_time_tioc.f90 Source Code submodule ( forlab_time ) forlab_time_tioc use stdlib_strings , only : to_string implicit none real ( dp ), save :: tic_time contains module procedure tic integer :: values ( 8 ) call date_and_time ( values = values ) tic_time = datenum ( values ( 1 ), values ( 2 ), values ( 3 ), values ( 5 ), & values ( 6 ), values ( 7 ), values ( 8 ) * 1000 ) & * 2 4.0d0 * 6 0.0d0 * 6 0.0d0 return end procedure tic module procedure toc_default integer :: values ( 8 ) real ( dp ) :: toc_time , elapsed_time call date_and_time ( values = values ) toc_time = datenum ( values ( 1 ), values ( 2 ), values ( 3 ), values ( 5 ), & values ( 6 ), values ( 7 ), values ( 8 ) * 1000 ) & * 2 4.0d0 * 6 0.0d0 * 6 0.0d0 elapsed_time = toc_time - tic_time call disp ( \"Elapsed time: \" & // to_string ( elapsed_time , \"(F12.3)\" ) & // \" seconds\" ) return end procedure toc_default module procedure toc_sp integer :: values ( 8 ) real ( dp ) :: toc_time , elapsed_time call date_and_time ( values = values ) toc_time = datenum ( values ( 1 ), values ( 2 ), values ( 3 ), values ( 5 ), & values ( 6 ), values ( 7 ), values ( 8 ) * 1000 ) & * 2 4.0d0 * 6 0.0d0 * 6 0.0d0 elapsed_time = toc_time - tic_time time = elapsed_time !!\\ATTENTION@zuo.zhihua@qq.com: Accuracy is converted here. return end procedure toc_sp module procedure toc_dp integer :: values ( 8 ) real ( dp ) :: toc_time , elapsed_time call date_and_time ( values = values ) toc_time = datenum ( values ( 1 ), values ( 2 ), values ( 3 ), values ( 5 ), & values ( 6 ), values ( 7 ), values ( 8 ) * 1000 ) & * 2 4.0d0 * 6 0.0d0 * 6 0.0d0 elapsed_time = toc_time - tic_time time = elapsed_time !!\\ATTENTION@zuo.zhihua@qq.com: Accuracy is converted here. return end procedure toc_dp module procedure toc_qp integer :: values ( 8 ) real ( dp ) :: toc_time , elapsed_time call date_and_time ( values = values ) toc_time = datenum ( values ( 1 ), values ( 2 ), values ( 3 ), values ( 5 ), & values ( 6 ), values ( 7 ), values ( 8 ) * 1000 ) & * 2 4.0d0 * 6 0.0d0 * 6 0.0d0 elapsed_time = toc_time - tic_time time = elapsed_time !!\\ATTENTION@zuo.zhihua@qq.com: Accuracy is converted here. return end procedure toc_qp end submodule forlab_time_tioc","tags":"","loc":"sourcefile/forlab_time_tioc.f90.html"},{"title":"forlab_linalg_eig.f90 – FORLAB","text":"Contents Submodules forlab_linalg_eig Source Code forlab_linalg_eig.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_eig implicit none contains module procedure eig_sp integer :: opt_itermax , iter , i , j , k , n integer , dimension (:), allocatable :: idx real ( sp ) :: threshold , gapj , termi , termj , h , term , t , & theta , c , s , tau , g real ( sp ), dimension (:), allocatable :: bw , zw real ( sp ), dimension (:, :), allocatable :: B real ( sp ), parameter :: zero = 0.0_sp , one = 1.0_sp , half = 0.5_sp opt_itermax = 1000 if ( present ( itermax )) opt_itermax = itermax if (. not . is_symmetric ( A )) then stop \"Error: in eig(A), A is not symmetric.\" else if ( allocated ( V )) deallocate ( V ) if ( allocated ( d )) deallocate ( d ) B = A n = size ( B , 1 ) allocate ( V ( n , n )) call eye ( V ) d = diag ( B ) bw = d zw = zeros ( n ) iter = 0 do while ( iter . lt . opt_itermax ) iter = iter + 1 threshold = sqrt ( sum ( triu ( B , 1 ) ** 2 )) / ( 4 * n ) if ( threshold . eq . zero ) exit do i = 1 , n do j = i + 1 , n gapj = 10_sp * abs ( B ( i , j )) termi = gapj + abs ( d ( i )) termj = gapj + abs ( d ( j )) if (( iter . gt . 4 ) . and . ( termi . eq . abs ( d ( i ))) & . and . ( termj . eq . abs ( d ( j )))) then B ( i , j ) = zero elseif ( threshold . le . abs ( B ( i , j ))) then h = d ( j ) - d ( i ) term = abs ( h ) + gapj if ( term . eq . abs ( h )) then t = B ( i , j ) / h else theta = half * h / B ( i , j ) t = one / ( abs ( theta ) + sqrt ( one + theta * theta )) if ( theta . lt . zero ) t = - t end if c = one / sqrt ( one + t * t ) s = t * c tau = s / ( one + c ) h = t * B ( i , j ) zw ( i ) = zw ( i ) - h zw ( j ) = zw ( j ) + h d ( i ) = d ( i ) - h d ( j ) = d ( j ) + h B ( i , j ) = zero do k = 1 , i - 1 g = B ( k , i ) h = B ( k , j ) B ( k , i ) = g - s * ( h + g * tau ) B ( k , j ) = h + s * ( g - h * tau ) end do do k = i + 1 , j - 1 g = B ( i , k ) h = B ( k , j ) B ( i , k ) = g - s * ( h + g * tau ) B ( k , j ) = h + s * ( g - h * tau ) end do do k = j + 1 , n g = B ( i , k ) h = B ( j , k ) B ( i , k ) = g - s * ( h + g * tau ) B ( j , k ) = h + s * ( g - h * tau ) end do do k = 1 , n g = V ( k , i ) h = V ( k , j ) v ( k , i ) = g - s * ( h + g * tau ) v ( k , j ) = h + s * ( g - h * tau ) end do end if end do end do bw = bw + zw d = bw zw = zero end do idx = argsort ( d , 1 ) d = d ( idx ) V = V (:, idx ) end if end procedure eig_sp module procedure eig_dp integer :: opt_itermax , iter , i , j , k , n integer , dimension (:), allocatable :: idx real ( dp ) :: threshold , gapj , termi , termj , h , term , t , & theta , c , s , tau , g real ( dp ), dimension (:), allocatable :: bw , zw real ( dp ), dimension (:, :), allocatable :: B real ( dp ), parameter :: zero = 0.0_dp , one = 1.0_dp , half = 0.5_dp opt_itermax = 1000 if ( present ( itermax )) opt_itermax = itermax if (. not . is_symmetric ( A )) then stop \"Error: in eig(A), A is not symmetric.\" else if ( allocated ( V )) deallocate ( V ) if ( allocated ( d )) deallocate ( d ) B = A n = size ( B , 1 ) allocate ( V ( n , n )) call eye ( V ) d = diag ( B ) bw = d zw = zeros ( n ) iter = 0 do while ( iter . lt . opt_itermax ) iter = iter + 1 threshold = sqrt ( sum ( triu ( B , 1 ) ** 2 )) / ( 4 * n ) if ( threshold . eq . zero ) exit do i = 1 , n do j = i + 1 , n gapj = 10_dp * abs ( B ( i , j )) termi = gapj + abs ( d ( i )) termj = gapj + abs ( d ( j )) if (( iter . gt . 4 ) . and . ( termi . eq . abs ( d ( i ))) & . and . ( termj . eq . abs ( d ( j )))) then B ( i , j ) = zero elseif ( threshold . le . abs ( B ( i , j ))) then h = d ( j ) - d ( i ) term = abs ( h ) + gapj if ( term . eq . abs ( h )) then t = B ( i , j ) / h else theta = half * h / B ( i , j ) t = one / ( abs ( theta ) + sqrt ( one + theta * theta )) if ( theta . lt . zero ) t = - t end if c = one / sqrt ( one + t * t ) s = t * c tau = s / ( one + c ) h = t * B ( i , j ) zw ( i ) = zw ( i ) - h zw ( j ) = zw ( j ) + h d ( i ) = d ( i ) - h d ( j ) = d ( j ) + h B ( i , j ) = zero do k = 1 , i - 1 g = B ( k , i ) h = B ( k , j ) B ( k , i ) = g - s * ( h + g * tau ) B ( k , j ) = h + s * ( g - h * tau ) end do do k = i + 1 , j - 1 g = B ( i , k ) h = B ( k , j ) B ( i , k ) = g - s * ( h + g * tau ) B ( k , j ) = h + s * ( g - h * tau ) end do do k = j + 1 , n g = B ( i , k ) h = B ( j , k ) B ( i , k ) = g - s * ( h + g * tau ) B ( j , k ) = h + s * ( g - h * tau ) end do do k = 1 , n g = V ( k , i ) h = V ( k , j ) v ( k , i ) = g - s * ( h + g * tau ) v ( k , j ) = h + s * ( g - h * tau ) end do end if end do end do bw = bw + zw d = bw zw = zero end do idx = argsort ( d , 1 ) d = d ( idx ) V = V (:, idx ) end if end procedure eig_dp module procedure eig_qp integer :: opt_itermax , iter , i , j , k , n integer , dimension (:), allocatable :: idx real ( qp ) :: threshold , gapj , termi , termj , h , term , t , & theta , c , s , tau , g real ( qp ), dimension (:), allocatable :: bw , zw real ( qp ), dimension (:, :), allocatable :: B real ( qp ), parameter :: zero = 0.0_qp , one = 1.0_qp , half = 0.5_qp opt_itermax = 1000 if ( present ( itermax )) opt_itermax = itermax if (. not . is_symmetric ( A )) then stop \"Error: in eig(A), A is not symmetric.\" else if ( allocated ( V )) deallocate ( V ) if ( allocated ( d )) deallocate ( d ) B = A n = size ( B , 1 ) allocate ( V ( n , n )) call eye ( V ) d = diag ( B ) bw = d zw = zeros ( n ) iter = 0 do while ( iter . lt . opt_itermax ) iter = iter + 1 threshold = sqrt ( sum ( triu ( B , 1 ) ** 2 )) / ( 4 * n ) if ( threshold . eq . zero ) exit do i = 1 , n do j = i + 1 , n gapj = 10_qp * abs ( B ( i , j )) termi = gapj + abs ( d ( i )) termj = gapj + abs ( d ( j )) if (( iter . gt . 4 ) . and . ( termi . eq . abs ( d ( i ))) & . and . ( termj . eq . abs ( d ( j )))) then B ( i , j ) = zero elseif ( threshold . le . abs ( B ( i , j ))) then h = d ( j ) - d ( i ) term = abs ( h ) + gapj if ( term . eq . abs ( h )) then t = B ( i , j ) / h else theta = half * h / B ( i , j ) t = one / ( abs ( theta ) + sqrt ( one + theta * theta )) if ( theta . lt . zero ) t = - t end if c = one / sqrt ( one + t * t ) s = t * c tau = s / ( one + c ) h = t * B ( i , j ) zw ( i ) = zw ( i ) - h zw ( j ) = zw ( j ) + h d ( i ) = d ( i ) - h d ( j ) = d ( j ) + h B ( i , j ) = zero do k = 1 , i - 1 g = B ( k , i ) h = B ( k , j ) B ( k , i ) = g - s * ( h + g * tau ) B ( k , j ) = h + s * ( g - h * tau ) end do do k = i + 1 , j - 1 g = B ( i , k ) h = B ( k , j ) B ( i , k ) = g - s * ( h + g * tau ) B ( k , j ) = h + s * ( g - h * tau ) end do do k = j + 1 , n g = B ( i , k ) h = B ( j , k ) B ( i , k ) = g - s * ( h + g * tau ) B ( j , k ) = h + s * ( g - h * tau ) end do do k = 1 , n g = V ( k , i ) h = V ( k , j ) v ( k , i ) = g - s * ( h + g * tau ) v ( k , j ) = h + s * ( g - h * tau ) end do end if end do end do bw = bw + zw d = bw zw = zero end do idx = argsort ( d , 1 ) d = d ( idx ) V = V (:, idx ) end if end procedure eig_qp end submodule forlab_linalg_eig","tags":"","loc":"sourcefile/forlab_linalg_eig.f90.html"},{"title":"forlab_io_progress_perc.f90 – FORLAB","text":"Contents Submodules forlab_io_progress_perc Source Code forlab_io_progress_perc.f90 Source Code submodule ( forlab_io ) forlab_io_progress_perc implicit none contains module subroutine progress_perc_int8 ( iter , itermax , prefix ) integer ( int8 ), intent ( in ) :: iter , itermax character ( * ), intent ( in ), optional :: prefix real ( sp ) :: percentage character (:), allocatable :: prefix_ prefix_ = optval ( prefix , \"\" ) percentage = real ( iter , sp ) / real ( itermax , sp ) * 10 0.0_sp write ( * , \"(a1,A,f6.2,A)\" , advance = \"no\" ) achar ( 13 ), prefix_ , percentage , \"%\" end subroutine progress_perc_int8 module subroutine progress_perc_int16 ( iter , itermax , prefix ) integer ( int16 ), intent ( in ) :: iter , itermax character ( * ), intent ( in ), optional :: prefix real ( sp ) :: percentage character (:), allocatable :: prefix_ prefix_ = optval ( prefix , \"\" ) percentage = real ( iter , sp ) / real ( itermax , sp ) * 10 0.0_sp write ( * , \"(a1,A,f6.2,A)\" , advance = \"no\" ) achar ( 13 ), prefix_ , percentage , \"%\" end subroutine progress_perc_int16 module subroutine progress_perc_int32 ( iter , itermax , prefix ) integer ( int32 ), intent ( in ) :: iter , itermax character ( * ), intent ( in ), optional :: prefix real ( sp ) :: percentage character (:), allocatable :: prefix_ prefix_ = optval ( prefix , \"\" ) percentage = real ( iter , sp ) / real ( itermax , sp ) * 10 0.0_sp write ( * , \"(a1,A,f6.2,A)\" , advance = \"no\" ) achar ( 13 ), prefix_ , percentage , \"%\" end subroutine progress_perc_int32 module subroutine progress_perc_int64 ( iter , itermax , prefix ) integer ( int64 ), intent ( in ) :: iter , itermax character ( * ), intent ( in ), optional :: prefix real ( sp ) :: percentage character (:), allocatable :: prefix_ prefix_ = optval ( prefix , \"\" ) percentage = real ( iter , sp ) / real ( itermax , sp ) * 10 0.0_sp write ( * , \"(a1,A,f6.2,A)\" , advance = \"no\" ) achar ( 13 ), prefix_ , percentage , \"%\" end subroutine progress_perc_int64 end submodule forlab_io_progress_perc","tags":"","loc":"sourcefile/forlab_io_progress_perc.f90.html"},{"title":"forlab_linalg_solve.f90 – FORLAB","text":"Contents Submodules forlab_linalg_solve Source Code forlab_linalg_solve.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_solve implicit none contains module procedure solve_sp integer :: i , j , m , n real ( sp ), dimension (:), allocatable :: w , y real ( sp ), dimension (:, :), allocatable :: L , U , V m = size ( A , 1 ) n = size ( A , 2 ) if ( is_square ( A )) then x = zeros ( m ) y = zeros ( m ) y ( 1 ) = b ( 1 ) ! LU decomposition to solve LUx = b !=================================== call lu ( A , L , U ) ! Forward substitution: Ly = b !============================== do i = 2 , m y ( i ) = b ( i ) do j = 1 , i - 1 y ( i ) = y ( i ) - y ( j ) * L ( i , j ) end do end do ! Back substitution: Ux = y !=========================== x ( m ) = y ( m ) / U ( m , m ) do i = m - 1 , 1 , - 1 x ( i ) = y ( i ) do j = m , i + 1 , - 1 x ( i ) = x ( i ) - x ( j ) * U ( i , j ) end do x ( i ) = x ( i ) / U ( i , i ) end do else x = svdsolve ( A , b ) end if end procedure solve_sp module procedure solve_dp integer :: i , j , m , n real ( dp ), dimension (:), allocatable :: w , y real ( dp ), dimension (:, :), allocatable :: L , U , V m = size ( A , 1 ) n = size ( A , 2 ) if ( is_square ( A )) then x = zeros ( m ) y = zeros ( m ) y ( 1 ) = b ( 1 ) ! LU decomposition to solve LUx = b !=================================== call lu ( A , L , U ) ! Forward substitution: Ly = b !============================== do i = 2 , m y ( i ) = b ( i ) do j = 1 , i - 1 y ( i ) = y ( i ) - y ( j ) * L ( i , j ) end do end do ! Back substitution: Ux = y !=========================== x ( m ) = y ( m ) / U ( m , m ) do i = m - 1 , 1 , - 1 x ( i ) = y ( i ) do j = m , i + 1 , - 1 x ( i ) = x ( i ) - x ( j ) * U ( i , j ) end do x ( i ) = x ( i ) / U ( i , i ) end do else x = svdsolve ( A , b ) end if end procedure solve_dp module procedure solve_qp integer :: i , j , m , n real ( qp ), dimension (:), allocatable :: w , y real ( qp ), dimension (:, :), allocatable :: L , U , V m = size ( A , 1 ) n = size ( A , 2 ) if ( is_square ( A )) then x = zeros ( m ) y = zeros ( m ) y ( 1 ) = b ( 1 ) ! LU decomposition to solve LUx = b !=================================== call lu ( A , L , U ) ! Forward substitution: Ly = b !============================== do i = 2 , m y ( i ) = b ( i ) do j = 1 , i - 1 y ( i ) = y ( i ) - y ( j ) * L ( i , j ) end do end do ! Back substitution: Ux = y !=========================== x ( m ) = y ( m ) / U ( m , m ) do i = m - 1 , 1 , - 1 x ( i ) = y ( i ) do j = m , i + 1 , - 1 x ( i ) = x ( i ) - x ( j ) * U ( i , j ) end do x ( i ) = x ( i ) / U ( i , i ) end do else x = svdsolve ( A , b ) end if end procedure solve_qp end submodule forlab_linalg_solve","tags":"","loc":"sourcefile/forlab_linalg_solve.f90.html"},{"title":"forlab_io.f90 – FORLAB","text":"Contents Modules forlab_io Source Code forlab_io.f90 Source Code module forlab_io use stdlib_error , only : error_stop use stdlib_io , only : open , parse_mode use stdlib_strings , only : to_string use stdlib_kinds , only : sp , dp , qp , int8 , int16 , int32 , int64 , lk , c_bool use stdlib_optval , only : optval use stdlib_strings , only : to_string use stdlib_string_type , only : string_type implicit none private public :: file public :: countlines , file_exist public :: savebin , loadbin , savetxt , loadtxt public :: color public :: disp public :: progress_bar , progress_perc !> Version: experimental !> !> forlab file derived type. !> ([Specification](../page/specs/forlab_io.html#file-file-constructor-and-file-derived-type)) type file character (:), allocatable :: filename character ( 3 ) :: mode integer :: unit integer :: lines contains procedure :: exist => file_exist1 procedure :: open => open_file procedure :: countlines => countlines1 procedure :: close end type file !> version: experimental !> !> Display a scalar, vector or matrix. !> ([Specification](../page/specs/stdlib_io.html#disp-display-your-data-to-the-screen-or-another-output-unit)) interface disp module subroutine disp_0_rsp ( x , header , unit , brief ) real ( sp ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_0_rsp module subroutine disp_1_rsp ( x , header , unit , brief ) real ( sp ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_1_rsp module subroutine disp_2_rsp ( x , header , unit , brief ) real ( sp ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_2_rsp module subroutine disp_0_rdp ( x , header , unit , brief ) real ( dp ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_0_rdp module subroutine disp_1_rdp ( x , header , unit , brief ) real ( dp ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_1_rdp module subroutine disp_2_rdp ( x , header , unit , brief ) real ( dp ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_2_rdp module subroutine disp_0_rqp ( x , header , unit , brief ) real ( qp ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_0_rqp module subroutine disp_1_rqp ( x , header , unit , brief ) real ( qp ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_1_rqp module subroutine disp_2_rqp ( x , header , unit , brief ) real ( qp ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_2_rqp module subroutine disp_0_iint8 ( x , header , unit , brief ) integer ( int8 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_0_iint8 module subroutine disp_1_iint8 ( x , header , unit , brief ) integer ( int8 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_1_iint8 module subroutine disp_2_iint8 ( x , header , unit , brief ) integer ( int8 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_2_iint8 module subroutine disp_0_iint16 ( x , header , unit , brief ) integer ( int16 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_0_iint16 module subroutine disp_1_iint16 ( x , header , unit , brief ) integer ( int16 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_1_iint16 module subroutine disp_2_iint16 ( x , header , unit , brief ) integer ( int16 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_2_iint16 module subroutine disp_0_iint32 ( x , header , unit , brief ) integer ( int32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_0_iint32 module subroutine disp_1_iint32 ( x , header , unit , brief ) integer ( int32 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_1_iint32 module subroutine disp_2_iint32 ( x , header , unit , brief ) integer ( int32 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_2_iint32 module subroutine disp_0_iint64 ( x , header , unit , brief ) integer ( int64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_0_iint64 module subroutine disp_1_iint64 ( x , header , unit , brief ) integer ( int64 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_1_iint64 module subroutine disp_2_iint64 ( x , header , unit , brief ) integer ( int64 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_2_iint64 module subroutine disp_0_csp ( x , header , unit , brief ) complex ( sp ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_0_csp module subroutine disp_1_csp ( x , header , unit , brief ) complex ( sp ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_1_csp module subroutine disp_2_csp ( x , header , unit , brief ) complex ( sp ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_2_csp module subroutine disp_0_cdp ( x , header , unit , brief ) complex ( dp ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_0_cdp module subroutine disp_1_cdp ( x , header , unit , brief ) complex ( dp ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_1_cdp module subroutine disp_2_cdp ( x , header , unit , brief ) complex ( dp ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_2_cdp module subroutine disp_0_cqp ( x , header , unit , brief ) complex ( qp ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_0_cqp module subroutine disp_1_cqp ( x , header , unit , brief ) complex ( qp ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_1_cqp module subroutine disp_2_cqp ( x , header , unit , brief ) complex ( qp ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_2_cqp module subroutine disp_0_llk ( x , header , unit , brief ) logical ( lk ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_0_llk module subroutine disp_1_llk ( x , header , unit , brief ) logical ( lk ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_1_llk module subroutine disp_2_llk ( x , header , unit , brief ) logical ( lk ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_2_llk module subroutine disp_0_lc_bool ( x , header , unit , brief ) logical ( c_bool ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_0_lc_bool module subroutine disp_1_lc_bool ( x , header , unit , brief ) logical ( c_bool ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_1_lc_bool module subroutine disp_2_lc_bool ( x , header , unit , brief ) logical ( c_bool ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_2_lc_bool module subroutine disp_character ( x , header , unit , brief ) character ( len =* ), intent ( in ), optional :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_character module subroutine disp_string_type ( x , header , unit , brief ) type ( string_type ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: header integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: brief end subroutine disp_string_type end interface disp interface file procedure init_file end interface file interface countlines procedure countlines2 end interface countlines interface file_exist procedure file_exist2 end interface file_exist interface loadbin module subroutine loadbin_1_rsp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( sp ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_1_rdp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( dp ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_1_rqp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( qp ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_1_iint8 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int8 ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_1_iint16 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int16 ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_1_iint32 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int32 ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_1_iint64 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_1_csp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( sp ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_1_cdp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( dp ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_1_cqp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( qp ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_2_rsp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( sp ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_2_rdp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( dp ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_2_rqp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( qp ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_2_iint8 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int8 ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_2_iint16 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int16 ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_2_iint32 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int32 ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_2_iint64 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_2_csp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( sp ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_2_cdp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( dp ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_2_cqp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( qp ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_3_rsp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( sp ), dimension (:, :, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_3_rdp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( dp ), dimension (:, :, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_3_rqp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( qp ), dimension (:, :, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_3_iint8 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int8 ), dimension (:, :, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_3_iint16 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int16 ), dimension (:, :, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_3_iint32 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int32 ), dimension (:, :, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_3_iint64 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:, :, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_3_csp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( sp ), dimension (:, :, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_3_cdp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( dp ), dimension (:, :, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadbin_3_cqp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( qp ), dimension (:, :, :), allocatable , intent ( out ) :: X end subroutine end interface interface loadtxt module subroutine loadtxt_1_rsp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( sp ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_1_rdp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( dp ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_1_rqp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( qp ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_1_iint8 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int8 ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_1_iint16 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int16 ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_1_iint32 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int32 ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_1_iint64 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_1_csp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( sp ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_1_cdp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( dp ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_1_cqp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( qp ), dimension (:), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_2_rsp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( sp ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_2_rdp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( dp ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_2_rqp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( qp ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_2_iint8 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int8 ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_2_iint16 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int16 ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_2_iint32 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int32 ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_2_iint64 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_2_csp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( sp ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_2_cdp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( dp ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine module subroutine loadtxt_2_cqp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( qp ), dimension (:, :), allocatable , intent ( out ) :: X end subroutine end interface interface savebin module subroutine savebin_1_rsp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( sp ), dimension (:), intent ( in ) :: X end subroutine module subroutine savebin_1_rdp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( dp ), dimension (:), intent ( in ) :: X end subroutine module subroutine savebin_1_rqp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( qp ), dimension (:), intent ( in ) :: X end subroutine module subroutine savebin_1_iint8 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int8 ), dimension (:), intent ( in ) :: X end subroutine module subroutine savebin_1_iint16 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int16 ), dimension (:), intent ( in ) :: X end subroutine module subroutine savebin_1_iint32 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int32 ), dimension (:), intent ( in ) :: X end subroutine module subroutine savebin_1_iint64 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:), intent ( in ) :: X end subroutine module subroutine savebin_1_csp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( sp ), dimension (:), intent ( in ) :: X end subroutine module subroutine savebin_1_cdp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( dp ), dimension (:), intent ( in ) :: X end subroutine module subroutine savebin_1_cqp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( qp ), dimension (:), intent ( in ) :: X end subroutine module subroutine savebin_2_rsp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( sp ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savebin_2_rdp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( dp ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savebin_2_rqp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( qp ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savebin_2_iint8 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int8 ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savebin_2_iint16 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int16 ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savebin_2_iint32 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int32 ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savebin_2_iint64 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savebin_2_csp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( sp ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savebin_2_cdp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( dp ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savebin_2_cqp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( qp ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savebin_3_rsp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( sp ), dimension (:, :, :), intent ( in ) :: X end subroutine module subroutine savebin_3_rdp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( dp ), dimension (:, :, :), intent ( in ) :: X end subroutine module subroutine savebin_3_rqp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( qp ), dimension (:, :, :), intent ( in ) :: X end subroutine module subroutine savebin_3_iint8 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int8 ), dimension (:, :, :), intent ( in ) :: X end subroutine module subroutine savebin_3_iint16 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int16 ), dimension (:, :, :), intent ( in ) :: X end subroutine module subroutine savebin_3_iint32 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int32 ), dimension (:, :, :), intent ( in ) :: X end subroutine module subroutine savebin_3_iint64 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:, :, :), intent ( in ) :: X end subroutine module subroutine savebin_3_csp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( sp ), dimension (:, :, :), intent ( in ) :: X end subroutine module subroutine savebin_3_cdp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( dp ), dimension (:, :, :), intent ( in ) :: X end subroutine module subroutine savebin_3_cqp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( qp ), dimension (:, :, :), intent ( in ) :: X end subroutine end interface savebin interface savetxt module subroutine savetxt_1_rsp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( sp ), dimension (:), intent ( in ) :: X end subroutine module subroutine savetxt_1_rdp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( dp ), dimension (:), intent ( in ) :: X end subroutine module subroutine savetxt_1_rqp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( qp ), dimension (:), intent ( in ) :: X end subroutine module subroutine savetxt_1_iint8 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int8 ), dimension (:), intent ( in ) :: X end subroutine module subroutine savetxt_1_iint16 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int16 ), dimension (:), intent ( in ) :: X end subroutine module subroutine savetxt_1_iint32 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int32 ), dimension (:), intent ( in ) :: X end subroutine module subroutine savetxt_1_iint64 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:), intent ( in ) :: X end subroutine module subroutine savetxt_1_csp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( sp ), dimension (:), intent ( in ) :: X end subroutine module subroutine savetxt_1_cdp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( dp ), dimension (:), intent ( in ) :: X end subroutine module subroutine savetxt_1_cqp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( qp ), dimension (:), intent ( in ) :: X end subroutine module subroutine savetxt_2_rsp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( sp ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savetxt_2_rdp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( dp ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savetxt_2_rqp ( filename , X ) character ( len =* ), intent ( in ) :: filename real ( qp ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savetxt_2_iint8 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int8 ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savetxt_2_iint16 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int16 ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savetxt_2_iint32 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int32 ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savetxt_2_iint64 ( filename , X ) character ( len =* ), intent ( in ) :: filename integer ( int64 ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savetxt_2_csp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( sp ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savetxt_2_cdp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( dp ), dimension (:, :), intent ( in ) :: X end subroutine module subroutine savetxt_2_cqp ( filename , X ) character ( len =* ), intent ( in ) :: filename complex ( qp ), dimension (:, :), intent ( in ) :: X end subroutine end interface savetxt !> Version: experimental !> !> `color` sets color for console text. !> ([Specification](../page/specs/forlab_io.html#color)) interface module subroutine color ( string ) character ( len =* ), intent ( in ), optional :: string end subroutine color end interface !> Version: expermental !> !> Print a progress_bar. !> ([Specification](../page/specs/forlab_io.html#progress_bar)) interface progress_bar module subroutine progress_bar_int8 ( iter , itermax , step , symbol ) integer ( int8 ), intent ( in ) :: iter , itermax integer ( int8 ), intent ( in ), optional :: step character ( * ), intent ( in ), optional :: symbol end subroutine progress_bar_int8 module subroutine progress_bar_int16 ( iter , itermax , step , symbol ) integer ( int16 ), intent ( in ) :: iter , itermax integer ( int16 ), intent ( in ), optional :: step character ( * ), intent ( in ), optional :: symbol end subroutine progress_bar_int16 module subroutine progress_bar_int32 ( iter , itermax , step , symbol ) integer ( int32 ), intent ( in ) :: iter , itermax integer ( int32 ), intent ( in ), optional :: step character ( * ), intent ( in ), optional :: symbol end subroutine progress_bar_int32 module subroutine progress_bar_int64 ( iter , itermax , step , symbol ) integer ( int64 ), intent ( in ) :: iter , itermax integer ( int64 ), intent ( in ), optional :: step character ( * ), intent ( in ), optional :: symbol end subroutine progress_bar_int64 end interface progress_bar !> Version: expermental !> !> Print a progress percentage message. !> ([Specification](../page/specs/forlab_io.html#progress_perc)) interface progress_perc module subroutine progress_perc_int8 ( iter , itermax , prefix ) integer ( int8 ), intent ( in ) :: iter , itermax character ( * ), intent ( in ), optional :: prefix end subroutine progress_perc_int8 module subroutine progress_perc_int16 ( iter , itermax , prefix ) integer ( int16 ), intent ( in ) :: iter , itermax character ( * ), intent ( in ), optional :: prefix end subroutine progress_perc_int16 module subroutine progress_perc_int32 ( iter , itermax , prefix ) integer ( int32 ), intent ( in ) :: iter , itermax character ( * ), intent ( in ), optional :: prefix end subroutine progress_perc_int32 module subroutine progress_perc_int64 ( iter , itermax , prefix ) integer ( int64 ), intent ( in ) :: iter , itermax character ( * ), intent ( in ), optional :: prefix end subroutine progress_perc_int64 end interface progress_perc contains !> Version: experimental !> !> Open the file. ([Specification](../page/specs/forlab_io.html#fileopen)) subroutine open_file ( self ) class ( file ), intent ( inout ) :: self integer :: stat self % unit = open ( self % filename , self % mode , iostat = stat ) if ( stat /= 0 ) call error_stop ( 'Error: File \"' // self % filename // & '\" open failed, iostat = ' // to_string ( stat )) end subroutine open_file !> Version: experimental !> !> `close` closes a `file` object, deallocate `file%filename`. !> ([Specification](../page/specs/forlab_io.html#fileclose)) subroutine close ( self ) class ( file ), intent ( inout ) :: self deallocate ( self % filename ) close ( self % unit ) end subroutine close !> Version: experimental !> !> `countlines` counts the number of lines in a txt file. !> ([Specification](../page/specs/forlab_io.html#filecountlines)) subroutine countlines1 ( self ) class ( file ), intent ( inout ) :: self integer :: ierr logical :: ok self % lines = 0 ok = . false . inquire ( unit = self % unit , opened = ok ) if ( ok ) then rewind ( self % unit ) do read ( self % unit , * , iostat = ierr ) if ( ierr < 0 ) exit self % lines = self % lines + 1 end do rewind ( self % unit ) else call self % open () do read ( self % unit , * , iostat = ierr ) if ( ierr < 0 ) exit self % lines = self % lines + 1 end do call self % close () end if if ( self % lines == 0 ) then call disp ( 'Warn: linecounts is 0 in \"' // self % filename // '\".' ) end if end subroutine countlines1 !> The `countlines2` function returns the number of lines of the file integer function countlines2 ( filename ) character ( len =* ), intent ( in ) :: filename type ( file ) :: infile infile = file ( trim ( filename )) if (. not . infile % exist ()) call error_stop ( 'Error: File \"' // infile % filename & // '\" open failed.' ) call infile % open () call infile % countlines () call infile % close () countlines2 = infile % lines end function countlines2 !> Version: experimental !> !> `file_exist` determines whether a `file` object already exists. !> ([Specification](../page/specs/forlab_io.html#fileexist)) function file_exist1 ( self ) result ( result ) class ( File ), intent ( inout ) :: self logical :: result inquire ( file = self % filename , exist = result ) end function file_exist1 logical function file_exist2 ( filename ) !! The `countlines2` function returns the number of lines of the file character ( len =* ), intent ( in ) :: filename type ( File ) :: infile infile = File ( filename ) file_exist2 = infile % exist () return end function file_exist2 type ( file ) function init_file ( filename , mode ) !!## File (constructor) !! File constructs a File object. !! !!### Syntax !! ofile = file(filename, mode) !! !!### Description !! `ofile = file(filename, mode)` returns a File object associated to the !! file filename with the identifier unit. !! !!### Examples !!    type(file) :: ofile !! !!    ofile = file(\"myfile.txt\", \"r\") !!    call ofile%open() !!    !! ... some operations on this file ... !!    call ofile%close() character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ), optional :: mode character ( len = 3 ) :: mode_ mode_ = parse_mode ( optval ( mode , '' )) init_file % filename = filename init_file % mode = mode_ return end function init_file end module forlab_io","tags":"","loc":"sourcefile/forlab_io.f90.html"},{"title":"forlab_io_progress_bar.f90 – FORLAB","text":"Contents Submodules forlab_io_progress_bar Source Code forlab_io_progress_bar.f90 Source Code submodule ( forlab_io ) forlab_io_progress_bar implicit none contains module subroutine progress_bar_int8 ( iter , itermax , step , symbol ) integer ( int8 ), intent ( in ) :: iter , itermax integer ( int8 ), intent ( in ), optional :: step character ( * ), intent ( in ), optional :: symbol integer ( int8 ) :: step_ , i , percentage character (:), allocatable :: symbol_ , bar step_ = optval ( step , 50_int8 ) symbol_ = optval ( symbol , \"=\" ) bar = \"  [\" do i = 1_int8 , step_ bar = bar // \" \" end do bar = bar // \"]\" percentage = real ( iter ) / real ( itermax ) * 10 0.0 do i = 1_int8 , floor ( percentage / ( 10 0.0 / step_ ), int8 ) bar ( 3_int8 + i : 3_int8 + i ) = symbol_ end do i = ceiling (( step_ + 2_int8 ) / 2.0 , int8 ) write ( bar ( i + 1_int8 : i + 3_int8 ), \"(i3)\" ) percentage bar ( i + 4_int8 : i + 4_int8 ) = \"%\" if ( percentage < 100_int8 . and . percentage > 50_int8 - 100_int8 / step_ ) & bar ( i + 1_int8 : i + 1_int8 ) = symbol_ write ( * , \"(a1, A)\" , advance = \"no\" ) achar ( 13 ), bar end subroutine progress_bar_int8 module subroutine progress_bar_int16 ( iter , itermax , step , symbol ) integer ( int16 ), intent ( in ) :: iter , itermax integer ( int16 ), intent ( in ), optional :: step character ( * ), intent ( in ), optional :: symbol integer ( int16 ) :: step_ , i , percentage character (:), allocatable :: symbol_ , bar step_ = optval ( step , 50_int16 ) symbol_ = optval ( symbol , \"=\" ) bar = \"  [\" do i = 1_int16 , step_ bar = bar // \" \" end do bar = bar // \"]\" percentage = real ( iter ) / real ( itermax ) * 10 0.0 do i = 1_int16 , floor ( percentage / ( 10 0.0 / step_ ), int16 ) bar ( 3_int16 + i : 3_int16 + i ) = symbol_ end do i = ceiling (( step_ + 2_int16 ) / 2.0 , int16 ) write ( bar ( i + 1_int16 : i + 3_int16 ), \"(i3)\" ) percentage bar ( i + 4_int16 : i + 4_int16 ) = \"%\" if ( percentage < 100_int16 . and . percentage > 50_int16 - 100_int16 / step_ ) & bar ( i + 1_int16 : i + 1_int16 ) = symbol_ write ( * , \"(a1, A)\" , advance = \"no\" ) achar ( 13 ), bar end subroutine progress_bar_int16 module subroutine progress_bar_int32 ( iter , itermax , step , symbol ) integer ( int32 ), intent ( in ) :: iter , itermax integer ( int32 ), intent ( in ), optional :: step character ( * ), intent ( in ), optional :: symbol integer ( int32 ) :: step_ , i , percentage character (:), allocatable :: symbol_ , bar step_ = optval ( step , 50_int32 ) symbol_ = optval ( symbol , \"=\" ) bar = \"  [\" do i = 1_int32 , step_ bar = bar // \" \" end do bar = bar // \"]\" percentage = real ( iter ) / real ( itermax ) * 10 0.0 do i = 1_int32 , floor ( percentage / ( 10 0.0 / step_ ), int32 ) bar ( 3_int32 + i : 3_int32 + i ) = symbol_ end do i = ceiling (( step_ + 2_int32 ) / 2.0 , int32 ) write ( bar ( i + 1_int32 : i + 3_int32 ), \"(i3)\" ) percentage bar ( i + 4_int32 : i + 4_int32 ) = \"%\" if ( percentage < 100_int32 . and . percentage > 50_int32 - 100_int32 / step_ ) & bar ( i + 1_int32 : i + 1_int32 ) = symbol_ write ( * , \"(a1, A)\" , advance = \"no\" ) achar ( 13 ), bar end subroutine progress_bar_int32 module subroutine progress_bar_int64 ( iter , itermax , step , symbol ) integer ( int64 ), intent ( in ) :: iter , itermax integer ( int64 ), intent ( in ), optional :: step character ( * ), intent ( in ), optional :: symbol integer ( int64 ) :: step_ , i , percentage character (:), allocatable :: symbol_ , bar step_ = optval ( step , 50_int64 ) symbol_ = optval ( symbol , \"=\" ) bar = \"  [\" do i = 1_int64 , step_ bar = bar // \" \" end do bar = bar // \"]\" percentage = real ( iter ) / real ( itermax ) * 10 0.0 do i = 1_int64 , floor ( percentage / ( 10 0.0 / step_ ), int64 ) bar ( 3_int64 + i : 3_int64 + i ) = symbol_ end do i = ceiling (( step_ + 2_int64 ) / 2.0 , int64 ) write ( bar ( i + 1_int64 : i + 3_int64 ), \"(i3)\" ) percentage bar ( i + 4_int64 : i + 4_int64 ) = \"%\" if ( percentage < 100_int64 . and . percentage > 50_int64 - 100_int64 / step_ ) & bar ( i + 1_int64 : i + 1_int64 ) = symbol_ write ( * , \"(a1, A)\" , advance = \"no\" ) achar ( 13 ), bar end subroutine progress_bar_int64 end submodule forlab_io_progress_bar","tags":"","loc":"sourcefile/forlab_io_progress_bar.f90.html"},{"title":"forlab_linalg_det.f90 – FORLAB","text":"Contents Submodules forlab_linalg_det Source Code forlab_linalg_det.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_det implicit none contains module procedure det_sp real ( sp ), dimension (:, :), allocatable :: L , U integer :: m if ( is_square ( A )) then m = size ( A , 1 ) if ( m . eq . 2 ) then det = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) elseif ( m . eq . 3 ) then det = A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) & + A ( 2 , 1 ) * A ( 3 , 2 ) * A ( 1 , 3 ) & + A ( 3 , 1 ) * A ( 1 , 2 ) * A ( 2 , 3 ) & - A ( 1 , 1 ) * A ( 3 , 2 ) * A ( 2 , 3 ) & - A ( 3 , 1 ) * A ( 2 , 2 ) * A ( 1 , 3 ) & - A ( 2 , 1 ) * A ( 1 , 2 ) * A ( 3 , 3 ) else call lu ( A , L , U ) det = product ( diag ( U )) if ( present ( outL )) outL = L if ( present ( outU )) outU = U end if else call error_stop ( \"Error: in det(A), A should be square.\" ) end if return end procedure det_sp module procedure det_dp real ( dp ), dimension (:, :), allocatable :: L , U integer :: m if ( is_square ( A )) then m = size ( A , 1 ) if ( m . eq . 2 ) then det = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) elseif ( m . eq . 3 ) then det = A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) & + A ( 2 , 1 ) * A ( 3 , 2 ) * A ( 1 , 3 ) & + A ( 3 , 1 ) * A ( 1 , 2 ) * A ( 2 , 3 ) & - A ( 1 , 1 ) * A ( 3 , 2 ) * A ( 2 , 3 ) & - A ( 3 , 1 ) * A ( 2 , 2 ) * A ( 1 , 3 ) & - A ( 2 , 1 ) * A ( 1 , 2 ) * A ( 3 , 3 ) else call lu ( A , L , U ) det = product ( diag ( U )) if ( present ( outL )) outL = L if ( present ( outU )) outU = U end if else call error_stop ( \"Error: in det(A), A should be square.\" ) end if return end procedure det_dp module procedure det_qp real ( qp ), dimension (:, :), allocatable :: L , U integer :: m if ( is_square ( A )) then m = size ( A , 1 ) if ( m . eq . 2 ) then det = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) elseif ( m . eq . 3 ) then det = A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) & + A ( 2 , 1 ) * A ( 3 , 2 ) * A ( 1 , 3 ) & + A ( 3 , 1 ) * A ( 1 , 2 ) * A ( 2 , 3 ) & - A ( 1 , 1 ) * A ( 3 , 2 ) * A ( 2 , 3 ) & - A ( 3 , 1 ) * A ( 2 , 2 ) * A ( 1 , 3 ) & - A ( 2 , 1 ) * A ( 1 , 2 ) * A ( 3 , 3 ) else call lu ( A , L , U ) det = product ( diag ( U )) if ( present ( outL )) outL = L if ( present ( outU )) outU = U end if else call error_stop ( \"Error: in det(A), A should be square.\" ) end if return end procedure det_qp end submodule forlab_linalg_det","tags":"","loc":"sourcefile/forlab_linalg_det.f90.html"},{"title":"forlab_linalg_diff.f90 – FORLAB","text":"Contents Submodules forlab_linalg_diff Source Code forlab_linalg_diff.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_diff implicit none contains !> `diff` computes differences of arrays of the real(sp) type. pure module function diff_1_sp ( x , n ) result ( result ) real ( sp ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n real ( sp ), dimension (:), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = x do i = 1 , n_ result = result ( 2 :) - result (: size ( result ) - 1 ) end do end function diff_1_sp !> `diff` computes differences of arrays of the real(sp) type. pure module function diff_2_sp ( A , n , dim ) result ( result ) real ( sp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim real ( sp ), dimension (:, :), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = A if ((. not . present ( dim )) . or . ( dim == 1 )) then do i = 1 , n_ result = result ( 2 :, :) - result (: size ( result , 1 ) - 1 , :) end do elseif ( dim == 2 ) then do i = 1 , n_ result = result (:, 2 :) - result (:, : size ( result , 2 ) - 1 ) end do end if end function diff_2_sp !> `diff` computes differences of arrays of the real(dp) type. pure module function diff_1_dp ( x , n ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n real ( dp ), dimension (:), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = x do i = 1 , n_ result = result ( 2 :) - result (: size ( result ) - 1 ) end do end function diff_1_dp !> `diff` computes differences of arrays of the real(dp) type. pure module function diff_2_dp ( A , n , dim ) result ( result ) real ( dp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim real ( dp ), dimension (:, :), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = A if ((. not . present ( dim )) . or . ( dim == 1 )) then do i = 1 , n_ result = result ( 2 :, :) - result (: size ( result , 1 ) - 1 , :) end do elseif ( dim == 2 ) then do i = 1 , n_ result = result (:, 2 :) - result (:, : size ( result , 2 ) - 1 ) end do end if end function diff_2_dp !> `diff` computes differences of arrays of the real(qp) type. pure module function diff_1_qp ( x , n ) result ( result ) real ( qp ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n real ( qp ), dimension (:), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = x do i = 1 , n_ result = result ( 2 :) - result (: size ( result ) - 1 ) end do end function diff_1_qp !> `diff` computes differences of arrays of the real(qp) type. pure module function diff_2_qp ( A , n , dim ) result ( result ) real ( qp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim real ( qp ), dimension (:, :), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = A if ((. not . present ( dim )) . or . ( dim == 1 )) then do i = 1 , n_ result = result ( 2 :, :) - result (: size ( result , 1 ) - 1 , :) end do elseif ( dim == 2 ) then do i = 1 , n_ result = result (:, 2 :) - result (:, : size ( result , 2 ) - 1 ) end do end if end function diff_2_qp !> `diff` computes differences of arrays of the integer(int8) type. pure module function diff_1_int8 ( x , n ) result ( result ) integer ( int8 ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n integer ( int8 ), dimension (:), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = x do i = 1 , n_ result = result ( 2 :) - result (: size ( result ) - 1 ) end do end function diff_1_int8 !> `diff` computes differences of arrays of the integer(int8) type. pure module function diff_2_int8 ( A , n , dim ) result ( result ) integer ( int8 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim integer ( int8 ), dimension (:, :), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = A if ((. not . present ( dim )) . or . ( dim == 1 )) then do i = 1 , n_ result = result ( 2 :, :) - result (: size ( result , 1 ) - 1 , :) end do elseif ( dim == 2 ) then do i = 1 , n_ result = result (:, 2 :) - result (:, : size ( result , 2 ) - 1 ) end do end if end function diff_2_int8 !> `diff` computes differences of arrays of the integer(int16) type. pure module function diff_1_int16 ( x , n ) result ( result ) integer ( int16 ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n integer ( int16 ), dimension (:), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = x do i = 1 , n_ result = result ( 2 :) - result (: size ( result ) - 1 ) end do end function diff_1_int16 !> `diff` computes differences of arrays of the integer(int16) type. pure module function diff_2_int16 ( A , n , dim ) result ( result ) integer ( int16 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim integer ( int16 ), dimension (:, :), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = A if ((. not . present ( dim )) . or . ( dim == 1 )) then do i = 1 , n_ result = result ( 2 :, :) - result (: size ( result , 1 ) - 1 , :) end do elseif ( dim == 2 ) then do i = 1 , n_ result = result (:, 2 :) - result (:, : size ( result , 2 ) - 1 ) end do end if end function diff_2_int16 !> `diff` computes differences of arrays of the integer(int32) type. pure module function diff_1_int32 ( x , n ) result ( result ) integer ( int32 ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n integer ( int32 ), dimension (:), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = x do i = 1 , n_ result = result ( 2 :) - result (: size ( result ) - 1 ) end do end function diff_1_int32 !> `diff` computes differences of arrays of the integer(int32) type. pure module function diff_2_int32 ( A , n , dim ) result ( result ) integer ( int32 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim integer ( int32 ), dimension (:, :), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = A if ((. not . present ( dim )) . or . ( dim == 1 )) then do i = 1 , n_ result = result ( 2 :, :) - result (: size ( result , 1 ) - 1 , :) end do elseif ( dim == 2 ) then do i = 1 , n_ result = result (:, 2 :) - result (:, : size ( result , 2 ) - 1 ) end do end if end function diff_2_int32 !> `diff` computes differences of arrays of the integer(int64) type. pure module function diff_1_int64 ( x , n ) result ( result ) integer ( int64 ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n integer ( int64 ), dimension (:), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = x do i = 1 , n_ result = result ( 2 :) - result (: size ( result ) - 1 ) end do end function diff_1_int64 !> `diff` computes differences of arrays of the integer(int64) type. pure module function diff_2_int64 ( A , n , dim ) result ( result ) integer ( int64 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim integer ( int64 ), dimension (:, :), allocatable :: result integer :: n_ , i n_ = merge ( n , 1 , present ( n )) result = A if ((. not . present ( dim )) . or . ( dim == 1 )) then do i = 1 , n_ result = result ( 2 :, :) - result (: size ( result , 1 ) - 1 , :) end do elseif ( dim == 2 ) then do i = 1 , n_ result = result (:, 2 :) - result (:, : size ( result , 2 ) - 1 ) end do end if end function diff_2_int64 end submodule forlab_linalg_diff","tags":"","loc":"sourcefile/forlab_linalg_diff.f90.html"},{"title":"forlab_math_signum.f90 – FORLAB","text":"Contents Submodules forlab_math_signum Source Code forlab_math_signum.f90 Source Code submodule ( forlab_math ) forlab_math_signum contains real ( sp ) elemental module function signum_rsp ( x ) result ( sign ) real ( sp ), intent ( in ) :: x if ( x < 0.0_sp ) then ; sign = - 1.0_sp elseif ( x > 0.0_sp ) then ; sign = 1.0_sp else ; sign = 0.0_sp end if end function signum_rsp real ( dp ) elemental module function signum_rdp ( x ) result ( sign ) real ( dp ), intent ( in ) :: x if ( x < 0.0_dp ) then ; sign = - 1.0_dp elseif ( x > 0.0_dp ) then ; sign = 1.0_dp else ; sign = 0.0_dp end if end function signum_rdp real ( qp ) elemental module function signum_rqp ( x ) result ( sign ) real ( qp ), intent ( in ) :: x if ( x < 0.0_qp ) then ; sign = - 1.0_qp elseif ( x > 0.0_qp ) then ; sign = 1.0_qp else ; sign = 0.0_qp end if end function signum_rqp integer ( int8 ) elemental module function signum_iint8 ( x ) result ( sign ) integer ( int8 ), intent ( in ) :: x if ( x < 0_int8 ) then ; sign = - 1_int8 elseif ( x > 0_int8 ) then ; sign = 1_int8 else ; sign = 0_int8 end if end function signum_iint8 integer ( int16 ) elemental module function signum_iint16 ( x ) result ( sign ) integer ( int16 ), intent ( in ) :: x if ( x < 0_int16 ) then ; sign = - 1_int16 elseif ( x > 0_int16 ) then ; sign = 1_int16 else ; sign = 0_int16 end if end function signum_iint16 integer ( int32 ) elemental module function signum_iint32 ( x ) result ( sign ) integer ( int32 ), intent ( in ) :: x if ( x < 0_int32 ) then ; sign = - 1_int32 elseif ( x > 0_int32 ) then ; sign = 1_int32 else ; sign = 0_int32 end if end function signum_iint32 integer ( int64 ) elemental module function signum_iint64 ( x ) result ( sign ) integer ( int64 ), intent ( in ) :: x if ( x < 0_int64 ) then ; sign = - 1_int64 elseif ( x > 0_int64 ) then ; sign = 1_int64 else ; sign = 0_int64 end if end function signum_iint64 complex ( sp ) elemental module function signum_csp ( x ) result ( sign ) complex ( sp ), intent ( in ) :: x if ( x == ( 0.0_sp , 0.0_sp )) then ; sign = x else ; sign = x / abs ( x ) end if end function signum_csp complex ( dp ) elemental module function signum_cdp ( x ) result ( sign ) complex ( dp ), intent ( in ) :: x if ( x == ( 0.0_dp , 0.0_dp )) then ; sign = x else ; sign = x / abs ( x ) end if end function signum_cdp complex ( qp ) elemental module function signum_cqp ( x ) result ( sign ) complex ( qp ), intent ( in ) :: x if ( x == ( 0.0_qp , 0.0_qp )) then ; sign = x else ; sign = x / abs ( x ) end if end function signum_cqp end submodule forlab_math_signum","tags":"","loc":"sourcefile/forlab_math_signum.f90.html"},{"title":"forlab_linalg_chol.f90 – FORLAB","text":"Contents Submodules forlab_linalg_chol Source Code forlab_linalg_chol.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_chol implicit none contains module procedure chol_sp integer :: i , j , k , n real ( sp ) :: sum1 , sum2 real ( sp ), dimension (:), allocatable :: d real ( sp ), dimension (:,:), allocatable :: V real ( sp ), parameter :: zero = 0.0_sp , one = 1.0_sp call eig ( A , V , d ) deallocate ( V ) if ( all ( d >= zero )) then n = size ( A , 1 ) L = zeros ( n , n ) L ( 1 , 1 ) = sqrt ( A ( 1 , 1 )) do i = 2 , n L ( i , 1 ) = A ( i , 1 ) / L ( 1 , 1 ) end do do i = 2 , n do k = 1 , i sum1 = zero sum2 = zero do j = 1 , k - 1 if ( i == k ) then sum1 = sum1 + ( L ( k , j ) * L ( k , j )) L ( k , k ) = sqrt ( A ( k , k ) - sum1 ) elseif ( i . gt . k ) then sum2 = sum2 + ( L ( i , j ) * L ( k , j )) L ( i , k ) = ( one / L ( k , k )) * ( A ( i , k ) - sum2 ) else L ( i , k ) = zero end if end do end do end do else error stop \"Error: in chol(A), A should be positive definite.\" end if deallocate ( d ) end procedure chol_sp module procedure chol_dp integer :: i , j , k , n real ( dp ) :: sum1 , sum2 real ( dp ), dimension (:), allocatable :: d real ( dp ), dimension (:,:), allocatable :: V real ( dp ), parameter :: zero = 0.0_dp , one = 1.0_dp call eig ( A , V , d ) deallocate ( V ) if ( all ( d >= zero )) then n = size ( A , 1 ) L = zeros ( n , n ) L ( 1 , 1 ) = sqrt ( A ( 1 , 1 )) do i = 2 , n L ( i , 1 ) = A ( i , 1 ) / L ( 1 , 1 ) end do do i = 2 , n do k = 1 , i sum1 = zero sum2 = zero do j = 1 , k - 1 if ( i == k ) then sum1 = sum1 + ( L ( k , j ) * L ( k , j )) L ( k , k ) = sqrt ( A ( k , k ) - sum1 ) elseif ( i . gt . k ) then sum2 = sum2 + ( L ( i , j ) * L ( k , j )) L ( i , k ) = ( one / L ( k , k )) * ( A ( i , k ) - sum2 ) else L ( i , k ) = zero end if end do end do end do else error stop \"Error: in chol(A), A should be positive definite.\" end if deallocate ( d ) end procedure chol_dp module procedure chol_qp integer :: i , j , k , n real ( qp ) :: sum1 , sum2 real ( qp ), dimension (:), allocatable :: d real ( qp ), dimension (:,:), allocatable :: V real ( qp ), parameter :: zero = 0.0_qp , one = 1.0_qp call eig ( A , V , d ) deallocate ( V ) if ( all ( d >= zero )) then n = size ( A , 1 ) L = zeros ( n , n ) L ( 1 , 1 ) = sqrt ( A ( 1 , 1 )) do i = 2 , n L ( i , 1 ) = A ( i , 1 ) / L ( 1 , 1 ) end do do i = 2 , n do k = 1 , i sum1 = zero sum2 = zero do j = 1 , k - 1 if ( i == k ) then sum1 = sum1 + ( L ( k , j ) * L ( k , j )) L ( k , k ) = sqrt ( A ( k , k ) - sum1 ) elseif ( i . gt . k ) then sum2 = sum2 + ( L ( i , j ) * L ( k , j )) L ( i , k ) = ( one / L ( k , k )) * ( A ( i , k ) - sum2 ) else L ( i , k ) = zero end if end do end do end do else error stop \"Error: in chol(A), A should be positive definite.\" end if deallocate ( d ) end procedure chol_qp end submodule forlab_linalg_chol","tags":"","loc":"sourcefile/forlab_linalg_chol.f90.html"},{"title":"forlab_stats_mean.f90 – FORLAB","text":"Contents Submodules forlab_stats_mean Source Code forlab_stats_mean.f90 Source Code submodule ( forlab_stats ) forlab_stats_mean implicit none contains module procedure mean_1_sp mean = sum ( x ) / size ( x ) return end procedure mean_1_sp module procedure mean_2_sp integer :: i , m , n m = size ( A , 1 ) n = size ( A , 2 ) if ((. not . present ( dim )) . or . ( dim == 1 )) then allocate ( mean ( n )) do i = 1 , n mean ( i ) = mean_1_sp ( A (:, i )) end do elseif ( dim == 2 ) then allocate ( mean ( m )) do i = 1 , m mean ( i ) = mean_1_sp ( A ( i , :)) end do end if return end procedure mean_2_sp module procedure mean_1_dp mean = sum ( x ) / size ( x ) return end procedure mean_1_dp module procedure mean_2_dp integer :: i , m , n m = size ( A , 1 ) n = size ( A , 2 ) if ((. not . present ( dim )) . or . ( dim == 1 )) then allocate ( mean ( n )) do i = 1 , n mean ( i ) = mean_1_dp ( A (:, i )) end do elseif ( dim == 2 ) then allocate ( mean ( m )) do i = 1 , m mean ( i ) = mean_1_dp ( A ( i , :)) end do end if return end procedure mean_2_dp module procedure mean_1_qp mean = sum ( x ) / size ( x ) return end procedure mean_1_qp module procedure mean_2_qp integer :: i , m , n m = size ( A , 1 ) n = size ( A , 2 ) if ((. not . present ( dim )) . or . ( dim == 1 )) then allocate ( mean ( n )) do i = 1 , n mean ( i ) = mean_1_qp ( A (:, i )) end do elseif ( dim == 2 ) then allocate ( mean ( m )) do i = 1 , m mean ( i ) = mean_1_qp ( A ( i , :)) end do end if return end procedure mean_2_qp end submodule forlab_stats_mean","tags":"","loc":"sourcefile/forlab_stats_mean.f90.html"},{"title":"forlab_linalg_inv.f90 – FORLAB","text":"Contents Submodules forlab_linalg_inv Source Code forlab_linalg_inv.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_inv implicit none contains module procedure inv_rsp !! inv0 computes the real matrix inverse. integer :: i , j , k , m real ( sp ) :: D real ( sp ), dimension (:), allocatable :: x , y , e real ( sp ), dimension (:, :), allocatable :: L , U if ( is_square ( A )) then m = size ( A , 1 ) if ( m . le . 3 ) then D = det ( A ) else D = det ( A , L , U ) end if if ( D . ne . 0._sp ) then inv = zeros ( m , m ) if ( m . eq . 2 ) then inv ( 1 , 1 ) = A ( 2 , 2 ) inv ( 1 , 2 ) = - A ( 1 , 2 ) inv ( 2 , 1 ) = - A ( 2 , 1 ) inv ( 2 , 2 ) = A ( 1 , 1 ) inv = inv / D elseif ( m . eq . 3 ) then inv ( 1 , 1 ) = A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 ) inv ( 1 , 2 ) = A ( 1 , 3 ) * A ( 3 , 2 ) - A ( 1 , 2 ) * A ( 3 , 3 ) inv ( 1 , 3 ) = A ( 1 , 2 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 2 ) inv ( 2 , 1 ) = A ( 2 , 3 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 3 ) inv ( 2 , 2 ) = A ( 1 , 1 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 1 ) inv ( 2 , 3 ) = A ( 1 , 3 ) * A ( 2 , 1 ) - A ( 1 , 1 ) * A ( 2 , 3 ) inv ( 3 , 1 ) = A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 ) inv ( 3 , 2 ) = A ( 1 , 2 ) * A ( 3 , 1 ) - A ( 1 , 1 ) * A ( 3 , 2 ) inv ( 3 , 3 ) = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) inv = inv / D else do k = 1 , m x = zeros ( m ) y = zeros ( m ) e = zeros ( m ) e ( k ) = 1. y ( 1 ) = e ( 1 ) ! Forward substitution: Ly = e !============================== do i = 2 , m y ( i ) = e ( i ) do j = 1 , i - 1 y ( i ) = y ( i ) - y ( j ) * L ( i , j ) end do end do ! Back substitution: Ux = y !=========================== x ( m ) = y ( m ) / U ( m , m ) do i = m - 1 , 1 , - 1 x ( i ) = y ( i ) do j = m , i + 1 , - 1 x ( i ) = x ( i ) - x ( j ) * U ( i , j ) end do x ( i ) = x ( i ) / U ( i , i ) end do ! The column k of the inverse is x !================================== inv (:, k ) = x end do end if else call error_stop ( \"Error: in det(A), A is not inversible (= 0).\" ) end if else call error_stop ( \"Error: in inv(A), A should be square.\" ) end if return end procedure module procedure inv_rdp !! inv0 computes the real matrix inverse. integer :: i , j , k , m real ( dp ) :: D real ( dp ), dimension (:), allocatable :: x , y , e real ( dp ), dimension (:, :), allocatable :: L , U if ( is_square ( A )) then m = size ( A , 1 ) if ( m . le . 3 ) then D = det ( A ) else D = det ( A , L , U ) end if if ( D . ne . 0._dp ) then inv = zeros ( m , m ) if ( m . eq . 2 ) then inv ( 1 , 1 ) = A ( 2 , 2 ) inv ( 1 , 2 ) = - A ( 1 , 2 ) inv ( 2 , 1 ) = - A ( 2 , 1 ) inv ( 2 , 2 ) = A ( 1 , 1 ) inv = inv / D elseif ( m . eq . 3 ) then inv ( 1 , 1 ) = A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 ) inv ( 1 , 2 ) = A ( 1 , 3 ) * A ( 3 , 2 ) - A ( 1 , 2 ) * A ( 3 , 3 ) inv ( 1 , 3 ) = A ( 1 , 2 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 2 ) inv ( 2 , 1 ) = A ( 2 , 3 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 3 ) inv ( 2 , 2 ) = A ( 1 , 1 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 1 ) inv ( 2 , 3 ) = A ( 1 , 3 ) * A ( 2 , 1 ) - A ( 1 , 1 ) * A ( 2 , 3 ) inv ( 3 , 1 ) = A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 ) inv ( 3 , 2 ) = A ( 1 , 2 ) * A ( 3 , 1 ) - A ( 1 , 1 ) * A ( 3 , 2 ) inv ( 3 , 3 ) = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) inv = inv / D else do k = 1 , m x = zeros ( m ) y = zeros ( m ) e = zeros ( m ) e ( k ) = 1. y ( 1 ) = e ( 1 ) ! Forward substitution: Ly = e !============================== do i = 2 , m y ( i ) = e ( i ) do j = 1 , i - 1 y ( i ) = y ( i ) - y ( j ) * L ( i , j ) end do end do ! Back substitution: Ux = y !=========================== x ( m ) = y ( m ) / U ( m , m ) do i = m - 1 , 1 , - 1 x ( i ) = y ( i ) do j = m , i + 1 , - 1 x ( i ) = x ( i ) - x ( j ) * U ( i , j ) end do x ( i ) = x ( i ) / U ( i , i ) end do ! The column k of the inverse is x !================================== inv (:, k ) = x end do end if else call error_stop ( \"Error: in det(A), A is not inversible (= 0).\" ) end if else call error_stop ( \"Error: in inv(A), A should be square.\" ) end if return end procedure module procedure inv_rqp !! inv0 computes the real matrix inverse. integer :: i , j , k , m real ( qp ) :: D real ( qp ), dimension (:), allocatable :: x , y , e real ( qp ), dimension (:, :), allocatable :: L , U if ( is_square ( A )) then m = size ( A , 1 ) if ( m . le . 3 ) then D = det ( A ) else D = det ( A , L , U ) end if if ( D . ne . 0._qp ) then inv = zeros ( m , m ) if ( m . eq . 2 ) then inv ( 1 , 1 ) = A ( 2 , 2 ) inv ( 1 , 2 ) = - A ( 1 , 2 ) inv ( 2 , 1 ) = - A ( 2 , 1 ) inv ( 2 , 2 ) = A ( 1 , 1 ) inv = inv / D elseif ( m . eq . 3 ) then inv ( 1 , 1 ) = A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 ) inv ( 1 , 2 ) = A ( 1 , 3 ) * A ( 3 , 2 ) - A ( 1 , 2 ) * A ( 3 , 3 ) inv ( 1 , 3 ) = A ( 1 , 2 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 2 ) inv ( 2 , 1 ) = A ( 2 , 3 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 3 ) inv ( 2 , 2 ) = A ( 1 , 1 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 1 ) inv ( 2 , 3 ) = A ( 1 , 3 ) * A ( 2 , 1 ) - A ( 1 , 1 ) * A ( 2 , 3 ) inv ( 3 , 1 ) = A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 ) inv ( 3 , 2 ) = A ( 1 , 2 ) * A ( 3 , 1 ) - A ( 1 , 1 ) * A ( 3 , 2 ) inv ( 3 , 3 ) = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) inv = inv / D else do k = 1 , m x = zeros ( m ) y = zeros ( m ) e = zeros ( m ) e ( k ) = 1. y ( 1 ) = e ( 1 ) ! Forward substitution: Ly = e !============================== do i = 2 , m y ( i ) = e ( i ) do j = 1 , i - 1 y ( i ) = y ( i ) - y ( j ) * L ( i , j ) end do end do ! Back substitution: Ux = y !=========================== x ( m ) = y ( m ) / U ( m , m ) do i = m - 1 , 1 , - 1 x ( i ) = y ( i ) do j = m , i + 1 , - 1 x ( i ) = x ( i ) - x ( j ) * U ( i , j ) end do x ( i ) = x ( i ) / U ( i , i ) end do ! The column k of the inverse is x !================================== inv (:, k ) = x end do end if else call error_stop ( \"Error: in det(A), A is not inversible (= 0).\" ) end if else call error_stop ( \"Error: in inv(A), A should be square.\" ) end if return end procedure module procedure inv_csp !! inv computes the complex matrix inverse. real ( sp ), dimension (:, :), allocatable :: ar , ai !! AR stores the real part, AI stores the imaginary part integer :: flag , n real ( sp ) :: d , p , t , q , s , b integer , dimension (:), allocatable :: is , js integer :: i , j , k if ( is_square ( A )) then n = size ( A , 1 ) inv = zeros ( n , n ) ar = zeros ( n , n ) ai = zeros ( n , n ) is = ones ( n ) js = ones ( n ) forall ( i = 1 : n , j = 1 : n ) ar ( i , j ) = real ( A ( i , j )); ai ( i , j ) = imag ( A ( i , j )) end forall flag = 1 do k = 1 , n d = 0.0 do i = k , n do j = k , n p = ar ( i , j ) * ar ( i , j ) + ai ( i , j ) * ai ( i , j ) if ( p . gt . d ) then d = p is ( k ) = i js ( k ) = j end if end do end do if ( d + 1.0_sp . eq . 1.0_sp ) then flag = 0 call error_stop ( 'ERROR: A is not inversible (= 0)' ) end if do j = 1 , n t = ar ( k , j ) ar ( k , j ) = ar ( is ( k ), j ) ar ( is ( k ), j ) = t t = ai ( k , j ) ai ( k , j ) = ai ( is ( k ), j ) ai ( is ( k ), j ) = t end do do i = 1 , n t = ar ( i , k ) ar ( i , k ) = ar ( i , js ( k )) ar ( i , js ( k )) = t t = ai ( i , k ) ai ( i , k ) = ai ( i , js ( k )) ai ( i , js ( k )) = t end do ar ( k , k ) = ar ( k , k ) / d ai ( k , k ) = - ai ( k , k ) / d do j = 1 , n if ( j . ne . k ) then p = ar ( k , j ) * ar ( k , k ) q = ai ( k , j ) * ai ( k , k ) s = ( ar ( k , j ) + ai ( k , j )) * ( ar ( k , k ) + ai ( k , k )) ar ( k , j ) = p - q ai ( k , j ) = s - p - q end if end do do i = 1 , n if ( i . ne . k ) then do j = 1 , n if ( j . ne . k ) then p = ar ( k , j ) * ar ( i , k ) q = ai ( k , j ) * ai ( i , k ) s = ( ar ( k , j ) + ai ( k , j )) * ( ar ( i , k ) + ai ( i , k )) t = p - q b = s - p - q ar ( i , j ) = ar ( i , j ) - t ai ( i , j ) = ai ( i , j ) - b end if end do end if end do do i = 1 , n if ( i . ne . k ) then p = ar ( i , k ) * ar ( k , k ) q = ai ( i , k ) * ai ( k , k ) s = ( ar ( i , k ) + ai ( i , k )) * ( ar ( k , k ) + ai ( k , k )) ar ( i , k ) = q - p ai ( i , k ) = p + q - s end if end do end do do k = n , 1 , - 1 do j = 1 , n t = ar ( k , j ) ar ( k , j ) = ar ( js ( k ), j ) ar ( js ( k ), j ) = t t = ai ( k , j ) ai ( k , j ) = ai ( js ( k ), j ) ai ( js ( k ), j ) = t end do do i = 1 , n t = ar ( i , k ) ar ( i , k ) = ar ( i , is ( k )) ar ( i , is ( k )) = t t = ai ( i , k ) ai ( i , k ) = ai ( i , is ( k )) ai ( i , is ( k )) = t end do end do forall ( i = 1 : n , j = 1 : n ) inv ( i , j ) = cmplx ( ar ( i , j ), ai ( i , j ), sp ) end forall else call error_stop ( 'Error: in inv(A), A should be square.' ) end if return end procedure inv_csp module procedure inv_cdp !! inv computes the complex matrix inverse. real ( dp ), dimension (:, :), allocatable :: ar , ai !! AR stores the real part, AI stores the imaginary part integer :: flag , n real ( dp ) :: d , p , t , q , s , b integer , dimension (:), allocatable :: is , js integer :: i , j , k if ( is_square ( A )) then n = size ( A , 1 ) inv = zeros ( n , n ) ar = zeros ( n , n ) ai = zeros ( n , n ) is = ones ( n ) js = ones ( n ) forall ( i = 1 : n , j = 1 : n ) ar ( i , j ) = real ( A ( i , j )); ai ( i , j ) = imag ( A ( i , j )) end forall flag = 1 do k = 1 , n d = 0.0 do i = k , n do j = k , n p = ar ( i , j ) * ar ( i , j ) + ai ( i , j ) * ai ( i , j ) if ( p . gt . d ) then d = p is ( k ) = i js ( k ) = j end if end do end do if ( d + 1.0_dp . eq . 1.0_dp ) then flag = 0 call error_stop ( 'ERROR: A is not inversible (= 0)' ) end if do j = 1 , n t = ar ( k , j ) ar ( k , j ) = ar ( is ( k ), j ) ar ( is ( k ), j ) = t t = ai ( k , j ) ai ( k , j ) = ai ( is ( k ), j ) ai ( is ( k ), j ) = t end do do i = 1 , n t = ar ( i , k ) ar ( i , k ) = ar ( i , js ( k )) ar ( i , js ( k )) = t t = ai ( i , k ) ai ( i , k ) = ai ( i , js ( k )) ai ( i , js ( k )) = t end do ar ( k , k ) = ar ( k , k ) / d ai ( k , k ) = - ai ( k , k ) / d do j = 1 , n if ( j . ne . k ) then p = ar ( k , j ) * ar ( k , k ) q = ai ( k , j ) * ai ( k , k ) s = ( ar ( k , j ) + ai ( k , j )) * ( ar ( k , k ) + ai ( k , k )) ar ( k , j ) = p - q ai ( k , j ) = s - p - q end if end do do i = 1 , n if ( i . ne . k ) then do j = 1 , n if ( j . ne . k ) then p = ar ( k , j ) * ar ( i , k ) q = ai ( k , j ) * ai ( i , k ) s = ( ar ( k , j ) + ai ( k , j )) * ( ar ( i , k ) + ai ( i , k )) t = p - q b = s - p - q ar ( i , j ) = ar ( i , j ) - t ai ( i , j ) = ai ( i , j ) - b end if end do end if end do do i = 1 , n if ( i . ne . k ) then p = ar ( i , k ) * ar ( k , k ) q = ai ( i , k ) * ai ( k , k ) s = ( ar ( i , k ) + ai ( i , k )) * ( ar ( k , k ) + ai ( k , k )) ar ( i , k ) = q - p ai ( i , k ) = p + q - s end if end do end do do k = n , 1 , - 1 do j = 1 , n t = ar ( k , j ) ar ( k , j ) = ar ( js ( k ), j ) ar ( js ( k ), j ) = t t = ai ( k , j ) ai ( k , j ) = ai ( js ( k ), j ) ai ( js ( k ), j ) = t end do do i = 1 , n t = ar ( i , k ) ar ( i , k ) = ar ( i , is ( k )) ar ( i , is ( k )) = t t = ai ( i , k ) ai ( i , k ) = ai ( i , is ( k )) ai ( i , is ( k )) = t end do end do forall ( i = 1 : n , j = 1 : n ) inv ( i , j ) = cmplx ( ar ( i , j ), ai ( i , j ), dp ) end forall else call error_stop ( 'Error: in inv(A), A should be square.' ) end if return end procedure inv_cdp module procedure inv_cqp !! inv computes the complex matrix inverse. real ( qp ), dimension (:, :), allocatable :: ar , ai !! AR stores the real part, AI stores the imaginary part integer :: flag , n real ( qp ) :: d , p , t , q , s , b integer , dimension (:), allocatable :: is , js integer :: i , j , k if ( is_square ( A )) then n = size ( A , 1 ) inv = zeros ( n , n ) ar = zeros ( n , n ) ai = zeros ( n , n ) is = ones ( n ) js = ones ( n ) forall ( i = 1 : n , j = 1 : n ) ar ( i , j ) = real ( A ( i , j )); ai ( i , j ) = imag ( A ( i , j )) end forall flag = 1 do k = 1 , n d = 0.0 do i = k , n do j = k , n p = ar ( i , j ) * ar ( i , j ) + ai ( i , j ) * ai ( i , j ) if ( p . gt . d ) then d = p is ( k ) = i js ( k ) = j end if end do end do if ( d + 1.0_qp . eq . 1.0_qp ) then flag = 0 call error_stop ( 'ERROR: A is not inversible (= 0)' ) end if do j = 1 , n t = ar ( k , j ) ar ( k , j ) = ar ( is ( k ), j ) ar ( is ( k ), j ) = t t = ai ( k , j ) ai ( k , j ) = ai ( is ( k ), j ) ai ( is ( k ), j ) = t end do do i = 1 , n t = ar ( i , k ) ar ( i , k ) = ar ( i , js ( k )) ar ( i , js ( k )) = t t = ai ( i , k ) ai ( i , k ) = ai ( i , js ( k )) ai ( i , js ( k )) = t end do ar ( k , k ) = ar ( k , k ) / d ai ( k , k ) = - ai ( k , k ) / d do j = 1 , n if ( j . ne . k ) then p = ar ( k , j ) * ar ( k , k ) q = ai ( k , j ) * ai ( k , k ) s = ( ar ( k , j ) + ai ( k , j )) * ( ar ( k , k ) + ai ( k , k )) ar ( k , j ) = p - q ai ( k , j ) = s - p - q end if end do do i = 1 , n if ( i . ne . k ) then do j = 1 , n if ( j . ne . k ) then p = ar ( k , j ) * ar ( i , k ) q = ai ( k , j ) * ai ( i , k ) s = ( ar ( k , j ) + ai ( k , j )) * ( ar ( i , k ) + ai ( i , k )) t = p - q b = s - p - q ar ( i , j ) = ar ( i , j ) - t ai ( i , j ) = ai ( i , j ) - b end if end do end if end do do i = 1 , n if ( i . ne . k ) then p = ar ( i , k ) * ar ( k , k ) q = ai ( i , k ) * ai ( k , k ) s = ( ar ( i , k ) + ai ( i , k )) * ( ar ( k , k ) + ai ( k , k )) ar ( i , k ) = q - p ai ( i , k ) = p + q - s end if end do end do do k = n , 1 , - 1 do j = 1 , n t = ar ( k , j ) ar ( k , j ) = ar ( js ( k ), j ) ar ( js ( k ), j ) = t t = ai ( k , j ) ai ( k , j ) = ai ( js ( k ), j ) ai ( js ( k ), j ) = t end do do i = 1 , n t = ar ( i , k ) ar ( i , k ) = ar ( i , is ( k )) ar ( i , is ( k )) = t t = ai ( i , k ) ai ( i , k ) = ai ( i , is ( k )) ai ( i , is ( k )) = t end do end do forall ( i = 1 : n , j = 1 : n ) inv ( i , j ) = cmplx ( ar ( i , j ), ai ( i , j ), qp ) end forall else call error_stop ( 'Error: in inv(A), A should be square.' ) end if return end procedure inv_cqp end submodule forlab_linalg_inv","tags":"","loc":"sourcefile/forlab_linalg_inv.f90.html"},{"title":"forlab_linalg_diag.f90 – FORLAB","text":"Contents Submodules forlab_linalg_diag Source Code forlab_linalg_diag.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_diag implicit none contains module procedure diag1_sp integer :: i , n n = min ( size ( A , 1 ), size ( A , 2 )) allocate ( diag ( n )) do i = 1 , n diag ( i ) = A ( i , i ) end do return end procedure module procedure diag2_sp integer :: i , n n = size ( x ) diag = zeros ( n , n ) do i = 1 , n diag ( i , i ) = x ( i ) end do return end procedure diag2_sp module procedure diag1_dp integer :: i , n n = min ( size ( A , 1 ), size ( A , 2 )) allocate ( diag ( n )) do i = 1 , n diag ( i ) = A ( i , i ) end do return end procedure module procedure diag2_dp integer :: i , n n = size ( x ) diag = zeros ( n , n ) do i = 1 , n diag ( i , i ) = x ( i ) end do return end procedure diag2_dp module procedure diag1_qp integer :: i , n n = min ( size ( A , 1 ), size ( A , 2 )) allocate ( diag ( n )) do i = 1 , n diag ( i ) = A ( i , i ) end do return end procedure module procedure diag2_qp integer :: i , n n = size ( x ) diag = zeros ( n , n ) do i = 1 , n diag ( i , i ) = x ( i ) end do return end procedure diag2_qp end submodule forlab_linalg_diag","tags":"","loc":"sourcefile/forlab_linalg_diag.f90.html"},{"title":"forlab_time_datenum.f90 – FORLAB","text":"Contents Submodules forlab_time_datenum Source Code forlab_time_datenum.f90 Source Code submodule ( forlab_time ) forlab_time_datenum use stdlib_strings , only : to_string use forlab_io , only : disp implicit none contains module procedure datenum0 integer :: i , days_per_month ( 12 ) if (( month . lt . 1 ) . and . ( month . gt . 12 )) then call disp ( \"Error: month should be between 1 and 12 (\" // to_string ( month ) // \").\" ) end if if (( day . lt . 1 ) . and . ( day . gt . 31 )) then call disp ( \"Error: day should be between 1 and 31 (\" // to_string ( day ) // \").\" ) end if if (( present ( hour )) . and . ( hour . lt . 0 ) . and . ( hour . gt . 23 )) then call disp ( \"Error: hour should be between 0 and 23 (\" // to_string ( hour ) // \").\" ) end if if (( present ( minute )) . and . ( minute . lt . 0 ) . and . ( minute . gt . 59 )) then call disp ( \"Error: minute should be between 0 and 59 (\" // to_string ( minute ) // \").\" ) end if if (( present ( second )) . and . ( second . lt . 0 ) . and . ( second . gt . 59 )) then call disp ( \"Error: second should be between 0 and 59 (\" // to_string ( second ) // \").\" ) end if if (( present ( microsecond )) . and . ( microsecond . lt . 0 ) . and . ( microsecond . ge . 1.0d+6 )) then call disp ( \"Error: microsecond should be between 0 and 999,999 (\" // to_string ( microsecond ) // \").\" ) end if days_per_month = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] datenum0 = 0 do i = 0 , year - 1 if ( is_leap ( i )) then datenum0 = datenum0 + 366 else datenum0 = datenum0 + 365 end if end do datenum0 = datenum0 + sum ( days_per_month (: month - 1 )) if ( is_leap ( year ) . and . ( month . gt . 2 )) datenum0 = datenum0 + 1 datenum0 = datenum0 + day if ( present ( hour )) datenum0 = datenum0 + real ( hour , kind = 8 ) / 2 4.0d0 if ( present ( minute )) datenum0 = datenum0 + real ( minute , kind = 8 ) / ( 2 4.0d0 * 6 0.0d0 ) if ( present ( second )) datenum0 = datenum0 + real ( second , kind = 8 ) / ( 2 4.0d0 * 6 0.0d0 * 6 0.0d0 ) if ( present ( microsecond )) datenum0 = datenum0 + real ( microsecond , kind = 8 ) / ( 2 4.0d0 * 6 0.0d0 * 6 0.0d0 * 1.0d+6 ) return end procedure datenum0 end submodule forlab_time_datenum","tags":"","loc":"sourcefile/forlab_time_datenum.f90.html"},{"title":"forlab_linalg_eye.f90 – FORLAB","text":"Contents Submodules forlab_linalg_eye Source Code forlab_linalg_eye.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_eye implicit none contains module procedure eye_sp integer :: i X = 0 do i = 1 , min ( size ( X , 1 ), size ( X , 2 )) X ( i , i ) = 1.0_sp end do return end procedure eye_sp module procedure eye_dp integer :: i X = 0 do i = 1 , min ( size ( X , 1 ), size ( X , 2 )) X ( i , i ) = 1.0_dp end do return end procedure eye_dp module procedure eye_qp integer :: i X = 0 do i = 1 , min ( size ( X , 1 ), size ( X , 2 )) X ( i , i ) = 1.0_qp end do return end procedure eye_qp end submodule forlab_linalg_eye","tags":"","loc":"sourcefile/forlab_linalg_eye.f90.html"},{"title":"forlab_time.f90 – FORLAB","text":"Contents Modules forlab_time Source Code forlab_time.f90 Source Code module forlab_time use forlab_io , only : disp use stdlib_kinds , only : sp , dp , qp , & int8 , int16 , int32 , int64 implicit none private public :: datenum , time_string public :: is_leap public :: tic , toc interface datenum real ( dp ) module function datenum0 ( year , month , day , hour , minute , & second , microsecond ) integer , intent ( in ) :: year , month , day integer , intent ( in ), optional :: hour , minute , second , microsecond end function datenum0 end interface datenum interface is_leap procedure :: is_leap_int8 procedure :: is_leap_int16 procedure :: is_leap_int32 procedure :: is_leap_int64 end interface is_leap interface module subroutine tic () end subroutine tic end interface interface toc module subroutine toc_default () end subroutine toc_default module subroutine toc_sp ( time ) real ( sp ), intent ( out ) :: time end subroutine toc_sp module subroutine toc_dp ( time ) real ( dp ), intent ( out ) :: time end subroutine toc_dp module subroutine toc_qp ( time ) real ( qp ), intent ( out ) :: time end subroutine toc_qp end interface toc contains logical function is_leap_int8 ( year ) result ( is_leap ) integer ( int8 ), intent ( in ) :: year if (( mod ( year , 400 ) == 0 ) . or . & (( mod ( year , 4 ) == 0 ) . and . ( mod ( year , 100 ) /= 0 ))) then is_leap = . true . else is_leap = . false . end if return end function is_leap_int8 logical function is_leap_int16 ( year ) result ( is_leap ) integer ( int16 ), intent ( in ) :: year if (( mod ( year , 400 ) == 0 ) . or . & (( mod ( year , 4 ) == 0 ) . and . ( mod ( year , 100 ) /= 0 ))) then is_leap = . true . else is_leap = . false . end if return end function is_leap_int16 logical function is_leap_int32 ( year ) result ( is_leap ) integer ( int32 ), intent ( in ) :: year if (( mod ( year , 400 ) == 0 ) . or . & (( mod ( year , 4 ) == 0 ) . and . ( mod ( year , 100 ) /= 0 ))) then is_leap = . true . else is_leap = . false . end if return end function is_leap_int32 logical function is_leap_int64 ( year ) result ( is_leap ) integer ( int64 ), intent ( in ) :: year if (( mod ( year , 400 ) == 0 ) . or . & (( mod ( year , 4 ) == 0 ) . and . ( mod ( year , 100 ) /= 0 ))) then is_leap = . true . else is_leap = . false . end if return end function is_leap_int64 character ( 19 ) function time_string () implicit none character ( 10 ) :: data , time call date_and_time ( data , time ) time_string = data ( 1 : 4 ) // '-' // data ( 5 : 6 ) // '-' // data ( 7 : 8 ) // ' ' // time ( 1 : 2 ) & // ':' // time ( 3 : 4 ) // ':' // time ( 5 : 6 ) end function time_string end module forlab_time","tags":"","loc":"sourcefile/forlab_time.f90.html"},{"title":"forlab_linalg_cat.f90 – FORLAB","text":"Contents Submodules forlab_linalg_cat Source Code forlab_linalg_cat.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_cat implicit none contains module procedure horzcat_r_1_sp integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), 2 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 ) = x2 end procedure horzcat_r_1_sp module procedure horzcat_r_2_sp integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n1 + n2 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 :) = A2 end procedure horzcat_r_2_sp module procedure horzcat_r_21_sp integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), n1 + 1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 ) = x2 return end procedure horzcat_r_21_sp module procedure horzcat_r_12_sp integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n2 + 1 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 :) = A2 end procedure horzcat_r_12_sp module procedure horzcat_r_1_dp integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), 2 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 ) = x2 end procedure horzcat_r_1_dp module procedure horzcat_r_2_dp integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n1 + n2 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 :) = A2 end procedure horzcat_r_2_dp module procedure horzcat_r_21_dp integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), n1 + 1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 ) = x2 return end procedure horzcat_r_21_dp module procedure horzcat_r_12_dp integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n2 + 1 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 :) = A2 end procedure horzcat_r_12_dp module procedure horzcat_r_1_qp integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), 2 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 ) = x2 end procedure horzcat_r_1_qp module procedure horzcat_r_2_qp integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n1 + n2 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 :) = A2 end procedure horzcat_r_2_qp module procedure horzcat_r_21_qp integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), n1 + 1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 ) = x2 return end procedure horzcat_r_21_qp module procedure horzcat_r_12_qp integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n2 + 1 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 :) = A2 end procedure horzcat_r_12_qp module procedure horzcat_c_1_sp integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), 2 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 ) = x2 end procedure horzcat_c_1_sp module procedure horzcat_c_2_sp integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n1 + n2 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 :) = A2 end procedure horzcat_c_2_sp module procedure horzcat_c_21_sp integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), n1 + 1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 ) = x2 return end procedure horzcat_c_21_sp module procedure horzcat_c_12_sp integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n2 + 1 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 :) = A2 end procedure horzcat_c_12_sp module procedure horzcat_c_1_dp integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), 2 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 ) = x2 end procedure horzcat_c_1_dp module procedure horzcat_c_2_dp integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n1 + n2 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 :) = A2 end procedure horzcat_c_2_dp module procedure horzcat_c_21_dp integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), n1 + 1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 ) = x2 return end procedure horzcat_c_21_dp module procedure horzcat_c_12_dp integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n2 + 1 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 :) = A2 end procedure horzcat_c_12_dp module procedure horzcat_c_1_qp integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), 2 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 ) = x2 end procedure horzcat_c_1_qp module procedure horzcat_c_2_qp integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n1 + n2 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 :) = A2 end procedure horzcat_c_2_qp module procedure horzcat_c_21_qp integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), n1 + 1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 ) = x2 return end procedure horzcat_c_21_qp module procedure horzcat_c_12_qp integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n2 + 1 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 :) = A2 end procedure horzcat_c_12_qp module procedure horzcat_i_1_int8 integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), 2 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 ) = x2 end procedure horzcat_i_1_int8 module procedure horzcat_i_2_int8 integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n1 + n2 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 :) = A2 end procedure horzcat_i_2_int8 module procedure horzcat_i_21_int8 integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), n1 + 1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 ) = x2 return end procedure horzcat_i_21_int8 module procedure horzcat_i_12_int8 integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n2 + 1 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 :) = A2 end procedure horzcat_i_12_int8 module procedure horzcat_i_1_int16 integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), 2 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 ) = x2 end procedure horzcat_i_1_int16 module procedure horzcat_i_2_int16 integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n1 + n2 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 :) = A2 end procedure horzcat_i_2_int16 module procedure horzcat_i_21_int16 integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), n1 + 1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 ) = x2 return end procedure horzcat_i_21_int16 module procedure horzcat_i_12_int16 integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n2 + 1 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 :) = A2 end procedure horzcat_i_12_int16 module procedure horzcat_i_1_int32 integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), 2 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 ) = x2 end procedure horzcat_i_1_int32 module procedure horzcat_i_2_int32 integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n1 + n2 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 :) = A2 end procedure horzcat_i_2_int32 module procedure horzcat_i_21_int32 integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), n1 + 1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 ) = x2 return end procedure horzcat_i_21_int32 module procedure horzcat_i_12_int32 integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n2 + 1 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 :) = A2 end procedure horzcat_i_12_int32 module procedure horzcat_i_1_int64 integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), 2 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 ) = x2 end procedure horzcat_i_1_int64 module procedure horzcat_i_2_int64 integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n1 + n2 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 :) = A2 end procedure horzcat_i_2_int64 module procedure horzcat_i_21_int64 integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( max ( m1 , m2 ), n1 + 1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( 1 : m2 , n1 + 1 ) = x2 return end procedure horzcat_i_21_int64 module procedure horzcat_i_12_int64 integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( max ( m1 , m2 ), n2 + 1 ) result ( 1 : m1 , 1 ) = x1 result ( 1 : m2 , 2 :) = A2 end procedure horzcat_i_12_int64 module procedure vertcat_r_1_sp integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , 1 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 end procedure vertcat_r_1_sp module procedure vertcat_r_2_sp integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , max ( n1 , n2 )) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_r_2_sp module procedure vertcat_r_21_sp integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , n1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 return end procedure vertcat_r_21_sp module procedure vertcat_r_12_sp integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , n2 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_r_12_sp module procedure vertcat_r_1_dp integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , 1 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 end procedure vertcat_r_1_dp module procedure vertcat_r_2_dp integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , max ( n1 , n2 )) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_r_2_dp module procedure vertcat_r_21_dp integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , n1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 return end procedure vertcat_r_21_dp module procedure vertcat_r_12_dp integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , n2 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_r_12_dp module procedure vertcat_r_1_qp integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , 1 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 end procedure vertcat_r_1_qp module procedure vertcat_r_2_qp integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , max ( n1 , n2 )) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_r_2_qp module procedure vertcat_r_21_qp integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , n1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 return end procedure vertcat_r_21_qp module procedure vertcat_r_12_qp integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , n2 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_r_12_qp module procedure vertcat_c_1_sp integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , 1 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 end procedure vertcat_c_1_sp module procedure vertcat_c_2_sp integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , max ( n1 , n2 )) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_c_2_sp module procedure vertcat_c_21_sp integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , n1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 return end procedure vertcat_c_21_sp module procedure vertcat_c_12_sp integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , n2 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_c_12_sp module procedure vertcat_c_1_dp integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , 1 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 end procedure vertcat_c_1_dp module procedure vertcat_c_2_dp integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , max ( n1 , n2 )) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_c_2_dp module procedure vertcat_c_21_dp integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , n1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 return end procedure vertcat_c_21_dp module procedure vertcat_c_12_dp integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , n2 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_c_12_dp module procedure vertcat_c_1_qp integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , 1 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 end procedure vertcat_c_1_qp module procedure vertcat_c_2_qp integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , max ( n1 , n2 )) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_c_2_qp module procedure vertcat_c_21_qp integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , n1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 return end procedure vertcat_c_21_qp module procedure vertcat_c_12_qp integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , n2 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_c_12_qp module procedure vertcat_i_1_int8 integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , 1 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 end procedure vertcat_i_1_int8 module procedure vertcat_i_2_int8 integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , max ( n1 , n2 )) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_i_2_int8 module procedure vertcat_i_21_int8 integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , n1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 return end procedure vertcat_i_21_int8 module procedure vertcat_i_12_int8 integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , n2 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_i_12_int8 module procedure vertcat_i_1_int16 integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , 1 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 end procedure vertcat_i_1_int16 module procedure vertcat_i_2_int16 integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , max ( n1 , n2 )) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_i_2_int16 module procedure vertcat_i_21_int16 integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , n1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 return end procedure vertcat_i_21_int16 module procedure vertcat_i_12_int16 integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , n2 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_i_12_int16 module procedure vertcat_i_1_int32 integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , 1 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 end procedure vertcat_i_1_int32 module procedure vertcat_i_2_int32 integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , max ( n1 , n2 )) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_i_2_int32 module procedure vertcat_i_21_int32 integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , n1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 return end procedure vertcat_i_21_int32 module procedure vertcat_i_12_int32 integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , n2 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_i_12_int32 module procedure vertcat_i_1_int64 integer :: m1 , m2 m1 = size ( x1 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , 1 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 end procedure vertcat_i_1_int64 module procedure vertcat_i_2_int64 integer :: m1 , n1 , m2 , n2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , max ( n1 , n2 )) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_i_2_int64 module procedure vertcat_i_21_int64 integer :: m1 , n1 , m2 m1 = size ( A1 , 1 ) n1 = size ( A1 , 2 ) m2 = size ( x2 ) result = zeros ( m1 + m2 , n1 ) result ( 1 : m1 , 1 : n1 ) = A1 result ( m1 + 1 : m1 + m2 , 1 ) = x2 return end procedure vertcat_i_21_int64 module procedure vertcat_i_12_int64 integer :: m1 , m2 , n2 m1 = size ( x1 ) m2 = size ( A2 , 1 ) n2 = size ( A2 , 2 ) result = zeros ( m1 + m2 , n2 ) result ( 1 : m1 , 1 ) = x1 result ( m1 + 1 : m1 + m2 , 1 : n2 ) = A2 end procedure vertcat_i_12_int64 end submodule forlab_linalg_cat","tags":"","loc":"sourcefile/forlab_linalg_cat.f90.html"},{"title":"forlab_linalg.f90 – FORLAB","text":"Contents Modules forlab_linalg Source Code forlab_linalg.f90 Source Code module forlab_linalg use stdlib_error , only : error_stop use stdlib_kinds , only : sp , dp , qp , & int8 , int16 , int32 , int64 use forlab_sorting , only : argsort use stdlib_optval , only : optval implicit none private public :: is_square , is_symmetric public :: zeros , ones , linspace , logspace , seq public :: eye public :: horzcat , vertcat public :: diag , det , lu , matpow , qr , svd , trace , tril , triu , chol , norm , & diff public :: operator (. i .), operator (. x .), inv , outer , solve , svdsolve interface chol !! chol computes Cholesky's decomposition of a symmetric positive !! definite matrix. module function chol_sp ( A ) result ( L ) real ( sp ), dimension (:, :), intent ( in ) :: A real ( sp ), dimension (:, :), allocatable :: L end function module function chol_dp ( A ) result ( L ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:, :), allocatable :: L end function module function chol_qp ( A ) result ( L ) real ( qp ), dimension (:, :), intent ( in ) :: A real ( qp ), dimension (:, :), allocatable :: L end function !#:for k1,t1 in CMPLX_KINDS_TYPES !    module function chol_cqp (A) result(L) !        real(qp), dimension(:, :), intent(in) :: A !        real(qp), dimension(:, :), allocatable :: L !    end function !#:endfor end interface chol interface det !! det computes the matrix determinant. module function det_sp ( A , outL , outU ) result ( det ) real ( sp ), dimension (:, :), intent ( in ) :: A real ( sp ), dimension (:, :), allocatable , intent ( inout ), optional :: outL , outU real ( sp ) :: det end function det_sp module function det_dp ( A , outL , outU ) result ( det ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:, :), allocatable , intent ( inout ), optional :: outL , outU real ( dp ) :: det end function det_dp module function det_qp ( A , outL , outU ) result ( det ) real ( qp ), dimension (:, :), intent ( in ) :: A real ( qp ), dimension (:, :), allocatable , intent ( inout ), optional :: outL , outU real ( qp ) :: det end function det_qp end interface det interface diag !! diag creates diagonal matrix or get the diagonal of a matrix. module function diag1_sp ( A ) result ( diag ) real ( sp ), dimension (:, :), intent ( in ) :: A real ( sp ), dimension (:), allocatable :: diag end function diag1_sp module function diag2_sp ( x ) result ( diag ) real ( sp ), dimension (:), intent ( in ) :: x real ( sp ), dimension (:, :), allocatable :: diag end function diag2_sp module function diag1_dp ( A ) result ( diag ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), allocatable :: diag end function diag1_dp module function diag2_dp ( x ) result ( diag ) real ( dp ), dimension (:), intent ( in ) :: x real ( dp ), dimension (:, :), allocatable :: diag end function diag2_dp module function diag1_qp ( A ) result ( diag ) real ( qp ), dimension (:, :), intent ( in ) :: A real ( qp ), dimension (:), allocatable :: diag end function diag1_qp module function diag2_qp ( x ) result ( diag ) real ( qp ), dimension (:), intent ( in ) :: x real ( qp ), dimension (:, :), allocatable :: diag end function diag2_qp end interface diag !> Version: Experimental !> !> `diff` computes differences of arrays. !> ([Specification](../page/specs/forlab_linalg.html)) interface diff pure module function diff_1_sp ( x , n ) result ( result ) real ( sp ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n real ( sp ), dimension (:), allocatable :: result end function diff_1_sp pure module function diff_2_sp ( A , n , dim ) result ( result ) real ( sp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim real ( sp ), dimension (:, :), allocatable :: result end function diff_2_sp pure module function diff_1_dp ( x , n ) result ( result ) real ( dp ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n real ( dp ), dimension (:), allocatable :: result end function diff_1_dp pure module function diff_2_dp ( A , n , dim ) result ( result ) real ( dp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim real ( dp ), dimension (:, :), allocatable :: result end function diff_2_dp pure module function diff_1_qp ( x , n ) result ( result ) real ( qp ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n real ( qp ), dimension (:), allocatable :: result end function diff_1_qp pure module function diff_2_qp ( A , n , dim ) result ( result ) real ( qp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim real ( qp ), dimension (:, :), allocatable :: result end function diff_2_qp pure module function diff_1_int8 ( x , n ) result ( result ) integer ( int8 ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n integer ( int8 ), dimension (:), allocatable :: result end function diff_1_int8 pure module function diff_2_int8 ( A , n , dim ) result ( result ) integer ( int8 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim integer ( int8 ), dimension (:, :), allocatable :: result end function diff_2_int8 pure module function diff_1_int16 ( x , n ) result ( result ) integer ( int16 ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n integer ( int16 ), dimension (:), allocatable :: result end function diff_1_int16 pure module function diff_2_int16 ( A , n , dim ) result ( result ) integer ( int16 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim integer ( int16 ), dimension (:, :), allocatable :: result end function diff_2_int16 pure module function diff_1_int32 ( x , n ) result ( result ) integer ( int32 ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n integer ( int32 ), dimension (:), allocatable :: result end function diff_1_int32 pure module function diff_2_int32 ( A , n , dim ) result ( result ) integer ( int32 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim integer ( int32 ), dimension (:, :), allocatable :: result end function diff_2_int32 pure module function diff_1_int64 ( x , n ) result ( result ) integer ( int64 ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: n integer ( int64 ), dimension (:), allocatable :: result end function diff_1_int64 pure module function diff_2_int64 ( A , n , dim ) result ( result ) integer ( int64 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: n , dim integer ( int64 ), dimension (:, :), allocatable :: result end function diff_2_int64 end interface diff interface eig !! eig computes eigenvalues and eigenvectors of symmetric matrix using Jacobi algorithm. module subroutine eig_sp ( A , V , d , itermax ) real ( sp ), dimension (:, :), intent ( in ) :: A real ( sp ), dimension (:, :), allocatable , intent ( out ) :: V real ( sp ), dimension (:), allocatable , intent ( out ) :: d integer , intent ( in ), optional :: itermax end subroutine eig_sp module subroutine eig_dp ( A , V , d , itermax ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:, :), allocatable , intent ( out ) :: V real ( dp ), dimension (:), allocatable , intent ( out ) :: d integer , intent ( in ), optional :: itermax end subroutine eig_dp module subroutine eig_qp ( A , V , d , itermax ) real ( qp ), dimension (:, :), intent ( in ) :: A real ( qp ), dimension (:, :), allocatable , intent ( out ) :: V real ( qp ), dimension (:), allocatable , intent ( out ) :: d integer , intent ( in ), optional :: itermax end subroutine eig_qp end interface eig interface eye module subroutine eye_sp ( X ) real ( sp ), intent ( out ) :: X (:, :) end subroutine eye_sp module subroutine eye_dp ( X ) real ( dp ), intent ( out ) :: X (:, :) end subroutine eye_dp module subroutine eye_qp ( X ) real ( qp ), intent ( out ) :: X (:, :) end subroutine eye_qp end interface eye interface horzcat module function horzcat_r_1_sp ( x1 , x2 ) result ( result ) real ( sp ), dimension (:, :), allocatable :: result real ( sp ), dimension (:), intent ( in ) :: x1 , x2 end function horzcat_r_1_sp module function horzcat_r_2_sp ( A1 , A2 ) result ( result ) real ( sp ), dimension (:, :), allocatable :: result real ( sp ), dimension (:, :), intent ( in ) :: A1 , A2 end function horzcat_r_2_sp module function horzcat_r_21_sp ( A1 , x2 ) result ( result ) real ( sp ), dimension (:, :), allocatable :: result real ( sp ), dimension (:, :), intent ( in ) :: A1 real ( sp ), dimension (:), intent ( in ) :: x2 end function horzcat_r_21_sp module function horzcat_r_12_sp ( x1 , A2 ) result ( result ) real ( sp ), dimension (:, :), allocatable :: result real ( sp ), dimension (:), intent ( in ) :: x1 real ( sp ), dimension (:, :), intent ( in ) :: A2 end function horzcat_r_12_sp module function horzcat_r_1_dp ( x1 , x2 ) result ( result ) real ( dp ), dimension (:, :), allocatable :: result real ( dp ), dimension (:), intent ( in ) :: x1 , x2 end function horzcat_r_1_dp module function horzcat_r_2_dp ( A1 , A2 ) result ( result ) real ( dp ), dimension (:, :), allocatable :: result real ( dp ), dimension (:, :), intent ( in ) :: A1 , A2 end function horzcat_r_2_dp module function horzcat_r_21_dp ( A1 , x2 ) result ( result ) real ( dp ), dimension (:, :), allocatable :: result real ( dp ), dimension (:, :), intent ( in ) :: A1 real ( dp ), dimension (:), intent ( in ) :: x2 end function horzcat_r_21_dp module function horzcat_r_12_dp ( x1 , A2 ) result ( result ) real ( dp ), dimension (:, :), allocatable :: result real ( dp ), dimension (:), intent ( in ) :: x1 real ( dp ), dimension (:, :), intent ( in ) :: A2 end function horzcat_r_12_dp module function horzcat_r_1_qp ( x1 , x2 ) result ( result ) real ( qp ), dimension (:, :), allocatable :: result real ( qp ), dimension (:), intent ( in ) :: x1 , x2 end function horzcat_r_1_qp module function horzcat_r_2_qp ( A1 , A2 ) result ( result ) real ( qp ), dimension (:, :), allocatable :: result real ( qp ), dimension (:, :), intent ( in ) :: A1 , A2 end function horzcat_r_2_qp module function horzcat_r_21_qp ( A1 , x2 ) result ( result ) real ( qp ), dimension (:, :), allocatable :: result real ( qp ), dimension (:, :), intent ( in ) :: A1 real ( qp ), dimension (:), intent ( in ) :: x2 end function horzcat_r_21_qp module function horzcat_r_12_qp ( x1 , A2 ) result ( result ) real ( qp ), dimension (:, :), allocatable :: result real ( qp ), dimension (:), intent ( in ) :: x1 real ( qp ), dimension (:, :), intent ( in ) :: A2 end function horzcat_r_12_qp module function horzcat_c_1_sp ( x1 , x2 ) result ( result ) complex ( sp ), dimension (:, :), allocatable :: result complex ( sp ), dimension (:), intent ( in ) :: x1 , x2 end function horzcat_c_1_sp module function horzcat_c_2_sp ( A1 , A2 ) result ( result ) complex ( sp ), dimension (:, :), allocatable :: result complex ( sp ), dimension (:, :), intent ( in ) :: A1 , A2 end function horzcat_c_2_sp module function horzcat_c_21_sp ( A1 , x2 ) result ( result ) complex ( sp ), dimension (:, :), allocatable :: result complex ( sp ), dimension (:, :), intent ( in ) :: A1 complex ( sp ), dimension (:), intent ( in ) :: x2 end function horzcat_c_21_sp module function horzcat_c_12_sp ( x1 , A2 ) result ( result ) complex ( sp ), dimension (:, :), allocatable :: result complex ( sp ), dimension (:), intent ( in ) :: x1 complex ( sp ), dimension (:, :), intent ( in ) :: A2 end function horzcat_c_12_sp module function horzcat_c_1_dp ( x1 , x2 ) result ( result ) complex ( dp ), dimension (:, :), allocatable :: result complex ( dp ), dimension (:), intent ( in ) :: x1 , x2 end function horzcat_c_1_dp module function horzcat_c_2_dp ( A1 , A2 ) result ( result ) complex ( dp ), dimension (:, :), allocatable :: result complex ( dp ), dimension (:, :), intent ( in ) :: A1 , A2 end function horzcat_c_2_dp module function horzcat_c_21_dp ( A1 , x2 ) result ( result ) complex ( dp ), dimension (:, :), allocatable :: result complex ( dp ), dimension (:, :), intent ( in ) :: A1 complex ( dp ), dimension (:), intent ( in ) :: x2 end function horzcat_c_21_dp module function horzcat_c_12_dp ( x1 , A2 ) result ( result ) complex ( dp ), dimension (:, :), allocatable :: result complex ( dp ), dimension (:), intent ( in ) :: x1 complex ( dp ), dimension (:, :), intent ( in ) :: A2 end function horzcat_c_12_dp module function horzcat_c_1_qp ( x1 , x2 ) result ( result ) complex ( qp ), dimension (:, :), allocatable :: result complex ( qp ), dimension (:), intent ( in ) :: x1 , x2 end function horzcat_c_1_qp module function horzcat_c_2_qp ( A1 , A2 ) result ( result ) complex ( qp ), dimension (:, :), allocatable :: result complex ( qp ), dimension (:, :), intent ( in ) :: A1 , A2 end function horzcat_c_2_qp module function horzcat_c_21_qp ( A1 , x2 ) result ( result ) complex ( qp ), dimension (:, :), allocatable :: result complex ( qp ), dimension (:, :), intent ( in ) :: A1 complex ( qp ), dimension (:), intent ( in ) :: x2 end function horzcat_c_21_qp module function horzcat_c_12_qp ( x1 , A2 ) result ( result ) complex ( qp ), dimension (:, :), allocatable :: result complex ( qp ), dimension (:), intent ( in ) :: x1 complex ( qp ), dimension (:, :), intent ( in ) :: A2 end function horzcat_c_12_qp module function horzcat_i_1_int8 ( x1 , x2 ) result ( result ) integer ( int8 ), dimension (:, :), allocatable :: result integer ( int8 ), dimension (:), intent ( in ) :: x1 , x2 end function horzcat_i_1_int8 module function horzcat_i_2_int8 ( A1 , A2 ) result ( result ) integer ( int8 ), dimension (:, :), allocatable :: result integer ( int8 ), dimension (:, :), intent ( in ) :: A1 , A2 end function horzcat_i_2_int8 module function horzcat_i_21_int8 ( A1 , x2 ) result ( result ) integer ( int8 ), dimension (:, :), allocatable :: result integer ( int8 ), dimension (:, :), intent ( in ) :: A1 integer ( int8 ), dimension (:), intent ( in ) :: x2 end function horzcat_i_21_int8 module function horzcat_i_12_int8 ( x1 , A2 ) result ( result ) integer ( int8 ), dimension (:, :), allocatable :: result integer ( int8 ), dimension (:), intent ( in ) :: x1 integer ( int8 ), dimension (:, :), intent ( in ) :: A2 end function horzcat_i_12_int8 module function horzcat_i_1_int16 ( x1 , x2 ) result ( result ) integer ( int16 ), dimension (:, :), allocatable :: result integer ( int16 ), dimension (:), intent ( in ) :: x1 , x2 end function horzcat_i_1_int16 module function horzcat_i_2_int16 ( A1 , A2 ) result ( result ) integer ( int16 ), dimension (:, :), allocatable :: result integer ( int16 ), dimension (:, :), intent ( in ) :: A1 , A2 end function horzcat_i_2_int16 module function horzcat_i_21_int16 ( A1 , x2 ) result ( result ) integer ( int16 ), dimension (:, :), allocatable :: result integer ( int16 ), dimension (:, :), intent ( in ) :: A1 integer ( int16 ), dimension (:), intent ( in ) :: x2 end function horzcat_i_21_int16 module function horzcat_i_12_int16 ( x1 , A2 ) result ( result ) integer ( int16 ), dimension (:, :), allocatable :: result integer ( int16 ), dimension (:), intent ( in ) :: x1 integer ( int16 ), dimension (:, :), intent ( in ) :: A2 end function horzcat_i_12_int16 module function horzcat_i_1_int32 ( x1 , x2 ) result ( result ) integer ( int32 ), dimension (:, :), allocatable :: result integer ( int32 ), dimension (:), intent ( in ) :: x1 , x2 end function horzcat_i_1_int32 module function horzcat_i_2_int32 ( A1 , A2 ) result ( result ) integer ( int32 ), dimension (:, :), allocatable :: result integer ( int32 ), dimension (:, :), intent ( in ) :: A1 , A2 end function horzcat_i_2_int32 module function horzcat_i_21_int32 ( A1 , x2 ) result ( result ) integer ( int32 ), dimension (:, :), allocatable :: result integer ( int32 ), dimension (:, :), intent ( in ) :: A1 integer ( int32 ), dimension (:), intent ( in ) :: x2 end function horzcat_i_21_int32 module function horzcat_i_12_int32 ( x1 , A2 ) result ( result ) integer ( int32 ), dimension (:, :), allocatable :: result integer ( int32 ), dimension (:), intent ( in ) :: x1 integer ( int32 ), dimension (:, :), intent ( in ) :: A2 end function horzcat_i_12_int32 module function horzcat_i_1_int64 ( x1 , x2 ) result ( result ) integer ( int64 ), dimension (:, :), allocatable :: result integer ( int64 ), dimension (:), intent ( in ) :: x1 , x2 end function horzcat_i_1_int64 module function horzcat_i_2_int64 ( A1 , A2 ) result ( result ) integer ( int64 ), dimension (:, :), allocatable :: result integer ( int64 ), dimension (:, :), intent ( in ) :: A1 , A2 end function horzcat_i_2_int64 module function horzcat_i_21_int64 ( A1 , x2 ) result ( result ) integer ( int64 ), dimension (:, :), allocatable :: result integer ( int64 ), dimension (:, :), intent ( in ) :: A1 integer ( int64 ), dimension (:), intent ( in ) :: x2 end function horzcat_i_21_int64 module function horzcat_i_12_int64 ( x1 , A2 ) result ( result ) integer ( int64 ), dimension (:, :), allocatable :: result integer ( int64 ), dimension (:), intent ( in ) :: x1 integer ( int64 ), dimension (:, :), intent ( in ) :: A2 end function horzcat_i_12_int64 end interface horzcat interface vertcat module function vertcat_r_1_sp ( x1 , x2 ) result ( result ) real ( sp ), dimension (:, :), allocatable :: result real ( sp ), dimension (:), intent ( in ) :: x1 , x2 end function vertcat_r_1_sp module function vertcat_r_2_sp ( A1 , A2 ) result ( result ) real ( sp ), dimension (:, :), allocatable :: result real ( sp ), dimension (:, :), intent ( in ) :: A1 , A2 end function vertcat_r_2_sp module function vertcat_r_21_sp ( A1 , x2 ) result ( result ) real ( sp ), dimension (:, :), allocatable :: result real ( sp ), dimension (:, :), intent ( in ) :: A1 real ( sp ), dimension (:), intent ( in ) :: x2 end function vertcat_r_21_sp module function vertcat_r_12_sp ( x1 , A2 ) result ( result ) real ( sp ), dimension (:, :), allocatable :: result real ( sp ), dimension (:), intent ( in ) :: x1 real ( sp ), dimension (:, :), intent ( in ) :: A2 end function vertcat_r_12_sp module function vertcat_r_1_dp ( x1 , x2 ) result ( result ) real ( dp ), dimension (:, :), allocatable :: result real ( dp ), dimension (:), intent ( in ) :: x1 , x2 end function vertcat_r_1_dp module function vertcat_r_2_dp ( A1 , A2 ) result ( result ) real ( dp ), dimension (:, :), allocatable :: result real ( dp ), dimension (:, :), intent ( in ) :: A1 , A2 end function vertcat_r_2_dp module function vertcat_r_21_dp ( A1 , x2 ) result ( result ) real ( dp ), dimension (:, :), allocatable :: result real ( dp ), dimension (:, :), intent ( in ) :: A1 real ( dp ), dimension (:), intent ( in ) :: x2 end function vertcat_r_21_dp module function vertcat_r_12_dp ( x1 , A2 ) result ( result ) real ( dp ), dimension (:, :), allocatable :: result real ( dp ), dimension (:), intent ( in ) :: x1 real ( dp ), dimension (:, :), intent ( in ) :: A2 end function vertcat_r_12_dp module function vertcat_r_1_qp ( x1 , x2 ) result ( result ) real ( qp ), dimension (:, :), allocatable :: result real ( qp ), dimension (:), intent ( in ) :: x1 , x2 end function vertcat_r_1_qp module function vertcat_r_2_qp ( A1 , A2 ) result ( result ) real ( qp ), dimension (:, :), allocatable :: result real ( qp ), dimension (:, :), intent ( in ) :: A1 , A2 end function vertcat_r_2_qp module function vertcat_r_21_qp ( A1 , x2 ) result ( result ) real ( qp ), dimension (:, :), allocatable :: result real ( qp ), dimension (:, :), intent ( in ) :: A1 real ( qp ), dimension (:), intent ( in ) :: x2 end function vertcat_r_21_qp module function vertcat_r_12_qp ( x1 , A2 ) result ( result ) real ( qp ), dimension (:, :), allocatable :: result real ( qp ), dimension (:), intent ( in ) :: x1 real ( qp ), dimension (:, :), intent ( in ) :: A2 end function vertcat_r_12_qp module function vertcat_c_1_sp ( x1 , x2 ) result ( result ) complex ( sp ), dimension (:, :), allocatable :: result complex ( sp ), dimension (:), intent ( in ) :: x1 , x2 end function vertcat_c_1_sp module function vertcat_c_2_sp ( A1 , A2 ) result ( result ) complex ( sp ), dimension (:, :), allocatable :: result complex ( sp ), dimension (:, :), intent ( in ) :: A1 , A2 end function vertcat_c_2_sp module function vertcat_c_21_sp ( A1 , x2 ) result ( result ) complex ( sp ), dimension (:, :), allocatable :: result complex ( sp ), dimension (:, :), intent ( in ) :: A1 complex ( sp ), dimension (:), intent ( in ) :: x2 end function vertcat_c_21_sp module function vertcat_c_12_sp ( x1 , A2 ) result ( result ) complex ( sp ), dimension (:, :), allocatable :: result complex ( sp ), dimension (:), intent ( in ) :: x1 complex ( sp ), dimension (:, :), intent ( in ) :: A2 end function vertcat_c_12_sp module function vertcat_c_1_dp ( x1 , x2 ) result ( result ) complex ( dp ), dimension (:, :), allocatable :: result complex ( dp ), dimension (:), intent ( in ) :: x1 , x2 end function vertcat_c_1_dp module function vertcat_c_2_dp ( A1 , A2 ) result ( result ) complex ( dp ), dimension (:, :), allocatable :: result complex ( dp ), dimension (:, :), intent ( in ) :: A1 , A2 end function vertcat_c_2_dp module function vertcat_c_21_dp ( A1 , x2 ) result ( result ) complex ( dp ), dimension (:, :), allocatable :: result complex ( dp ), dimension (:, :), intent ( in ) :: A1 complex ( dp ), dimension (:), intent ( in ) :: x2 end function vertcat_c_21_dp module function vertcat_c_12_dp ( x1 , A2 ) result ( result ) complex ( dp ), dimension (:, :), allocatable :: result complex ( dp ), dimension (:), intent ( in ) :: x1 complex ( dp ), dimension (:, :), intent ( in ) :: A2 end function vertcat_c_12_dp module function vertcat_c_1_qp ( x1 , x2 ) result ( result ) complex ( qp ), dimension (:, :), allocatable :: result complex ( qp ), dimension (:), intent ( in ) :: x1 , x2 end function vertcat_c_1_qp module function vertcat_c_2_qp ( A1 , A2 ) result ( result ) complex ( qp ), dimension (:, :), allocatable :: result complex ( qp ), dimension (:, :), intent ( in ) :: A1 , A2 end function vertcat_c_2_qp module function vertcat_c_21_qp ( A1 , x2 ) result ( result ) complex ( qp ), dimension (:, :), allocatable :: result complex ( qp ), dimension (:, :), intent ( in ) :: A1 complex ( qp ), dimension (:), intent ( in ) :: x2 end function vertcat_c_21_qp module function vertcat_c_12_qp ( x1 , A2 ) result ( result ) complex ( qp ), dimension (:, :), allocatable :: result complex ( qp ), dimension (:), intent ( in ) :: x1 complex ( qp ), dimension (:, :), intent ( in ) :: A2 end function vertcat_c_12_qp module function vertcat_i_1_int8 ( x1 , x2 ) result ( result ) integer ( int8 ), dimension (:, :), allocatable :: result integer ( int8 ), dimension (:), intent ( in ) :: x1 , x2 end function vertcat_i_1_int8 module function vertcat_i_2_int8 ( A1 , A2 ) result ( result ) integer ( int8 ), dimension (:, :), allocatable :: result integer ( int8 ), dimension (:, :), intent ( in ) :: A1 , A2 end function vertcat_i_2_int8 module function vertcat_i_21_int8 ( A1 , x2 ) result ( result ) integer ( int8 ), dimension (:, :), allocatable :: result integer ( int8 ), dimension (:, :), intent ( in ) :: A1 integer ( int8 ), dimension (:), intent ( in ) :: x2 end function vertcat_i_21_int8 module function vertcat_i_12_int8 ( x1 , A2 ) result ( result ) integer ( int8 ), dimension (:, :), allocatable :: result integer ( int8 ), dimension (:), intent ( in ) :: x1 integer ( int8 ), dimension (:, :), intent ( in ) :: A2 end function vertcat_i_12_int8 module function vertcat_i_1_int16 ( x1 , x2 ) result ( result ) integer ( int16 ), dimension (:, :), allocatable :: result integer ( int16 ), dimension (:), intent ( in ) :: x1 , x2 end function vertcat_i_1_int16 module function vertcat_i_2_int16 ( A1 , A2 ) result ( result ) integer ( int16 ), dimension (:, :), allocatable :: result integer ( int16 ), dimension (:, :), intent ( in ) :: A1 , A2 end function vertcat_i_2_int16 module function vertcat_i_21_int16 ( A1 , x2 ) result ( result ) integer ( int16 ), dimension (:, :), allocatable :: result integer ( int16 ), dimension (:, :), intent ( in ) :: A1 integer ( int16 ), dimension (:), intent ( in ) :: x2 end function vertcat_i_21_int16 module function vertcat_i_12_int16 ( x1 , A2 ) result ( result ) integer ( int16 ), dimension (:, :), allocatable :: result integer ( int16 ), dimension (:), intent ( in ) :: x1 integer ( int16 ), dimension (:, :), intent ( in ) :: A2 end function vertcat_i_12_int16 module function vertcat_i_1_int32 ( x1 , x2 ) result ( result ) integer ( int32 ), dimension (:, :), allocatable :: result integer ( int32 ), dimension (:), intent ( in ) :: x1 , x2 end function vertcat_i_1_int32 module function vertcat_i_2_int32 ( A1 , A2 ) result ( result ) integer ( int32 ), dimension (:, :), allocatable :: result integer ( int32 ), dimension (:, :), intent ( in ) :: A1 , A2 end function vertcat_i_2_int32 module function vertcat_i_21_int32 ( A1 , x2 ) result ( result ) integer ( int32 ), dimension (:, :), allocatable :: result integer ( int32 ), dimension (:, :), intent ( in ) :: A1 integer ( int32 ), dimension (:), intent ( in ) :: x2 end function vertcat_i_21_int32 module function vertcat_i_12_int32 ( x1 , A2 ) result ( result ) integer ( int32 ), dimension (:, :), allocatable :: result integer ( int32 ), dimension (:), intent ( in ) :: x1 integer ( int32 ), dimension (:, :), intent ( in ) :: A2 end function vertcat_i_12_int32 module function vertcat_i_1_int64 ( x1 , x2 ) result ( result ) integer ( int64 ), dimension (:, :), allocatable :: result integer ( int64 ), dimension (:), intent ( in ) :: x1 , x2 end function vertcat_i_1_int64 module function vertcat_i_2_int64 ( A1 , A2 ) result ( result ) integer ( int64 ), dimension (:, :), allocatable :: result integer ( int64 ), dimension (:, :), intent ( in ) :: A1 , A2 end function vertcat_i_2_int64 module function vertcat_i_21_int64 ( A1 , x2 ) result ( result ) integer ( int64 ), dimension (:, :), allocatable :: result integer ( int64 ), dimension (:, :), intent ( in ) :: A1 integer ( int64 ), dimension (:), intent ( in ) :: x2 end function vertcat_i_21_int64 module function vertcat_i_12_int64 ( x1 , A2 ) result ( result ) integer ( int64 ), dimension (:, :), allocatable :: result integer ( int64 ), dimension (:), intent ( in ) :: x1 integer ( int64 ), dimension (:, :), intent ( in ) :: A2 end function vertcat_i_12_int64 end interface vertcat interface inv module function inv_rsp ( A ) result ( inv ) real ( sp ), dimension (:, :), intent ( in ) :: A real ( sp ), dimension (:, :), allocatable :: inv end function inv_rsp module function inv_rdp ( A ) result ( inv ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:, :), allocatable :: inv end function inv_rdp module function inv_rqp ( A ) result ( inv ) real ( qp ), dimension (:, :), intent ( in ) :: A real ( qp ), dimension (:, :), allocatable :: inv end function inv_rqp module function inv_csp ( A ) result ( inv ) complex ( sp ), dimension (:, :), intent ( in ) :: A complex ( sp ), dimension (:, :), allocatable :: inv end function inv_csp module function inv_cdp ( A ) result ( inv ) complex ( dp ), dimension (:, :), intent ( in ) :: A complex ( dp ), dimension (:, :), allocatable :: inv end function inv_cdp module function inv_cqp ( A ) result ( inv ) complex ( qp ), dimension (:, :), intent ( in ) :: A complex ( qp ), dimension (:, :), allocatable :: inv end function inv_cqp end interface inv interface is_square procedure :: is_square_rsp procedure :: is_square_rdp procedure :: is_square_rqp procedure :: is_square_csp procedure :: is_square_cdp procedure :: is_square_cqp end interface is_square interface is_symmetric procedure :: is_symmetric_rsp procedure :: is_symmetric_rdp procedure :: is_symmetric_rqp procedure :: is_symmetric_csp procedure :: is_symmetric_cdp procedure :: is_symmetric_cqp end interface is_symmetric interface linspace pure module subroutine linspace_sp ( X , from , to ) real ( sp ), intent ( out ) :: X (:) real ( sp ), intent ( in ) :: from , to end subroutine linspace_sp pure module subroutine linspace_dp ( X , from , to ) real ( dp ), intent ( out ) :: X (:) real ( dp ), intent ( in ) :: from , to end subroutine linspace_dp pure module subroutine linspace_qp ( X , from , to ) real ( qp ), intent ( out ) :: X (:) real ( qp ), intent ( in ) :: from , to end subroutine linspace_qp end interface linspace interface logspace pure module subroutine logspace_sp ( X , from , to ) real ( sp ), intent ( out ) :: X (:) real ( sp ), intent ( in ) :: from , to end subroutine logspace_sp pure module subroutine logspace_dp ( X , from , to ) real ( dp ), intent ( out ) :: X (:) real ( dp ), intent ( in ) :: from , to end subroutine logspace_dp pure module subroutine logspace_qp ( X , from , to ) real ( qp ), intent ( out ) :: X (:) real ( qp ), intent ( in ) :: from , to end subroutine logspace_qp end interface logspace interface lu !! lu computes the LU matrix factorization. module subroutine lu_sp ( A , L , U ) real ( sp ), dimension (:, :), intent ( in ) :: A real ( sp ), dimension (:, :), allocatable , intent ( out ) :: L , U end subroutine lu_sp module subroutine lu_dp ( A , L , U ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:, :), allocatable , intent ( out ) :: L , U end subroutine lu_dp module subroutine lu_qp ( A , L , U ) real ( qp ), dimension (:, :), intent ( in ) :: A real ( qp ), dimension (:, :), allocatable , intent ( out ) :: L , U end subroutine lu_qp end interface lu interface matpow !! Calculat matrix power module function matpow_sp ( a , num ) result ( c ) real ( sp ), dimension (:,:), intent ( in ) :: a real ( sp ), allocatable :: c (:,:) integer :: num end function matpow_sp module function matpow_dp ( a , num ) result ( c ) real ( dp ), dimension (:,:), intent ( in ) :: a real ( dp ), allocatable :: c (:,:) integer :: num end function matpow_dp module function matpow_qp ( a , num ) result ( c ) real ( qp ), dimension (:,:), intent ( in ) :: a real ( qp ), allocatable :: c (:,:) integer :: num end function matpow_qp end interface matpow interface norm !! norm computes vector and matrix norms. module function norm1_sp ( x , p ) result ( norm1 ) real ( sp ), dimension (:), intent ( in ) :: x real ( sp ), intent ( in ), optional :: p real ( sp ) :: norm1 end function norm1_sp module function norm2_sp ( A , p ) result ( norm2 ) real ( sp ), dimension (:,:), intent ( in ) :: A real ( sp ), intent ( in ), optional :: p real ( sp ) :: norm2 end function norm2_sp module function norm1_dp ( x , p ) result ( norm1 ) real ( dp ), dimension (:), intent ( in ) :: x real ( dp ), intent ( in ), optional :: p real ( dp ) :: norm1 end function norm1_dp module function norm2_dp ( A , p ) result ( norm2 ) real ( dp ), dimension (:,:), intent ( in ) :: A real ( dp ), intent ( in ), optional :: p real ( dp ) :: norm2 end function norm2_dp module function norm1_qp ( x , p ) result ( norm1 ) real ( qp ), dimension (:), intent ( in ) :: x real ( qp ), intent ( in ), optional :: p real ( qp ) :: norm1 end function norm1_qp module function norm2_qp ( A , p ) result ( norm2 ) real ( qp ), dimension (:,:), intent ( in ) :: A real ( qp ), intent ( in ), optional :: p real ( qp ) :: norm2 end function norm2_qp end interface norm interface operator (. i .) !! Calculate the inverse of a real matrix. procedure inv_rsp procedure inv_rdp procedure inv_rqp procedure inv_csp procedure inv_cdp procedure inv_cqp end interface operator (. i .) interface operator (. x .) procedure :: rmut_sp procedure :: rmut_dp procedure :: rmut_qp procedure :: cmut_sp procedure :: cmut_dp procedure :: cmut_qp procedure :: rcmut_sp procedure :: rcmut_dp procedure :: rcmut_qp procedure :: crmut_sp procedure :: crmut_dp procedure :: crmut_qp end interface operator (. x .) !> Version: experimental !> !> Creates a rank-1 or rank-2 array filled ones. !> ([Specification](../page/specs/forlab_linalg.html#zerosones)) interface ones procedure :: ones_1_default procedure :: ones_2_default end interface ones interface outer module function outer_int8 ( x , y ) integer ( int8 ), dimension (:,:), allocatable :: outer_int8 integer ( int8 ), dimension (:), intent ( in ) :: x , y end function module function outer_int16 ( x , y ) integer ( int16 ), dimension (:,:), allocatable :: outer_int16 integer ( int16 ), dimension (:), intent ( in ) :: x , y end function module function outer_int32 ( x , y ) integer ( int32 ), dimension (:,:), allocatable :: outer_int32 integer ( int32 ), dimension (:), intent ( in ) :: x , y end function module function outer_int64 ( x , y ) integer ( int64 ), dimension (:,:), allocatable :: outer_int64 integer ( int64 ), dimension (:), intent ( in ) :: x , y end function module function outer_sp ( x , y ) real ( sp ), dimension (:,:), allocatable :: outer_sp real ( sp ), dimension (:), intent ( in ) :: x , y end function module function outer_dp ( x , y ) real ( dp ), dimension (:,:), allocatable :: outer_dp real ( dp ), dimension (:), intent ( in ) :: x , y end function module function outer_qp ( x , y ) real ( qp ), dimension (:,:), allocatable :: outer_qp real ( qp ), dimension (:), intent ( in ) :: x , y end function end interface outer interface qr module subroutine qr_sp ( a , q , r , l ) real ( sp ), intent ( in ) :: a (:,:) real ( sp ), allocatable , intent ( out ) :: q (:,:), r (:,:) integer , optional :: l end subroutine qr_sp module subroutine qr_dp ( a , q , r , l ) real ( dp ), intent ( in ) :: a (:,:) real ( dp ), allocatable , intent ( out ) :: q (:,:), r (:,:) integer , optional :: l end subroutine qr_dp module subroutine qr_qp ( a , q , r , l ) real ( qp ), intent ( in ) :: a (:,:) real ( qp ), allocatable , intent ( out ) :: q (:,:), r (:,:) integer , optional :: l end subroutine qr_qp end interface qr interface seq !! seq returns evenly spaced vector. module subroutine seq_sp ( X , from , to , by ) real ( sp ), dimension (:), allocatable , intent ( out ) :: X real ( sp ), intent ( in ) :: from , to real ( sp ), optional , intent ( in ) :: by end subroutine seq_sp module subroutine seq_dp ( X , from , to , by ) real ( dp ), dimension (:), allocatable , intent ( out ) :: X real ( dp ), intent ( in ) :: from , to real ( dp ), optional , intent ( in ) :: by end subroutine seq_dp module subroutine seq_qp ( X , from , to , by ) real ( qp ), dimension (:), allocatable , intent ( out ) :: X real ( qp ), intent ( in ) :: from , to real ( qp ), optional , intent ( in ) :: by end subroutine seq_qp module subroutine seq_int8 ( X , from , to , by ) integer ( int8 ), dimension (:), allocatable , intent ( out ) :: X integer ( int8 ), intent ( in ) :: from , to integer ( int8 ), optional , intent ( in ) :: by end subroutine seq_int8 module subroutine seq_int16 ( X , from , to , by ) integer ( int16 ), dimension (:), allocatable , intent ( out ) :: X integer ( int16 ), intent ( in ) :: from , to integer ( int16 ), optional , intent ( in ) :: by end subroutine seq_int16 module subroutine seq_int32 ( X , from , to , by ) integer ( int32 ), dimension (:), allocatable , intent ( out ) :: X integer ( int32 ), intent ( in ) :: from , to integer ( int32 ), optional , intent ( in ) :: by end subroutine seq_int32 module subroutine seq_int64 ( X , from , to , by ) integer ( int64 ), dimension (:), allocatable , intent ( out ) :: X integer ( int64 ), intent ( in ) :: from , to integer ( int64 ), optional , intent ( in ) :: by end subroutine seq_int64 end interface seq interface solve module function solve_sp ( A , b ) result ( x ) real ( sp ), dimension (:, :), intent ( in ) :: A real ( sp ), dimension (:), intent ( in ) :: b real ( sp ), dimension (:), allocatable :: x end function solve_sp module function solve_dp ( A , b ) result ( x ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension (:), allocatable :: x end function solve_dp module function solve_qp ( A , b ) result ( x ) real ( qp ), dimension (:, :), intent ( in ) :: A real ( qp ), dimension (:), intent ( in ) :: b real ( qp ), dimension (:), allocatable :: x end function solve_qp end interface solve interface svd module subroutine svd_sp ( a , w , u , v , d , ierr ) real ( sp ), dimension (:, :), intent ( in ) :: a real ( sp ), dimension (:), allocatable , intent ( out ) :: w real ( sp ), dimension (:, :), allocatable , intent ( out ), optional :: u , v integer , intent ( out ), optional :: ierr logical , intent ( in ), optional :: d end subroutine svd_sp module subroutine svd_dp ( a , w , u , v , d , ierr ) real ( dp ), dimension (:, :), intent ( in ) :: a real ( dp ), dimension (:), allocatable , intent ( out ) :: w real ( dp ), dimension (:, :), allocatable , intent ( out ), optional :: u , v integer , intent ( out ), optional :: ierr logical , intent ( in ), optional :: d end subroutine svd_dp module subroutine svd_qp ( a , w , u , v , d , ierr ) real ( qp ), dimension (:, :), intent ( in ) :: a real ( qp ), dimension (:), allocatable , intent ( out ) :: w real ( qp ), dimension (:, :), allocatable , intent ( out ), optional :: u , v integer , intent ( out ), optional :: ierr logical , intent ( in ), optional :: d end subroutine svd_qp end interface svd interface svdsolve module function svdsolve_sp ( A , b , cutoff ) result ( x ) real ( sp ), dimension (:, :), intent ( in ) :: A real ( sp ), dimension (:), intent ( in ) :: b real ( sp ), dimension (:), allocatable :: x integer , intent ( in ), optional :: cutoff end function svdsolve_sp module function svdsolve_dp ( A , b , cutoff ) result ( x ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ), dimension (:), intent ( in ) :: b real ( dp ), dimension (:), allocatable :: x integer , intent ( in ), optional :: cutoff end function svdsolve_dp module function svdsolve_qp ( A , b , cutoff ) result ( x ) real ( qp ), dimension (:, :), intent ( in ) :: A real ( qp ), dimension (:), intent ( in ) :: b real ( qp ), dimension (:), allocatable :: x integer , intent ( in ), optional :: cutoff end function svdsolve_qp end interface svdsolve interface trace procedure :: trace_sp procedure :: trace_dp procedure :: trace_qp end interface trace interface tril module function tril_int8 ( A , k ) integer ( int8 ), dimension (:, :), allocatable :: tril_int8 integer ( int8 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function tril_int8 module function tril_int16 ( A , k ) integer ( int16 ), dimension (:, :), allocatable :: tril_int16 integer ( int16 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function tril_int16 module function tril_int32 ( A , k ) integer ( int32 ), dimension (:, :), allocatable :: tril_int32 integer ( int32 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function tril_int32 module function tril_int64 ( A , k ) integer ( int64 ), dimension (:, :), allocatable :: tril_int64 integer ( int64 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function tril_int64 module function tril_sp ( A , k ) real ( sp ), dimension (:, :), allocatable :: tril_sp real ( sp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function tril_sp module function tril_dp ( A , k ) real ( dp ), dimension (:, :), allocatable :: tril_dp real ( dp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function tril_dp module function tril_qp ( A , k ) real ( qp ), dimension (:, :), allocatable :: tril_qp real ( qp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function tril_qp module function tril_csp ( A , k ) complex ( sp ), dimension (:, :), allocatable :: tril_csp complex ( sp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function tril_csp module function tril_cdp ( A , k ) complex ( dp ), dimension (:, :), allocatable :: tril_cdp complex ( dp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function tril_cdp module function tril_cqp ( A , k ) complex ( qp ), dimension (:, :), allocatable :: tril_cqp complex ( qp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function tril_cqp end interface tril interface triu module function triu_int8 ( A , k ) integer ( int8 ), dimension (:, :), allocatable :: triu_int8 integer ( int8 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function triu_int8 module function triu_int16 ( A , k ) integer ( int16 ), dimension (:, :), allocatable :: triu_int16 integer ( int16 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function triu_int16 module function triu_int32 ( A , k ) integer ( int32 ), dimension (:, :), allocatable :: triu_int32 integer ( int32 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function triu_int32 module function triu_int64 ( A , k ) integer ( int64 ), dimension (:, :), allocatable :: triu_int64 integer ( int64 ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function triu_int64 module function triu_sp ( A , k ) real ( sp ), dimension (:, :), allocatable :: triu_sp real ( sp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function triu_sp module function triu_dp ( A , k ) real ( dp ), dimension (:, :), allocatable :: triu_dp real ( dp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function triu_dp module function triu_qp ( A , k ) real ( qp ), dimension (:, :), allocatable :: triu_qp real ( qp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function triu_qp module function triu_csp ( A , k ) complex ( sp ), dimension (:, :), allocatable :: triu_csp complex ( sp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function triu_csp module function triu_cdp ( A , k ) complex ( dp ), dimension (:, :), allocatable :: triu_cdp complex ( dp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function triu_cdp module function triu_cqp ( A , k ) complex ( qp ), dimension (:, :), allocatable :: triu_cqp complex ( qp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: k end function triu_cqp end interface triu !> Version: experimental !> !> Creates a rank-1 or rank-2 array filled zeros. !> ([Specification](../page/specs/forlab_linalg.html#zerosones)) interface zeros procedure :: zeros_1_default procedure :: zeros_2_default end interface zeros contains function rmut_sp ( m1 , m2 ) result ( res ) !! complex(qp) matrix multiplication real ( sp ), intent ( in ) :: m1 (:, :), m2 (:, :) real ( sp ) :: res ( size ( m1 , 1 ), size ( m2 , 2 )) if ( size ( m1 , 2 ) == size ( m2 , 1 )) then res = matmul ( m1 , m2 ) else call error_stop ( 'Error: size(matrix_1, 2) /= size(matrix_2, 1)' ) end if end function rmut_sp function rmut_dp ( m1 , m2 ) result ( res ) !! complex(qp) matrix multiplication real ( dp ), intent ( in ) :: m1 (:, :), m2 (:, :) real ( dp ) :: res ( size ( m1 , 1 ), size ( m2 , 2 )) if ( size ( m1 , 2 ) == size ( m2 , 1 )) then res = matmul ( m1 , m2 ) else call error_stop ( 'Error: size(matrix_1, 2) /= size(matrix_2, 1)' ) end if end function rmut_dp function rmut_qp ( m1 , m2 ) result ( res ) !! complex(qp) matrix multiplication real ( qp ), intent ( in ) :: m1 (:, :), m2 (:, :) real ( qp ) :: res ( size ( m1 , 1 ), size ( m2 , 2 )) if ( size ( m1 , 2 ) == size ( m2 , 1 )) then res = matmul ( m1 , m2 ) else call error_stop ( 'Error: size(matrix_1, 2) /= size(matrix_2, 1)' ) end if end function rmut_qp function cmut_sp ( m1 , m2 ) result ( res ) !! complex(qp) matrix multiplication complex ( sp ), intent ( in ) :: m1 (:, :), m2 (:, :) complex ( sp ) :: res ( size ( m1 , 1 ), size ( m2 , 2 )) if ( size ( m1 , 2 ) == size ( m2 , 1 )) then res = matmul ( m1 , m2 ) else call error_stop ( 'Error: size(matrix_1, 2) /= size(matrix_2, 1)' ) end if end function cmut_sp function cmut_dp ( m1 , m2 ) result ( res ) !! complex(qp) matrix multiplication complex ( dp ), intent ( in ) :: m1 (:, :), m2 (:, :) complex ( dp ) :: res ( size ( m1 , 1 ), size ( m2 , 2 )) if ( size ( m1 , 2 ) == size ( m2 , 1 )) then res = matmul ( m1 , m2 ) else call error_stop ( 'Error: size(matrix_1, 2) /= size(matrix_2, 1)' ) end if end function cmut_dp function cmut_qp ( m1 , m2 ) result ( res ) !! complex(qp) matrix multiplication complex ( qp ), intent ( in ) :: m1 (:, :), m2 (:, :) complex ( qp ) :: res ( size ( m1 , 1 ), size ( m2 , 2 )) if ( size ( m1 , 2 ) == size ( m2 , 1 )) then res = matmul ( m1 , m2 ) else call error_stop ( 'Error: size(matrix_1, 2) /= size(matrix_2, 1)' ) end if end function cmut_qp function rcmut_sp ( m1 , m2 ) result ( res ) !! complex(qp) matrix multiplication real ( sp ), intent ( in ) :: m1 (:, :) complex ( sp ), intent ( in ) :: m2 (:, :) complex ( sp ) :: res ( size ( m1 , 1 ), size ( m2 , 2 )) if ( size ( m1 , 2 ) == size ( m2 , 1 )) then res = matmul ( m1 , m2 ) else call error_stop ( 'Error: size(matrix_1, 2) /= size(matrix_2, 1)' ) end if end function rcmut_sp function rcmut_dp ( m1 , m2 ) result ( res ) !! complex(qp) matrix multiplication real ( dp ), intent ( in ) :: m1 (:, :) complex ( dp ), intent ( in ) :: m2 (:, :) complex ( dp ) :: res ( size ( m1 , 1 ), size ( m2 , 2 )) if ( size ( m1 , 2 ) == size ( m2 , 1 )) then res = matmul ( m1 , m2 ) else call error_stop ( 'Error: size(matrix_1, 2) /= size(matrix_2, 1)' ) end if end function rcmut_dp function rcmut_qp ( m1 , m2 ) result ( res ) !! complex(qp) matrix multiplication real ( qp ), intent ( in ) :: m1 (:, :) complex ( qp ), intent ( in ) :: m2 (:, :) complex ( qp ) :: res ( size ( m1 , 1 ), size ( m2 , 2 )) if ( size ( m1 , 2 ) == size ( m2 , 1 )) then res = matmul ( m1 , m2 ) else call error_stop ( 'Error: size(matrix_1, 2) /= size(matrix_2, 1)' ) end if end function rcmut_qp function crmut_sp ( m1 , m2 ) result ( res ) !! complex(qp) matrix multiplication complex ( sp ), intent ( in ) :: m1 (:, :) real ( sp ), intent ( in ) :: m2 (:, :) complex ( sp ) :: res ( size ( m1 , 1 ), size ( m2 , 2 )) if ( size ( m1 , 2 ) == size ( m2 , 1 )) then res = matmul ( m1 , m2 ) else call error_stop ( 'Error: size(matrix_1, 2) /= size(matrix_2, 1)' ) end if end function crmut_sp function crmut_dp ( m1 , m2 ) result ( res ) !! complex(qp) matrix multiplication complex ( dp ), intent ( in ) :: m1 (:, :) real ( dp ), intent ( in ) :: m2 (:, :) complex ( dp ) :: res ( size ( m1 , 1 ), size ( m2 , 2 )) if ( size ( m1 , 2 ) == size ( m2 , 1 )) then res = matmul ( m1 , m2 ) else call error_stop ( 'Error: size(matrix_1, 2) /= size(matrix_2, 1)' ) end if end function crmut_dp function crmut_qp ( m1 , m2 ) result ( res ) !! complex(qp) matrix multiplication complex ( qp ), intent ( in ) :: m1 (:, :) real ( qp ), intent ( in ) :: m2 (:, :) complex ( qp ) :: res ( size ( m1 , 1 ), size ( m2 , 2 )) if ( size ( m1 , 2 ) == size ( m2 , 1 )) then res = matmul ( m1 , m2 ) else call error_stop ( 'Error: size(matrix_1, 2) /= size(matrix_2, 1)' ) end if end function crmut_qp function is_square_rsp ( A ) result ( is_square ) !! real(sp) matrix is square or not. real ( sp ), intent ( in ) :: A (:,:) logical :: is_square is_square = . false . if ( size ( A , 1 ) == size ( A , 2 )) is_square = . true . return end function is_square_rsp function is_square_rdp ( A ) result ( is_square ) !! real(dp) matrix is square or not. real ( dp ), intent ( in ) :: A (:,:) logical :: is_square is_square = . false . if ( size ( A , 1 ) == size ( A , 2 )) is_square = . true . return end function is_square_rdp function is_square_rqp ( A ) result ( is_square ) !! real(qp) matrix is square or not. real ( qp ), intent ( in ) :: A (:,:) logical :: is_square is_square = . false . if ( size ( A , 1 ) == size ( A , 2 )) is_square = . true . return end function is_square_rqp function is_square_csp ( A ) result ( is_square ) !! complex(sp) matrix is square or not. complex ( sp ), intent ( in ) :: A (:,:) logical :: is_square is_square = . false . if ( size ( A , 1 ) == size ( A , 2 )) is_square = . true . return end function is_square_csp function is_square_cdp ( A ) result ( is_square ) !! complex(dp) matrix is square or not. complex ( dp ), intent ( in ) :: A (:,:) logical :: is_square is_square = . false . if ( size ( A , 1 ) == size ( A , 2 )) is_square = . true . return end function is_square_cdp function is_square_cqp ( A ) result ( is_square ) !! complex(qp) matrix is square or not. complex ( qp ), intent ( in ) :: A (:,:) logical :: is_square is_square = . false . if ( size ( A , 1 ) == size ( A , 2 )) is_square = . true . return end function is_square_cqp function is_symmetric_rsp ( A ) result ( is_symmetric ) !! real(sp) matrix is symmetric or not. real ( sp ), intent ( in ) :: A (:,:) logical :: is_symmetric integer :: i , j , n is_symmetric = . true . if (. not . is_square ( A )) then is_symmetric = . false . return else n = size ( A , 1 ) do i = 1 , n do j = 1 , n if ( A ( i , j ) . ne . A ( j , i )) then is_symmetric = . false . return end if end do end do end if return end function is_symmetric_rsp function is_symmetric_rdp ( A ) result ( is_symmetric ) !! real(dp) matrix is symmetric or not. real ( dp ), intent ( in ) :: A (:,:) logical :: is_symmetric integer :: i , j , n is_symmetric = . true . if (. not . is_square ( A )) then is_symmetric = . false . return else n = size ( A , 1 ) do i = 1 , n do j = 1 , n if ( A ( i , j ) . ne . A ( j , i )) then is_symmetric = . false . return end if end do end do end if return end function is_symmetric_rdp function is_symmetric_rqp ( A ) result ( is_symmetric ) !! real(qp) matrix is symmetric or not. real ( qp ), intent ( in ) :: A (:,:) logical :: is_symmetric integer :: i , j , n is_symmetric = . true . if (. not . is_square ( A )) then is_symmetric = . false . return else n = size ( A , 1 ) do i = 1 , n do j = 1 , n if ( A ( i , j ) . ne . A ( j , i )) then is_symmetric = . false . return end if end do end do end if return end function is_symmetric_rqp function is_symmetric_csp ( A ) result ( is_symmetric ) !! complex(sp) matrix is symmetric or not. complex ( sp ), intent ( in ) :: A (:,:) logical :: is_symmetric integer :: i , j , n is_symmetric = . true . if (. not . is_square ( A )) then is_symmetric = . false . return else n = size ( A , 1 ) do i = 1 , n do j = 1 , n if ( A ( i , j ) . ne . A ( j , i )) then is_symmetric = . false . return end if end do end do end if return end function is_symmetric_csp function is_symmetric_cdp ( A ) result ( is_symmetric ) !! complex(dp) matrix is symmetric or not. complex ( dp ), intent ( in ) :: A (:,:) logical :: is_symmetric integer :: i , j , n is_symmetric = . true . if (. not . is_square ( A )) then is_symmetric = . false . return else n = size ( A , 1 ) do i = 1 , n do j = 1 , n if ( A ( i , j ) . ne . A ( j , i )) then is_symmetric = . false . return end if end do end do end if return end function is_symmetric_cdp function is_symmetric_cqp ( A ) result ( is_symmetric ) !! complex(qp) matrix is symmetric or not. complex ( qp ), intent ( in ) :: A (:,:) logical :: is_symmetric integer :: i , j , n is_symmetric = . true . if (. not . is_square ( A )) then is_symmetric = . false . return else n = size ( A , 1 ) do i = 1 , n do j = 1 , n if ( A ( i , j ) . ne . A ( j , i )) then is_symmetric = . false . return end if end do end do end if return end function is_symmetric_cqp function trace_sp ( A ) result ( trace ) real ( sp ), dimension (:, :), intent ( in ) :: A real ( sp ) :: trace trace = sum ( diag ( A )) end function trace_sp function trace_dp ( A ) result ( trace ) real ( dp ), dimension (:, :), intent ( in ) :: A real ( dp ) :: trace trace = sum ( diag ( A )) end function trace_dp function trace_qp ( A ) result ( trace ) real ( qp ), dimension (:, :), intent ( in ) :: A real ( qp ) :: trace trace = sum ( diag ( A )) end function trace_qp !> `ones` creates a rank-1 array, filled completely with `1` `integer` type values. pure function ones_1_default ( dim ) result ( result ) integer , intent ( in ) :: dim integer ( kind = int8 ), allocatable :: result (:) allocate ( result ( dim ), source = 1_int8 ) end function ones_1_default !> `ones` creates a rank-2 array, filled completely with `1` `integer` type values. pure function ones_2_default ( dim1 , dim2 ) result ( result ) integer , intent ( in ) :: dim1 , dim2 integer ( kind = int8 ), allocatable :: result (:, :) allocate ( result ( dim1 , dim2 ), source = 1_int8 ) end function ones_2_default !> `zeros` creates a rank-1 array, filled completely with `0` `integer` type values. pure function zeros_1_default ( dim ) result ( result ) integer , intent ( in ) :: dim integer ( kind = int8 ), allocatable :: result (:) allocate ( result ( dim ), source = 0_int8 ) end function zeros_1_default !> `zeros` creates a rank-2 array, filled completely with `0` `integer` type values. pure function zeros_2_default ( dim1 , dim2 ) result ( result ) integer , intent ( in ) :: dim1 , dim2 integer ( kind = int8 ), allocatable :: result (:, :) allocate ( result ( dim1 , dim2 ), source = 0_int8 ) end function zeros_2_default end module forlab_linalg","tags":"","loc":"sourcefile/forlab_linalg.f90.html"},{"title":"forlab_stats_randu.f90 – FORLAB","text":"Contents Submodules forlab_stats_randu Source Code forlab_stats_randu.f90 Source Code submodule ( forlab_stats ) forlab_stats_randu implicit none contains module function randu_0_rsp ( start , end ) result ( random ) real ( sp ), intent ( in ) :: start , end real ( sp ) :: random call random_number ( random ) random = start + random * ( end - start ) end function randu_0_rsp module function randu_1_rsp ( start , end , ndim ) result ( random ) real ( sp ), intent ( in ) :: start , end integer , intent ( in ) :: ndim real ( sp ) :: random ( ndim ) call random_number ( random ) random = start + random * ( end - start ) end function randu_1_rsp module function randu_0_rdp ( start , end ) result ( random ) real ( dp ), intent ( in ) :: start , end real ( dp ) :: random call random_number ( random ) random = start + random * ( end - start ) end function randu_0_rdp module function randu_1_rdp ( start , end , ndim ) result ( random ) real ( dp ), intent ( in ) :: start , end integer , intent ( in ) :: ndim real ( dp ) :: random ( ndim ) call random_number ( random ) random = start + random * ( end - start ) end function randu_1_rdp module function randu_0_rqp ( start , end ) result ( random ) real ( qp ), intent ( in ) :: start , end real ( qp ) :: random call random_number ( random ) random = start + random * ( end - start ) end function randu_0_rqp module function randu_1_rqp ( start , end , ndim ) result ( random ) real ( qp ), intent ( in ) :: start , end integer , intent ( in ) :: ndim real ( qp ) :: random ( ndim ) call random_number ( random ) random = start + random * ( end - start ) end function randu_1_rqp module function randu_0_iint8 ( start , end ) result ( random ) integer ( int8 ), intent ( in ) :: start , end integer ( int8 ) :: random real :: tmp call random_number ( tmp ) random = start + nint ( tmp * real ( end - start ), int8 ) end function randu_0_iint8 module function randu_1_iint8 ( start , end , ndim ) result ( random ) integer ( int8 ), intent ( in ) :: start , end integer , intent ( in ) :: ndim integer ( int8 ) :: random ( ndim ) real :: tmp ( ndim ) call random_number ( tmp ) random = start + nint ( tmp * real ( end - start ), int8 ) end function randu_1_iint8 module function randu_0_iint16 ( start , end ) result ( random ) integer ( int16 ), intent ( in ) :: start , end integer ( int16 ) :: random real :: tmp call random_number ( tmp ) random = start + nint ( tmp * real ( end - start ), int16 ) end function randu_0_iint16 module function randu_1_iint16 ( start , end , ndim ) result ( random ) integer ( int16 ), intent ( in ) :: start , end integer , intent ( in ) :: ndim integer ( int16 ) :: random ( ndim ) real :: tmp ( ndim ) call random_number ( tmp ) random = start + nint ( tmp * real ( end - start ), int16 ) end function randu_1_iint16 module function randu_0_iint32 ( start , end ) result ( random ) integer ( int32 ), intent ( in ) :: start , end integer ( int32 ) :: random real :: tmp call random_number ( tmp ) random = start + nint ( tmp * real ( end - start ), int32 ) end function randu_0_iint32 module function randu_1_iint32 ( start , end , ndim ) result ( random ) integer ( int32 ), intent ( in ) :: start , end integer , intent ( in ) :: ndim integer ( int32 ) :: random ( ndim ) real :: tmp ( ndim ) call random_number ( tmp ) random = start + nint ( tmp * real ( end - start ), int32 ) end function randu_1_iint32 module function randu_0_iint64 ( start , end ) result ( random ) integer ( int64 ), intent ( in ) :: start , end integer ( int64 ) :: random real :: tmp call random_number ( tmp ) random = start + nint ( tmp * real ( end - start ), int64 ) end function randu_0_iint64 module function randu_1_iint64 ( start , end , ndim ) result ( random ) integer ( int64 ), intent ( in ) :: start , end integer , intent ( in ) :: ndim integer ( int64 ) :: random ( ndim ) real :: tmp ( ndim ) call random_number ( tmp ) random = start + nint ( tmp * real ( end - start ), int64 ) end function randu_1_iint64 end submodule forlab_stats_randu","tags":"","loc":"sourcefile/forlab_stats_randu.f90.html"},{"title":"forlab_io_color.f90 – FORLAB","text":"Contents Submodules forlab_io_color Source Code forlab_io_color.f90 Source Code !> Some prepared color to choosed. !> https://rosettacode.org/wiki/Terminal_control/Coloured_text#Fortran submodule ( forlab_io ) forlab_io_color contains module subroutine color ( string ) character ( len =* ), intent ( in ), optional :: string write ( * , \"(A)\" , advance = \"no\" ) optval ( string , achar ( 27 ) // '[0m' ) end subroutine color end submodule forlab_io_color","tags":"","loc":"sourcefile/forlab_io_color.f90.html"},{"title":"forlab_io_txt.f90 – FORLAB","text":"Contents Submodules forlab__io_txt Source Code forlab_io_txt.f90 Source Code submodule ( forlab_io ) forlab__io_txt use forlab_time , only : time_string implicit none contains module procedure loadtxt_1_rsp integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'rsp' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 1 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 1 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,1I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_1_rsp module procedure loadtxt_1_rdp integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'rdp' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 1 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 1 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,1I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_1_rdp module procedure loadtxt_1_rqp integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'rqp' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 1 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 1 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,1I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_1_rqp module procedure loadtxt_1_iint8 integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'iint8' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 1 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 1 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,1I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_1_iint8 module procedure loadtxt_1_iint16 integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'iint16' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 1 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 1 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,1I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_1_iint16 module procedure loadtxt_1_iint32 integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'iint32' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 1 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 1 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,1I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_1_iint32 module procedure loadtxt_1_iint64 integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'iint64' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 1 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 1 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,1I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_1_iint64 module procedure loadtxt_1_csp integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'csp' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 1 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 1 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,1I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_1_csp module procedure loadtxt_1_cdp integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'cdp' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 1 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 1 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,1I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_1_cdp module procedure loadtxt_1_cqp integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'cqp' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 1 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 1 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 1 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,1I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_1_cqp module procedure loadtxt_2_rsp integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'rsp' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 2 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 2 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,2I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ,:) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_2_rsp module procedure loadtxt_2_rdp integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'rdp' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 2 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 2 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,2I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ,:) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_2_rdp module procedure loadtxt_2_rqp integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'rqp' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 2 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 2 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,2I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ,:) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_2_rqp module procedure loadtxt_2_iint8 integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'iint8' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 2 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 2 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,2I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ,:) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_2_iint8 module procedure loadtxt_2_iint16 integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'iint16' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 2 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 2 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,2I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ,:) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_2_iint16 module procedure loadtxt_2_iint32 integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'iint32' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 2 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 2 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,2I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ,:) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_2_iint32 module procedure loadtxt_2_iint64 integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'iint64' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 2 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 2 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,2I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ,:) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_2_iint64 module procedure loadtxt_2_csp integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'csp' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 2 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 2 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,2I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ,:) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_2_csp module procedure loadtxt_2_cdp integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'cdp' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 2 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 2 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,2I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ,:) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_2_cdp module procedure loadtxt_2_cqp integer :: i , data_dim type ( File ) :: infile character ( * ), parameter :: type = 'cqp' character ( 8 ) :: datatype integer , allocatable :: nsize (:) allocate ( nsize ( 2 )) infile = file ( filename , 'r t' ) if ( infile % exist ()) then call infile % open () read ( infile % unit , '(6X,A8,I8)' ) datatype , data_dim if ( trim ( adjustl ( datatype )) /= type ) then call error_stop ( 'Error: The program failed to try to read a ' & // type // ' array, but the file ' // trim ( filename ) // & 'stored an array with a ' // datatype // '.' ) endif if ( data_dim /= 2 ) then call error_stop ( 'Error: The program failed to read the ' & // to_string ( 2 ) // '-dimensional array. It may be that the file ' & // trim ( filename ) // ' stores an array of different dimensions.' ) endif read ( infile % unit , * ) read ( infile % unit , '(11X,2I8)' ) nsize (:) read ( infile % unit , * ) allocate ( X ( nsize ( 1 ), nsize ( 2 ))) do i = 1 , nsize ( 1 ) read ( infile % unit , * ) X ( i ,:) end do call infile % close () else call error_stop ( \"Error: '\" // trim ( filename ) // \"' not found\" ) end if return end procedure loadtxt_2_cqp module procedure savetxt_1_rsp integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'rsp' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 1 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,1(I8))' ) 'DIMENSION: ' , size ( X , 1 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i ) end do call outfile % close () return end procedure savetxt_1_rsp module procedure savetxt_1_rdp integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'rdp' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 1 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,1(I8))' ) 'DIMENSION: ' , size ( X , 1 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i ) end do call outfile % close () return end procedure savetxt_1_rdp module procedure savetxt_1_rqp integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'rqp' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 1 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,1(I8))' ) 'DIMENSION: ' , size ( X , 1 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i ) end do call outfile % close () return end procedure savetxt_1_rqp module procedure savetxt_1_iint8 integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'iint8' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 1 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,1(I8))' ) 'DIMENSION: ' , size ( X , 1 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i ) end do call outfile % close () return end procedure savetxt_1_iint8 module procedure savetxt_1_iint16 integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'iint16' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 1 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,1(I8))' ) 'DIMENSION: ' , size ( X , 1 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i ) end do call outfile % close () return end procedure savetxt_1_iint16 module procedure savetxt_1_iint32 integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'iint32' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 1 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,1(I8))' ) 'DIMENSION: ' , size ( X , 1 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i ) end do call outfile % close () return end procedure savetxt_1_iint32 module procedure savetxt_1_iint64 integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'iint64' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 1 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,1(I8))' ) 'DIMENSION: ' , size ( X , 1 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i ) end do call outfile % close () return end procedure savetxt_1_iint64 module procedure savetxt_1_csp integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'csp' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 1 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,1(I8))' ) 'DIMENSION: ' , size ( X , 1 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i ) end do call outfile % close () return end procedure savetxt_1_csp module procedure savetxt_1_cdp integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'cdp' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 1 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,1(I8))' ) 'DIMENSION: ' , size ( X , 1 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i ) end do call outfile % close () return end procedure savetxt_1_cdp module procedure savetxt_1_cqp integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'cqp' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 1 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,1(I8))' ) 'DIMENSION: ' , size ( X , 1 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i ) end do call outfile % close () return end procedure savetxt_1_cqp module procedure savetxt_2_rsp integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'rsp' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 2 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,2(I8))' ) 'DIMENSION: ' , size ( X , 1 ), size ( X , 2 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i , :) end do call outfile % close () return end procedure savetxt_2_rsp module procedure savetxt_2_rdp integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'rdp' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 2 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,2(I8))' ) 'DIMENSION: ' , size ( X , 1 ), size ( X , 2 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i , :) end do call outfile % close () return end procedure savetxt_2_rdp module procedure savetxt_2_rqp integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'rqp' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 2 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,2(I8))' ) 'DIMENSION: ' , size ( X , 1 ), size ( X , 2 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i , :) end do call outfile % close () return end procedure savetxt_2_rqp module procedure savetxt_2_iint8 integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'iint8' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 2 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,2(I8))' ) 'DIMENSION: ' , size ( X , 1 ), size ( X , 2 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i , :) end do call outfile % close () return end procedure savetxt_2_iint8 module procedure savetxt_2_iint16 integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'iint16' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 2 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,2(I8))' ) 'DIMENSION: ' , size ( X , 1 ), size ( X , 2 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i , :) end do call outfile % close () return end procedure savetxt_2_iint16 module procedure savetxt_2_iint32 integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'iint32' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 2 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,2(I8))' ) 'DIMENSION: ' , size ( X , 1 ), size ( X , 2 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i , :) end do call outfile % close () return end procedure savetxt_2_iint32 module procedure savetxt_2_iint64 integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'iint64' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 2 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,2(I8))' ) 'DIMENSION: ' , size ( X , 1 ), size ( X , 2 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i , :) end do call outfile % close () return end procedure savetxt_2_iint64 module procedure savetxt_2_csp integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'csp' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 2 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,2(I8))' ) 'DIMENSION: ' , size ( X , 1 ), size ( X , 2 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i , :) end do call outfile % close () return end procedure savetxt_2_csp module procedure savetxt_2_cdp integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'cdp' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 2 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,2(I8))' ) 'DIMENSION: ' , size ( X , 1 ), size ( X , 2 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i , :) end do call outfile % close () return end procedure savetxt_2_cdp module procedure savetxt_2_cqp integer :: i , m type ( file ) :: outfile character ( 8 ), parameter :: type = 'cqp' outfile = file ( filename , 'w t' ) m = size ( x , 1 ) call outfile % open () write ( outfile % unit , '(A6,A8,I8)' ) 'TYPE: ' , type , int ( 2 , 4 ) write ( outfile % unit , '(A6,A)' ) 'DATA: ' , time_string () write ( outfile % unit , '(A11,2(I8))' ) 'DIMENSION: ' , size ( X , 1 ), size ( X , 2 ) write ( outfile % unit , '(A)' ) '---' do i = 1 , m write ( outfile % unit , * ) X ( i , :) end do call outfile % close () return end procedure savetxt_2_cqp end submodule forlab__io_txt","tags":"","loc":"sourcefile/forlab_io_txt.f90.html"},{"title":"forlab_linalg_seq.f90 – FORLAB","text":"Contents Submodules forlab_linalg_seq Source Code forlab_linalg_seq.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_seq implicit none contains module procedure seq_sp real ( sp ) :: by_ integer :: i , n by_ = optval ( by , 1.0_sp ) if ( by <= 0 ) then call error_stop ( 'Error: In seq, `by` should be greater than 0.' ) end if n = int ( abs ( to - from ) / by_ ) + 1 allocate ( X ( n )) if ( from <= to ) then X = from + by_ * real ([( i - 1 , i = 1 , n )], sp ) else X = from - by_ * real ([( i - 1 , i = 1 , n )], sp ) end if return end procedure seq_sp module procedure seq_dp real ( dp ) :: by_ integer :: i , n by_ = optval ( by , 1.0_dp ) if ( by <= 0 ) then call error_stop ( 'Error: In seq, `by` should be greater than 0.' ) end if n = int ( abs ( to - from ) / by_ ) + 1 allocate ( X ( n )) if ( from <= to ) then X = from + by_ * real ([( i - 1 , i = 1 , n )], dp ) else X = from - by_ * real ([( i - 1 , i = 1 , n )], dp ) end if return end procedure seq_dp module procedure seq_qp real ( qp ) :: by_ integer :: i , n by_ = optval ( by , 1.0_qp ) if ( by <= 0 ) then call error_stop ( 'Error: In seq, `by` should be greater than 0.' ) end if n = int ( abs ( to - from ) / by_ ) + 1 allocate ( X ( n )) if ( from <= to ) then X = from + by_ * real ([( i - 1 , i = 1 , n )], qp ) else X = from - by_ * real ([( i - 1 , i = 1 , n )], qp ) end if return end procedure seq_qp module procedure seq_int8 integer ( int8 ) :: by_ integer :: i , n by_ = optval ( by , 1_int8 ) if ( by <= 0 ) then call error_stop ( 'Error: In seq, `by` should be greater than 0.' ) end if n = ( to - from ) / by_ + 1 allocate ( X ( n )) if ( from <= to ) then X = [( i , i = from , to , by_ )] else X = [( i , i = from , to , - by_ )] end if return end procedure seq_int8 module procedure seq_int16 integer ( int16 ) :: by_ integer :: i , n by_ = optval ( by , 1_int16 ) if ( by <= 0 ) then call error_stop ( 'Error: In seq, `by` should be greater than 0.' ) end if n = ( to - from ) / by_ + 1 allocate ( X ( n )) if ( from <= to ) then X = [( i , i = from , to , by_ )] else X = [( i , i = from , to , - by_ )] end if return end procedure seq_int16 module procedure seq_int32 integer ( int32 ) :: by_ integer :: i , n by_ = optval ( by , 1_int32 ) if ( by <= 0 ) then call error_stop ( 'Error: In seq, `by` should be greater than 0.' ) end if n = ( to - from ) / by_ + 1 allocate ( X ( n )) if ( from <= to ) then X = [( i , i = from , to , by_ )] else X = [( i , i = from , to , - by_ )] end if return end procedure seq_int32 module procedure seq_int64 integer ( int64 ) :: by_ integer :: i , n by_ = optval ( by , 1_int64 ) if ( by <= 0 ) then call error_stop ( 'Error: In seq, `by` should be greater than 0.' ) end if n = ( to - from ) / by_ + 1 allocate ( X ( n )) if ( from <= to ) then X = [( i , i = from , to , by_ )] else X = [( i , i = from , to , - by_ )] end if return end procedure seq_int64 end submodule forlab_linalg_seq","tags":"","loc":"sourcefile/forlab_linalg_seq.f90.html"},{"title":"forlab_math_is_close.f90 – FORLAB","text":"Contents Submodules forlab_math_is_close Source Code forlab_math_is_close.f90 Source Code submodule ( forlab_math ) forlab_math_is_close contains elemental module function is_close_rsp ( a , b , rel_tol , abs_tol ) result ( close ) real ( sp ), intent ( in ) :: a , b real ( sp ), intent ( in ), optional :: rel_tol , abs_tol logical :: close close = abs ( a - b ) <= max ( abs ( optval ( rel_tol , 1.0e-9_sp ) * max ( abs ( a ), abs ( b ))), & abs ( optval ( abs_tol , 0.0_sp )) ) end function is_close_rsp elemental module function is_close_rdp ( a , b , rel_tol , abs_tol ) result ( close ) real ( dp ), intent ( in ) :: a , b real ( dp ), intent ( in ), optional :: rel_tol , abs_tol logical :: close close = abs ( a - b ) <= max ( abs ( optval ( rel_tol , 1.0e-9_dp ) * max ( abs ( a ), abs ( b ))), & abs ( optval ( abs_tol , 0.0_dp )) ) end function is_close_rdp elemental module function is_close_rqp ( a , b , rel_tol , abs_tol ) result ( close ) real ( qp ), intent ( in ) :: a , b real ( qp ), intent ( in ), optional :: rel_tol , abs_tol logical :: close close = abs ( a - b ) <= max ( abs ( optval ( rel_tol , 1.0e-9_qp ) * max ( abs ( a ), abs ( b ))), & abs ( optval ( abs_tol , 0.0_qp )) ) end function is_close_rqp elemental module function is_close_csp ( a , b , rel_tol , abs_tol ) result ( close ) complex ( sp ), intent ( in ) :: a , b real ( sp ), intent ( in ), optional :: rel_tol , abs_tol logical :: close close = is_close_rsp ( a % re , b % re , rel_tol , abs_tol ) . and . & is_close_rsp ( a % im , b % im , rel_tol , abs_tol ) end function is_close_csp elemental module function is_close_cdp ( a , b , rel_tol , abs_tol ) result ( close ) complex ( dp ), intent ( in ) :: a , b real ( dp ), intent ( in ), optional :: rel_tol , abs_tol logical :: close close = is_close_rdp ( a % re , b % re , rel_tol , abs_tol ) . and . & is_close_rdp ( a % im , b % im , rel_tol , abs_tol ) end function is_close_cdp elemental module function is_close_cqp ( a , b , rel_tol , abs_tol ) result ( close ) complex ( qp ), intent ( in ) :: a , b real ( qp ), intent ( in ), optional :: rel_tol , abs_tol logical :: close close = is_close_rqp ( a % re , b % re , rel_tol , abs_tol ) . and . & is_close_rqp ( a % im , b % im , rel_tol , abs_tol ) end function is_close_cqp end submodule forlab_math_is_close","tags":"","loc":"sourcefile/forlab_math_is_close.f90.html"},{"title":"forlab_stats.f90 – FORLAB","text":"Contents Modules forlab_stats Source Code forlab_stats.f90 Source Code module forlab_stats use stdlib_kinds , only : sp , dp , qp , int8 , int16 , int32 , int64 implicit none private public :: mean , var , std public :: rng , randu , randn interface mean !! mean computes the mean value of an array. module function mean_1_sp ( x ) result ( mean ) real ( sp ), dimension (:), intent ( in ) :: x real ( sp ) :: mean end function mean_1_sp module function mean_2_sp ( A , dim ) result ( mean ) real ( sp ), dimension (:), allocatable :: mean real ( sp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: dim end function mean_2_sp module function mean_1_dp ( x ) result ( mean ) real ( dp ), dimension (:), intent ( in ) :: x real ( dp ) :: mean end function mean_1_dp module function mean_2_dp ( A , dim ) result ( mean ) real ( dp ), dimension (:), allocatable :: mean real ( dp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: dim end function mean_2_dp module function mean_1_qp ( x ) result ( mean ) real ( qp ), dimension (:), intent ( in ) :: x real ( qp ) :: mean end function mean_1_qp module function mean_2_qp ( A , dim ) result ( mean ) real ( qp ), dimension (:), allocatable :: mean real ( qp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: dim end function mean_2_qp end interface mean !> Version: Experimental !> !> Generate a normal distributed data scalar or vector. !> ([Specification](../page/specs/forlab_stats.html#randn)) interface randn module function randn_0_sp ( mean , std ) result ( random ) real ( sp ), intent ( in ) :: mean , std real ( sp ) :: random end function randn_0_sp module function randn_1_sp ( mean , std , ndim ) result ( random ) real ( sp ), intent ( in ) :: mean , std integer , intent ( in ) :: ndim real ( sp ) :: random ( ndim ) end function randn_1_sp module function randn_0_dp ( mean , std ) result ( random ) real ( dp ), intent ( in ) :: mean , std real ( dp ) :: random end function randn_0_dp module function randn_1_dp ( mean , std , ndim ) result ( random ) real ( dp ), intent ( in ) :: mean , std integer , intent ( in ) :: ndim real ( dp ) :: random ( ndim ) end function randn_1_dp module function randn_0_qp ( mean , std ) result ( random ) real ( qp ), intent ( in ) :: mean , std real ( qp ) :: random end function randn_0_qp module function randn_1_qp ( mean , std , ndim ) result ( random ) real ( qp ), intent ( in ) :: mean , std integer , intent ( in ) :: ndim real ( qp ) :: random ( ndim ) end function randn_1_qp end interface randn !> Version: Experimental !> !> Generate an uniformly distributed data scalar or vector. !> ([Specification](../page/specs/forlab_stats.html#randomrandu)) interface randu module function randu_0_rsp ( start , end ) result ( random ) real ( sp ), intent ( in ) :: start , end real ( sp ) :: random end function randu_0_rsp module function randu_1_rsp ( start , end , ndim ) result ( random ) real ( sp ), intent ( in ) :: start , end integer , intent ( in ) :: ndim real ( sp ) :: random ( ndim ) end function randu_1_rsp module function randu_0_rdp ( start , end ) result ( random ) real ( dp ), intent ( in ) :: start , end real ( dp ) :: random end function randu_0_rdp module function randu_1_rdp ( start , end , ndim ) result ( random ) real ( dp ), intent ( in ) :: start , end integer , intent ( in ) :: ndim real ( dp ) :: random ( ndim ) end function randu_1_rdp module function randu_0_rqp ( start , end ) result ( random ) real ( qp ), intent ( in ) :: start , end real ( qp ) :: random end function randu_0_rqp module function randu_1_rqp ( start , end , ndim ) result ( random ) real ( qp ), intent ( in ) :: start , end integer , intent ( in ) :: ndim real ( qp ) :: random ( ndim ) end function randu_1_rqp module function randu_0_iint8 ( start , end ) result ( random ) integer ( int8 ), intent ( in ) :: start , end integer ( int8 ) :: random end function randu_0_iint8 module function randu_1_iint8 ( start , end , ndim ) result ( random ) integer ( int8 ), intent ( in ) :: start , end integer , intent ( in ) :: ndim integer ( int8 ) :: random ( ndim ) end function randu_1_iint8 module function randu_0_iint16 ( start , end ) result ( random ) integer ( int16 ), intent ( in ) :: start , end integer ( int16 ) :: random end function randu_0_iint16 module function randu_1_iint16 ( start , end , ndim ) result ( random ) integer ( int16 ), intent ( in ) :: start , end integer , intent ( in ) :: ndim integer ( int16 ) :: random ( ndim ) end function randu_1_iint16 module function randu_0_iint32 ( start , end ) result ( random ) integer ( int32 ), intent ( in ) :: start , end integer ( int32 ) :: random end function randu_0_iint32 module function randu_1_iint32 ( start , end , ndim ) result ( random ) integer ( int32 ), intent ( in ) :: start , end integer , intent ( in ) :: ndim integer ( int32 ) :: random ( ndim ) end function randu_1_iint32 module function randu_0_iint64 ( start , end ) result ( random ) integer ( int64 ), intent ( in ) :: start , end integer ( int64 ) :: random end function randu_0_iint64 module function randu_1_iint64 ( start , end , ndim ) result ( random ) integer ( int64 ), intent ( in ) :: start , end integer , intent ( in ) :: ndim integer ( int64 ) :: random ( ndim ) end function randu_1_iint64 end interface randu interface module subroutine rng ( seed ) integer , intent ( in ), optional :: seed end subroutine rng end interface interface var !! `var` computes vector and matrix variances. !!([Specification](../module/forlab_var.html)) real ( sp ) module function var_1_sp ( x , w ) real ( sp ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: w end function var_1_sp module function var_2_sp ( A , w , dim ) real ( sp ), dimension (:), allocatable :: var_2_sp real ( sp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: w , dim end function var_2_sp real ( dp ) module function var_1_dp ( x , w ) real ( dp ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: w end function var_1_dp module function var_2_dp ( A , w , dim ) real ( dp ), dimension (:), allocatable :: var_2_dp real ( dp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: w , dim end function var_2_dp real ( qp ) module function var_1_qp ( x , w ) real ( qp ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: w end function var_1_qp module function var_2_qp ( A , w , dim ) real ( qp ), dimension (:), allocatable :: var_2_qp real ( qp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: w , dim end function var_2_qp end interface var interface std !! `std` computes vector and matrix standard deviations. !!([Specification](../module/forlab_var.html)) real ( sp ) module function std_1_sp ( x , w ) real ( sp ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: w end function std_1_sp module function std_2_sp ( A , w , dim ) real ( sp ), dimension (:), allocatable :: std_2_sp real ( sp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: w , dim end function std_2_sp real ( dp ) module function std_1_dp ( x , w ) real ( dp ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: w end function std_1_dp module function std_2_dp ( A , w , dim ) real ( dp ), dimension (:), allocatable :: std_2_dp real ( dp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: w , dim end function std_2_dp real ( qp ) module function std_1_qp ( x , w ) real ( qp ), dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: w end function std_1_qp module function std_2_qp ( A , w , dim ) real ( qp ), dimension (:), allocatable :: std_2_qp real ( qp ), dimension (:, :), intent ( in ) :: A integer , intent ( in ), optional :: w , dim end function std_2_qp end interface std end module forlab_stats","tags":"","loc":"sourcefile/forlab_stats.f90.html"},{"title":"forlab_linalg_svd.f90 – FORLAB","text":"Contents Submodules forlab_linalg_svd Source Code forlab_linalg_svd.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_svd implicit none contains module procedure svd_sp integer :: m , n , i , its , i1 , j , k , kk , k1 , l , ll , l1 , mn integer , dimension (:), allocatable :: idx real ( sp ) :: c , f , g , h , s , scale , tst1 , tst2 , x , y , z real ( sp ), dimension (:), allocatable :: rv1 real ( sp ), dimension (:, :), allocatable :: opt_u , opt_v logical :: outu , outv , opt_d , outierr real ( sp ), parameter :: zero = 0.0_sp , one = 1.0_sp outu = . false . outv = . false . opt_d = . true . outierr = . false . m = size ( a , 1 ) n = size ( a , 2 ) if (. not . allocated ( w )) allocate ( w ( n )) allocate ( rv1 ( n ), opt_u ( m , n ), opt_v ( n , n )) opt_u = a if ( present ( d )) opt_d = d if ( present ( u )) outu = . true . if ( present ( v )) outv = . true . if ( present ( ierr )) outierr = . true . ! Householder reduction to bidiagonal form !========================================== g = zero scale = zero x = zero do i = 1 , n l = i + 1 rv1 ( i ) = scale * g g = zero s = zero scale = zero if ( i <= m ) then scale = sum ( abs ( opt_u ( i : m , i ))) if ( scale /= zero ) then opt_u ( i : m , i ) = opt_u ( i : m , i ) / scale s = sum ( opt_u ( i : m , i ) ** 2 ) f = opt_u ( i , i ) g = - sign ( sqrt ( s ), f ) h = f * g - s opt_u ( i , i ) = f - g if ( i /= n ) then do j = l , n s = dot_product ( opt_u ( i : m , i ), opt_u ( i : m , j )) opt_u ( i : m , j ) = opt_u ( i : m , j ) + s * opt_u ( i : m , i ) / h end do end if opt_u ( i : m , i ) = scale * opt_u ( i : m , i ) end if end if w ( i ) = scale * g g = zero s = zero scale = zero if (( i <= m ) . and . ( i /= n )) then scale = sum ( abs ( opt_u ( i , l : n ))) if ( scale /= zero ) then opt_u ( i , l : n ) = opt_u ( i , l : n ) / scale s = sum ( opt_u ( i , l : n ) ** 2 ) f = opt_u ( i , l ) g = - sign ( sqrt ( s ), f ) h = f * g - s opt_u ( i , l ) = f - g rv1 ( l : n ) = opt_u ( i , l : n ) / h if ( i /= m ) then do j = l , m s = dot_product ( opt_u ( j , l : n ), opt_u ( i , l : n )) opt_u ( j , l : n ) = opt_u ( j , l : n ) + s * rv1 ( l : n ) end do end if opt_u ( i , l : n ) = scale * opt_u ( i , l : n ) end if end if x = max ( x , abs ( w ( i )) + abs ( rv1 ( i ))) end do ! Accumulation of right-hand transformations !============================================ if ( outv ) then do i = n , 1 , - 1 if ( i /= n ) then if ( g /= zero ) then opt_v ( l : n , i ) = ( opt_u ( i , l : n ) / opt_u ( i , l )) / g do j = l , n s = dot_product ( opt_u ( i , l : n ), opt_v ( l : n , j )) opt_v ( l : n , j ) = opt_v ( l : n , j ) + s * opt_v ( l : n , i ) end do end if opt_v ( i , l : n ) = zero opt_v ( l : n , i ) = zero end if opt_v ( i , i ) = one g = rv1 ( i ) l = i end do end if ! Accumulation of left-hand transformations !=========================================== if ( outu ) then mn = min ( m , n ) do i = min ( m , n ), 1 , - 1 l = i + 1 g = w ( i ) if ( i /= n ) opt_u ( i , l : n ) = zero if ( g /= zero ) then if ( i /= mn ) then do j = l , n s = dot_product ( opt_u ( l : m , i ), opt_u ( l : m , j )) f = ( s / opt_u ( i , i )) / g opt_u ( i : m , j ) = opt_u ( i : m , j ) + f * opt_u ( i : m , i ) end do end if opt_u ( i : m , i ) = opt_u ( i : m , i ) / g else opt_u ( i : m , i ) = zero end if opt_u ( i , i ) = opt_u ( i , i ) + one end do end if ! Diagonalization of the bidiagonal form !======================================== tst1 = x do kk = 1 , n k1 = n - kk k = k1 + 1 its = 0 ! Test for splitting !==================== 520 continue do ll = 1 , k l1 = k - ll l = l1 + 1 tst2 = tst1 + abs ( rv1 ( l )) if ( tst2 == tst1 ) goto 565 tst2 = tst1 + abs ( w ( l1 )) if ( tst2 == tst1 ) exit end do ! Cancellation of rv1(l) if L greater than 1 !============================================ c = zero s = one do i = l , k f = s * rv1 ( i ) rv1 ( i ) = c * rv1 ( i ) tst2 = tst1 + abs ( f ) if ( tst2 == tst1 ) goto 565 g = w ( i ) h = pythag_sp ( f , g ) w ( i ) = h c = g / h s = - f / h if ( outu ) then do j = 1 , m y = opt_u ( j , l1 ) z = opt_u ( j , i ) opt_u ( j , l1 ) = y * c + z * s opt_u ( j , i ) = - y * s + z * c end do end if end do ! Test for convergence !====================== 565 continue z = w ( k ) if ( l == k ) goto 650 ! Shift from bottom 2 by 2 minor !================================ if ( its >= 30 ) then if ( outierr ) ierr = k return end if its = its + 1 x = w ( l ) y = w ( k1 ) g = rv1 ( k1 ) h = rv1 ( k ) f = one / 2 * ((( g + z ) / h ) * (( g - z ) / y ) + y / h - h / y ) g = pythag_sp ( f , one ) f = x - ( z / x ) * z + ( h / x ) * ( y / ( f + sign ( g , f )) - h ) ! Next QR transformation !======================== c = one s = one do i1 = l , k1 i = i1 + 1 g = rv1 ( i ) y = w ( i ) h = s * g g = c * g z = pythag_sp ( f , h ) rv1 ( i1 ) = z c = f / z s = h / z f = x * c + g * s g = - x * s + g * c h = y * s y = y * c if ( outv ) then do j = 1 , n x = opt_v ( j , i1 ) z = opt_v ( j , i ) opt_v ( j , i1 ) = x * c + z * s opt_v ( j , i ) = - x * s + z * c end do end if z = pythag_sp ( f , h ) w ( i1 ) = z ! Rotation can be arbitrary if Z is zero !======================================== if ( z /= zero ) then c = f / z s = h / z end if f = c * g + s * y x = - s * g + c * y if ( outu ) then do j = 1 , m y = opt_u ( j , i1 ) z = opt_u ( j , i ) opt_u ( j , i1 ) = y * c + z * s opt_u ( j , i ) = - y * s + z * c end do end if end do rv1 ( l ) = zero rv1 ( k ) = f w ( k ) = x go to 520 ! Convergence !============= 650 continue if ( z <= zero ) then w ( k ) = - z if ( outv ) then opt_v ( 1 : n , k ) = - opt_v ( 1 : n , k ) end if end if end do ! Sort singular values !====================== if ( opt_d ) then idx = argsort ( w , 2 ) w = w ( idx ) if ( present ( u )) u = opt_u (:, idx ) if ( present ( v )) v = opt_v (:, idx ) else if ( present ( u )) u = opt_u if ( present ( v )) v = opt_v end if return end procedure svd_sp function pythag_sp ( x1 , x2 ) result ( pythag ) real ( sp ) , intent ( in ) :: x1 , x2 real ( sp ) :: r , s , t , u real ( sp ) :: pythag real ( sp ), parameter :: zero = 0.0_sp , one = 1.0_sp pythag = max ( abs ( x1 ), abs ( x2 )) if ( pythag /= zero ) then r = ( min ( abs ( x1 ), abs ( x2 )) / pythag ) ** 2 do t = 4 * one + r if ( t == 4 * one ) exit s = r / t u = one + 2 * s pythag = u * pythag r = ( s / u ) ** 2 * r end do end if return end function pythag_sp module procedure svd_dp integer :: m , n , i , its , i1 , j , k , kk , k1 , l , ll , l1 , mn integer , dimension (:), allocatable :: idx real ( dp ) :: c , f , g , h , s , scale , tst1 , tst2 , x , y , z real ( dp ), dimension (:), allocatable :: rv1 real ( dp ), dimension (:, :), allocatable :: opt_u , opt_v logical :: outu , outv , opt_d , outierr real ( dp ), parameter :: zero = 0.0_dp , one = 1.0_dp outu = . false . outv = . false . opt_d = . true . outierr = . false . m = size ( a , 1 ) n = size ( a , 2 ) if (. not . allocated ( w )) allocate ( w ( n )) allocate ( rv1 ( n ), opt_u ( m , n ), opt_v ( n , n )) opt_u = a if ( present ( d )) opt_d = d if ( present ( u )) outu = . true . if ( present ( v )) outv = . true . if ( present ( ierr )) outierr = . true . ! Householder reduction to bidiagonal form !========================================== g = zero scale = zero x = zero do i = 1 , n l = i + 1 rv1 ( i ) = scale * g g = zero s = zero scale = zero if ( i <= m ) then scale = sum ( abs ( opt_u ( i : m , i ))) if ( scale /= zero ) then opt_u ( i : m , i ) = opt_u ( i : m , i ) / scale s = sum ( opt_u ( i : m , i ) ** 2 ) f = opt_u ( i , i ) g = - sign ( sqrt ( s ), f ) h = f * g - s opt_u ( i , i ) = f - g if ( i /= n ) then do j = l , n s = dot_product ( opt_u ( i : m , i ), opt_u ( i : m , j )) opt_u ( i : m , j ) = opt_u ( i : m , j ) + s * opt_u ( i : m , i ) / h end do end if opt_u ( i : m , i ) = scale * opt_u ( i : m , i ) end if end if w ( i ) = scale * g g = zero s = zero scale = zero if (( i <= m ) . and . ( i /= n )) then scale = sum ( abs ( opt_u ( i , l : n ))) if ( scale /= zero ) then opt_u ( i , l : n ) = opt_u ( i , l : n ) / scale s = sum ( opt_u ( i , l : n ) ** 2 ) f = opt_u ( i , l ) g = - sign ( sqrt ( s ), f ) h = f * g - s opt_u ( i , l ) = f - g rv1 ( l : n ) = opt_u ( i , l : n ) / h if ( i /= m ) then do j = l , m s = dot_product ( opt_u ( j , l : n ), opt_u ( i , l : n )) opt_u ( j , l : n ) = opt_u ( j , l : n ) + s * rv1 ( l : n ) end do end if opt_u ( i , l : n ) = scale * opt_u ( i , l : n ) end if end if x = max ( x , abs ( w ( i )) + abs ( rv1 ( i ))) end do ! Accumulation of right-hand transformations !============================================ if ( outv ) then do i = n , 1 , - 1 if ( i /= n ) then if ( g /= zero ) then opt_v ( l : n , i ) = ( opt_u ( i , l : n ) / opt_u ( i , l )) / g do j = l , n s = dot_product ( opt_u ( i , l : n ), opt_v ( l : n , j )) opt_v ( l : n , j ) = opt_v ( l : n , j ) + s * opt_v ( l : n , i ) end do end if opt_v ( i , l : n ) = zero opt_v ( l : n , i ) = zero end if opt_v ( i , i ) = one g = rv1 ( i ) l = i end do end if ! Accumulation of left-hand transformations !=========================================== if ( outu ) then mn = min ( m , n ) do i = min ( m , n ), 1 , - 1 l = i + 1 g = w ( i ) if ( i /= n ) opt_u ( i , l : n ) = zero if ( g /= zero ) then if ( i /= mn ) then do j = l , n s = dot_product ( opt_u ( l : m , i ), opt_u ( l : m , j )) f = ( s / opt_u ( i , i )) / g opt_u ( i : m , j ) = opt_u ( i : m , j ) + f * opt_u ( i : m , i ) end do end if opt_u ( i : m , i ) = opt_u ( i : m , i ) / g else opt_u ( i : m , i ) = zero end if opt_u ( i , i ) = opt_u ( i , i ) + one end do end if ! Diagonalization of the bidiagonal form !======================================== tst1 = x do kk = 1 , n k1 = n - kk k = k1 + 1 its = 0 ! Test for splitting !==================== 520 continue do ll = 1 , k l1 = k - ll l = l1 + 1 tst2 = tst1 + abs ( rv1 ( l )) if ( tst2 == tst1 ) goto 565 tst2 = tst1 + abs ( w ( l1 )) if ( tst2 == tst1 ) exit end do ! Cancellation of rv1(l) if L greater than 1 !============================================ c = zero s = one do i = l , k f = s * rv1 ( i ) rv1 ( i ) = c * rv1 ( i ) tst2 = tst1 + abs ( f ) if ( tst2 == tst1 ) goto 565 g = w ( i ) h = pythag_dp ( f , g ) w ( i ) = h c = g / h s = - f / h if ( outu ) then do j = 1 , m y = opt_u ( j , l1 ) z = opt_u ( j , i ) opt_u ( j , l1 ) = y * c + z * s opt_u ( j , i ) = - y * s + z * c end do end if end do ! Test for convergence !====================== 565 continue z = w ( k ) if ( l == k ) goto 650 ! Shift from bottom 2 by 2 minor !================================ if ( its >= 30 ) then if ( outierr ) ierr = k return end if its = its + 1 x = w ( l ) y = w ( k1 ) g = rv1 ( k1 ) h = rv1 ( k ) f = one / 2 * ((( g + z ) / h ) * (( g - z ) / y ) + y / h - h / y ) g = pythag_dp ( f , one ) f = x - ( z / x ) * z + ( h / x ) * ( y / ( f + sign ( g , f )) - h ) ! Next QR transformation !======================== c = one s = one do i1 = l , k1 i = i1 + 1 g = rv1 ( i ) y = w ( i ) h = s * g g = c * g z = pythag_dp ( f , h ) rv1 ( i1 ) = z c = f / z s = h / z f = x * c + g * s g = - x * s + g * c h = y * s y = y * c if ( outv ) then do j = 1 , n x = opt_v ( j , i1 ) z = opt_v ( j , i ) opt_v ( j , i1 ) = x * c + z * s opt_v ( j , i ) = - x * s + z * c end do end if z = pythag_dp ( f , h ) w ( i1 ) = z ! Rotation can be arbitrary if Z is zero !======================================== if ( z /= zero ) then c = f / z s = h / z end if f = c * g + s * y x = - s * g + c * y if ( outu ) then do j = 1 , m y = opt_u ( j , i1 ) z = opt_u ( j , i ) opt_u ( j , i1 ) = y * c + z * s opt_u ( j , i ) = - y * s + z * c end do end if end do rv1 ( l ) = zero rv1 ( k ) = f w ( k ) = x go to 520 ! Convergence !============= 650 continue if ( z <= zero ) then w ( k ) = - z if ( outv ) then opt_v ( 1 : n , k ) = - opt_v ( 1 : n , k ) end if end if end do ! Sort singular values !====================== if ( opt_d ) then idx = argsort ( w , 2 ) w = w ( idx ) if ( present ( u )) u = opt_u (:, idx ) if ( present ( v )) v = opt_v (:, idx ) else if ( present ( u )) u = opt_u if ( present ( v )) v = opt_v end if return end procedure svd_dp function pythag_dp ( x1 , x2 ) result ( pythag ) real ( dp ) , intent ( in ) :: x1 , x2 real ( dp ) :: r , s , t , u real ( dp ) :: pythag real ( dp ), parameter :: zero = 0.0_dp , one = 1.0_dp pythag = max ( abs ( x1 ), abs ( x2 )) if ( pythag /= zero ) then r = ( min ( abs ( x1 ), abs ( x2 )) / pythag ) ** 2 do t = 4 * one + r if ( t == 4 * one ) exit s = r / t u = one + 2 * s pythag = u * pythag r = ( s / u ) ** 2 * r end do end if return end function pythag_dp module procedure svd_qp integer :: m , n , i , its , i1 , j , k , kk , k1 , l , ll , l1 , mn integer , dimension (:), allocatable :: idx real ( qp ) :: c , f , g , h , s , scale , tst1 , tst2 , x , y , z real ( qp ), dimension (:), allocatable :: rv1 real ( qp ), dimension (:, :), allocatable :: opt_u , opt_v logical :: outu , outv , opt_d , outierr real ( qp ), parameter :: zero = 0.0_qp , one = 1.0_qp outu = . false . outv = . false . opt_d = . true . outierr = . false . m = size ( a , 1 ) n = size ( a , 2 ) if (. not . allocated ( w )) allocate ( w ( n )) allocate ( rv1 ( n ), opt_u ( m , n ), opt_v ( n , n )) opt_u = a if ( present ( d )) opt_d = d if ( present ( u )) outu = . true . if ( present ( v )) outv = . true . if ( present ( ierr )) outierr = . true . ! Householder reduction to bidiagonal form !========================================== g = zero scale = zero x = zero do i = 1 , n l = i + 1 rv1 ( i ) = scale * g g = zero s = zero scale = zero if ( i <= m ) then scale = sum ( abs ( opt_u ( i : m , i ))) if ( scale /= zero ) then opt_u ( i : m , i ) = opt_u ( i : m , i ) / scale s = sum ( opt_u ( i : m , i ) ** 2 ) f = opt_u ( i , i ) g = - sign ( sqrt ( s ), f ) h = f * g - s opt_u ( i , i ) = f - g if ( i /= n ) then do j = l , n s = dot_product ( opt_u ( i : m , i ), opt_u ( i : m , j )) opt_u ( i : m , j ) = opt_u ( i : m , j ) + s * opt_u ( i : m , i ) / h end do end if opt_u ( i : m , i ) = scale * opt_u ( i : m , i ) end if end if w ( i ) = scale * g g = zero s = zero scale = zero if (( i <= m ) . and . ( i /= n )) then scale = sum ( abs ( opt_u ( i , l : n ))) if ( scale /= zero ) then opt_u ( i , l : n ) = opt_u ( i , l : n ) / scale s = sum ( opt_u ( i , l : n ) ** 2 ) f = opt_u ( i , l ) g = - sign ( sqrt ( s ), f ) h = f * g - s opt_u ( i , l ) = f - g rv1 ( l : n ) = opt_u ( i , l : n ) / h if ( i /= m ) then do j = l , m s = dot_product ( opt_u ( j , l : n ), opt_u ( i , l : n )) opt_u ( j , l : n ) = opt_u ( j , l : n ) + s * rv1 ( l : n ) end do end if opt_u ( i , l : n ) = scale * opt_u ( i , l : n ) end if end if x = max ( x , abs ( w ( i )) + abs ( rv1 ( i ))) end do ! Accumulation of right-hand transformations !============================================ if ( outv ) then do i = n , 1 , - 1 if ( i /= n ) then if ( g /= zero ) then opt_v ( l : n , i ) = ( opt_u ( i , l : n ) / opt_u ( i , l )) / g do j = l , n s = dot_product ( opt_u ( i , l : n ), opt_v ( l : n , j )) opt_v ( l : n , j ) = opt_v ( l : n , j ) + s * opt_v ( l : n , i ) end do end if opt_v ( i , l : n ) = zero opt_v ( l : n , i ) = zero end if opt_v ( i , i ) = one g = rv1 ( i ) l = i end do end if ! Accumulation of left-hand transformations !=========================================== if ( outu ) then mn = min ( m , n ) do i = min ( m , n ), 1 , - 1 l = i + 1 g = w ( i ) if ( i /= n ) opt_u ( i , l : n ) = zero if ( g /= zero ) then if ( i /= mn ) then do j = l , n s = dot_product ( opt_u ( l : m , i ), opt_u ( l : m , j )) f = ( s / opt_u ( i , i )) / g opt_u ( i : m , j ) = opt_u ( i : m , j ) + f * opt_u ( i : m , i ) end do end if opt_u ( i : m , i ) = opt_u ( i : m , i ) / g else opt_u ( i : m , i ) = zero end if opt_u ( i , i ) = opt_u ( i , i ) + one end do end if ! Diagonalization of the bidiagonal form !======================================== tst1 = x do kk = 1 , n k1 = n - kk k = k1 + 1 its = 0 ! Test for splitting !==================== 520 continue do ll = 1 , k l1 = k - ll l = l1 + 1 tst2 = tst1 + abs ( rv1 ( l )) if ( tst2 == tst1 ) goto 565 tst2 = tst1 + abs ( w ( l1 )) if ( tst2 == tst1 ) exit end do ! Cancellation of rv1(l) if L greater than 1 !============================================ c = zero s = one do i = l , k f = s * rv1 ( i ) rv1 ( i ) = c * rv1 ( i ) tst2 = tst1 + abs ( f ) if ( tst2 == tst1 ) goto 565 g = w ( i ) h = pythag_qp ( f , g ) w ( i ) = h c = g / h s = - f / h if ( outu ) then do j = 1 , m y = opt_u ( j , l1 ) z = opt_u ( j , i ) opt_u ( j , l1 ) = y * c + z * s opt_u ( j , i ) = - y * s + z * c end do end if end do ! Test for convergence !====================== 565 continue z = w ( k ) if ( l == k ) goto 650 ! Shift from bottom 2 by 2 minor !================================ if ( its >= 30 ) then if ( outierr ) ierr = k return end if its = its + 1 x = w ( l ) y = w ( k1 ) g = rv1 ( k1 ) h = rv1 ( k ) f = one / 2 * ((( g + z ) / h ) * (( g - z ) / y ) + y / h - h / y ) g = pythag_qp ( f , one ) f = x - ( z / x ) * z + ( h / x ) * ( y / ( f + sign ( g , f )) - h ) ! Next QR transformation !======================== c = one s = one do i1 = l , k1 i = i1 + 1 g = rv1 ( i ) y = w ( i ) h = s * g g = c * g z = pythag_qp ( f , h ) rv1 ( i1 ) = z c = f / z s = h / z f = x * c + g * s g = - x * s + g * c h = y * s y = y * c if ( outv ) then do j = 1 , n x = opt_v ( j , i1 ) z = opt_v ( j , i ) opt_v ( j , i1 ) = x * c + z * s opt_v ( j , i ) = - x * s + z * c end do end if z = pythag_qp ( f , h ) w ( i1 ) = z ! Rotation can be arbitrary if Z is zero !======================================== if ( z /= zero ) then c = f / z s = h / z end if f = c * g + s * y x = - s * g + c * y if ( outu ) then do j = 1 , m y = opt_u ( j , i1 ) z = opt_u ( j , i ) opt_u ( j , i1 ) = y * c + z * s opt_u ( j , i ) = - y * s + z * c end do end if end do rv1 ( l ) = zero rv1 ( k ) = f w ( k ) = x go to 520 ! Convergence !============= 650 continue if ( z <= zero ) then w ( k ) = - z if ( outv ) then opt_v ( 1 : n , k ) = - opt_v ( 1 : n , k ) end if end if end do ! Sort singular values !====================== if ( opt_d ) then idx = argsort ( w , 2 ) w = w ( idx ) if ( present ( u )) u = opt_u (:, idx ) if ( present ( v )) v = opt_v (:, idx ) else if ( present ( u )) u = opt_u if ( present ( v )) v = opt_v end if return end procedure svd_qp function pythag_qp ( x1 , x2 ) result ( pythag ) real ( qp ) , intent ( in ) :: x1 , x2 real ( qp ) :: r , s , t , u real ( qp ) :: pythag real ( qp ), parameter :: zero = 0.0_qp , one = 1.0_qp pythag = max ( abs ( x1 ), abs ( x2 )) if ( pythag /= zero ) then r = ( min ( abs ( x1 ), abs ( x2 )) / pythag ) ** 2 do t = 4 * one + r if ( t == 4 * one ) exit s = r / t u = one + 2 * s pythag = u * pythag r = ( s / u ) ** 2 * r end do end if return end function pythag_qp end submodule forlab_linalg_svd","tags":"","loc":"sourcefile/forlab_linalg_svd.f90.html"},{"title":"forlab_linalg_tri.f90 – FORLAB","text":"Contents Submodules forlab_linalg_tri Source Code forlab_linalg_tri.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_tri implicit none contains module procedure tril_int8 integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) tril_int8 = A do i = 1 , min ( m , n ) tril_int8 (: i - opt_k - 1 , i ) = 0_int8 end do end procedure tril_int8 module procedure tril_int16 integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) tril_int16 = A do i = 1 , min ( m , n ) tril_int16 (: i - opt_k - 1 , i ) = 0_int16 end do end procedure tril_int16 module procedure tril_int32 integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) tril_int32 = A do i = 1 , min ( m , n ) tril_int32 (: i - opt_k - 1 , i ) = 0_int32 end do end procedure tril_int32 module procedure tril_int64 integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) tril_int64 = A do i = 1 , min ( m , n ) tril_int64 (: i - opt_k - 1 , i ) = 0_int64 end do end procedure tril_int64 module procedure tril_sp integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) tril_sp = A do i = 1 , min ( m , n ) tril_sp (: i - opt_k - 1 , i ) = 0.0_sp end do end procedure tril_sp module procedure tril_dp integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) tril_dp = A do i = 1 , min ( m , n ) tril_dp (: i - opt_k - 1 , i ) = 0.0_dp end do end procedure tril_dp module procedure tril_qp integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) tril_qp = A do i = 1 , min ( m , n ) tril_qp (: i - opt_k - 1 , i ) = 0.0_qp end do end procedure tril_qp module procedure tril_csp integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) tril_csp = A do i = 1 , min ( m , n ) tril_csp (: i - opt_k - 1 , i ) = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) end do end procedure tril_csp module procedure tril_cdp integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) tril_cdp = A do i = 1 , min ( m , n ) tril_cdp (: i - opt_k - 1 , i ) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) end do end procedure tril_cdp module procedure tril_cqp integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) tril_cqp = A do i = 1 , min ( m , n ) tril_cqp (: i - opt_k - 1 , i ) = cmplx ( 0.0_qp , 0.0_qp , kind = qp ) end do end procedure tril_cqp module procedure triu_int8 integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) triu_int8 = A do i = 1 , min ( m , n ) triu_int8 ( i - opt_k + 1 :, i ) = 0_int8 end do end procedure triu_int8 module procedure triu_int16 integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) triu_int16 = A do i = 1 , min ( m , n ) triu_int16 ( i - opt_k + 1 :, i ) = 0_int16 end do end procedure triu_int16 module procedure triu_int32 integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) triu_int32 = A do i = 1 , min ( m , n ) triu_int32 ( i - opt_k + 1 :, i ) = 0_int32 end do end procedure triu_int32 module procedure triu_int64 integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) triu_int64 = A do i = 1 , min ( m , n ) triu_int64 ( i - opt_k + 1 :, i ) = 0_int64 end do end procedure triu_int64 module procedure triu_sp integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) triu_sp = A do i = 1 , min ( m , n ) triu_sp ( i - opt_k + 1 :, i ) = 0.0_sp end do end procedure triu_sp module procedure triu_dp integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) triu_dp = A do i = 1 , min ( m , n ) triu_dp ( i - opt_k + 1 :, i ) = 0.0_dp end do end procedure triu_dp module procedure triu_qp integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) triu_qp = A do i = 1 , min ( m , n ) triu_qp ( i - opt_k + 1 :, i ) = 0.0_qp end do end procedure triu_qp module procedure triu_csp integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) triu_csp = A do i = 1 , min ( m , n ) triu_csp ( i - opt_k + 1 :, i ) = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) end do end procedure triu_csp module procedure triu_cdp integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) triu_cdp = A do i = 1 , min ( m , n ) triu_cdp ( i - opt_k + 1 :, i ) = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) end do end procedure triu_cdp module procedure triu_cqp integer :: opt_k , i , m , n opt_k = 0 if ( present ( k )) opt_k = k m = size ( A , 1 ) n = size ( A , 2 ) triu_cqp = A do i = 1 , min ( m , n ) triu_cqp ( i - opt_k + 1 :, i ) = cmplx ( 0.0_qp , 0.0_qp , kind = qp ) end do end procedure triu_cqp end submodule forlab_linalg_tri","tags":"","loc":"sourcefile/forlab_linalg_tri.f90.html"},{"title":"forlab_linalg_linspace.f90 – FORLAB","text":"Contents Submodules forlab_linalg_linspace Source Code forlab_linalg_linspace.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_linspace implicit none contains module procedure linspace_sp integer :: i , n real ( sp ) :: by n = size ( X ) by = ( to - from ) / real ( n - 1 , sp ) X = from + by * real ([( i - 1 , i = 1 , n )], sp ) return end procedure linspace_sp module procedure logspace_sp call linspace ( X , log10 ( from ), log10 ( to )) X = 1 0._sp ** X return end procedure logspace_sp module procedure linspace_dp integer :: i , n real ( dp ) :: by n = size ( X ) by = ( to - from ) / real ( n - 1 , dp ) X = from + by * real ([( i - 1 , i = 1 , n )], dp ) return end procedure linspace_dp module procedure logspace_dp call linspace ( X , log10 ( from ), log10 ( to )) X = 1 0._dp ** X return end procedure logspace_dp module procedure linspace_qp integer :: i , n real ( qp ) :: by n = size ( X ) by = ( to - from ) / real ( n - 1 , qp ) X = from + by * real ([( i - 1 , i = 1 , n )], qp ) return end procedure linspace_qp module procedure logspace_qp call linspace ( X , log10 ( from ), log10 ( to )) X = 1 0._qp ** X return end procedure logspace_qp end submodule forlab_linalg_linspace","tags":"","loc":"sourcefile/forlab_linalg_linspace.f90.html"},{"title":"forlab_linalg_norm.f90 – FORLAB","text":"Contents Submodules forlab_linalg_norm Source Code forlab_linalg_norm.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_norm use forlab_linalg , only : svd implicit none contains module procedure norm1_sp real ( sp ) :: temp if (. not . present ( p )) then temp = 2.0_sp else temp = p end if if ( temp == 2.0_sp ) then norm1 = sqrt ( sum ( abs ( x ) ** 2 )) elseif ( temp == 1.0_sp ) then norm1 = sum ( abs ( x )) else norm1 = ( sum ( abs ( x ) ** p )) ** ( 1.0_sp / p ) end if end procedure norm1_sp module procedure norm2_sp real ( sp ) :: temp real ( sp ), dimension (:), allocatable :: w if (. not . present ( p )) then temp = 2.0_sp else temp = p end if if ( temp == 2.0_sp ) then call svd ( A , w ) norm2 = maxval ( w ) elseif ( temp == 1.0_sp ) then norm2 = maxval ( sum ( abs ( A ), dim = 2 )) end if end procedure norm2_sp module procedure norm1_dp real ( dp ) :: temp if (. not . present ( p )) then temp = 2.0_dp else temp = p end if if ( temp == 2.0_dp ) then norm1 = sqrt ( sum ( abs ( x ) ** 2 )) elseif ( temp == 1.0_dp ) then norm1 = sum ( abs ( x )) else norm1 = ( sum ( abs ( x ) ** p )) ** ( 1.0_dp / p ) end if end procedure norm1_dp module procedure norm2_dp real ( dp ) :: temp real ( dp ), dimension (:), allocatable :: w if (. not . present ( p )) then temp = 2.0_dp else temp = p end if if ( temp == 2.0_dp ) then call svd ( A , w ) norm2 = maxval ( w ) elseif ( temp == 1.0_dp ) then norm2 = maxval ( sum ( abs ( A ), dim = 2 )) end if end procedure norm2_dp module procedure norm1_qp real ( qp ) :: temp if (. not . present ( p )) then temp = 2.0_qp else temp = p end if if ( temp == 2.0_qp ) then norm1 = sqrt ( sum ( abs ( x ) ** 2 )) elseif ( temp == 1.0_qp ) then norm1 = sum ( abs ( x )) else norm1 = ( sum ( abs ( x ) ** p )) ** ( 1.0_qp / p ) end if end procedure norm1_qp module procedure norm2_qp real ( qp ) :: temp real ( qp ), dimension (:), allocatable :: w if (. not . present ( p )) then temp = 2.0_qp else temp = p end if if ( temp == 2.0_qp ) then call svd ( A , w ) norm2 = maxval ( w ) elseif ( temp == 1.0_qp ) then norm2 = maxval ( sum ( abs ( A ), dim = 2 )) end if end procedure norm2_qp end submodule forlab_linalg_norm","tags":"","loc":"sourcefile/forlab_linalg_norm.f90.html"},{"title":"forlab_sorting.f90 – FORLAB","text":"Contents Modules forlab_sorting Source Code forlab_sorting.f90 Source Code module forlab_sorting use stdlib_kinds , only : sp , dp , qp , & int8 , int16 , int32 , int64 use forlab_stats , only : randu implicit none private public :: argsort , sort interface argsort !! argsort generates the indices that would sort an array. module function argsort_int8 ( x , order ) integer , allocatable :: argsort_int8 (:) integer ( int8 ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function argsort_int8 module function argsort_int16 ( x , order ) integer , allocatable :: argsort_int16 (:) integer ( int16 ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function argsort_int16 module function argsort_int32 ( x , order ) integer , allocatable :: argsort_int32 (:) integer ( int32 ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function argsort_int32 module function argsort_int64 ( x , order ) integer , allocatable :: argsort_int64 (:) integer ( int64 ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function argsort_int64 module function argsort_sp ( x , order ) integer , allocatable :: argsort_sp (:) real ( sp ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function argsort_sp module function argsort_dp ( x , order ) integer , allocatable :: argsort_dp (:) real ( dp ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function argsort_dp module function argsort_qp ( x , order ) integer , allocatable :: argsort_qp (:) real ( qp ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function argsort_qp end interface argsort interface sort module function sort_int8 ( x , order ) integer ( int8 ), allocatable :: sort_int8 (:) integer ( int8 ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function sort_int8 module function sort_int16 ( x , order ) integer ( int16 ), allocatable :: sort_int16 (:) integer ( int16 ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function sort_int16 module function sort_int32 ( x , order ) integer ( int32 ), allocatable :: sort_int32 (:) integer ( int32 ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function sort_int32 module function sort_int64 ( x , order ) integer ( int64 ), allocatable :: sort_int64 (:) integer ( int64 ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function sort_int64 module function sort_sp ( x , order ) real ( sp ), allocatable :: sort_sp (:) real ( sp ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function sort_sp module function sort_dp ( x , order ) real ( dp ), allocatable :: sort_dp (:) real ( dp ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function sort_dp module function sort_qp ( x , order ) real ( qp ), allocatable :: sort_qp (:) real ( qp ), intent ( in ) :: x (:) integer , optional , intent ( in ) :: order end function sort_qp end interface sort end module forlab_sorting","tags":"","loc":"sourcefile/forlab_sorting.f90.html"},{"title":"forlab_stats_var.f90 – FORLAB","text":"Contents Submodules forlab_stats_var Source Code forlab_stats_var.f90 Source Code submodule ( forlab_stats ) forlab_stats_var implicit none contains module procedure var_1_sp integer :: opt_w opt_w = 0 if ( present ( w )) opt_w = w select case ( opt_w ) case ( 0 ) var_1_sp = sum (( x - mean ( x )) ** 2 ) / ( size ( x ) - 1 ) case ( 1 ) var_1_sp = sum (( x - mean ( x )) ** 2 ) / size ( x ) end select return end procedure var_1_sp module procedure var_2_sp integer :: opt_w , i , m , n opt_w = 0 if ( present ( w )) opt_w = w m = size ( A , 1 ) n = size ( A , 2 ) if ((. not . present ( dim )) . or . ( dim == 1 )) then allocate ( var_2_sp ( n )) do i = 1 , n var_2_sp ( i ) = var_1_sp ( A (:, i ), opt_w ) end do elseif ( dim == 2 ) then allocate ( var_2_sp ( m )) do i = 1 , m var_2_sp ( i ) = var_1_sp ( A ( i , :), opt_w ) end do end if return end procedure var_2_sp module procedure var_1_dp integer :: opt_w opt_w = 0 if ( present ( w )) opt_w = w select case ( opt_w ) case ( 0 ) var_1_dp = sum (( x - mean ( x )) ** 2 ) / ( size ( x ) - 1 ) case ( 1 ) var_1_dp = sum (( x - mean ( x )) ** 2 ) / size ( x ) end select return end procedure var_1_dp module procedure var_2_dp integer :: opt_w , i , m , n opt_w = 0 if ( present ( w )) opt_w = w m = size ( A , 1 ) n = size ( A , 2 ) if ((. not . present ( dim )) . or . ( dim == 1 )) then allocate ( var_2_dp ( n )) do i = 1 , n var_2_dp ( i ) = var_1_dp ( A (:, i ), opt_w ) end do elseif ( dim == 2 ) then allocate ( var_2_dp ( m )) do i = 1 , m var_2_dp ( i ) = var_1_dp ( A ( i , :), opt_w ) end do end if return end procedure var_2_dp module procedure var_1_qp integer :: opt_w opt_w = 0 if ( present ( w )) opt_w = w select case ( opt_w ) case ( 0 ) var_1_qp = sum (( x - mean ( x )) ** 2 ) / ( size ( x ) - 1 ) case ( 1 ) var_1_qp = sum (( x - mean ( x )) ** 2 ) / size ( x ) end select return end procedure var_1_qp module procedure var_2_qp integer :: opt_w , i , m , n opt_w = 0 if ( present ( w )) opt_w = w m = size ( A , 1 ) n = size ( A , 2 ) if ((. not . present ( dim )) . or . ( dim == 1 )) then allocate ( var_2_qp ( n )) do i = 1 , n var_2_qp ( i ) = var_1_qp ( A (:, i ), opt_w ) end do elseif ( dim == 2 ) then allocate ( var_2_qp ( m )) do i = 1 , m var_2_qp ( i ) = var_1_qp ( A ( i , :), opt_w ) end do end if return end procedure var_2_qp module procedure std_1_sp integer :: opt_w opt_w = 0 if ( present ( w )) opt_w = w std_1_sp = sqrt ( var_1_sp ( x , opt_w )) return end procedure std_1_sp module procedure std_2_sp integer :: opt_w opt_w = 0 if ( present ( w )) opt_w = w if (. not . present ( dim )) then std_2_sp = sqrt ( var_2_sp ( A , opt_w )) else std_2_sp = sqrt ( var_2_sp ( A , opt_w , dim )) end if return end procedure std_2_sp module procedure std_1_dp integer :: opt_w opt_w = 0 if ( present ( w )) opt_w = w std_1_dp = sqrt ( var_1_dp ( x , opt_w )) return end procedure std_1_dp module procedure std_2_dp integer :: opt_w opt_w = 0 if ( present ( w )) opt_w = w if (. not . present ( dim )) then std_2_dp = sqrt ( var_2_dp ( A , opt_w )) else std_2_dp = sqrt ( var_2_dp ( A , opt_w , dim )) end if return end procedure std_2_dp module procedure std_1_qp integer :: opt_w opt_w = 0 if ( present ( w )) opt_w = w std_1_qp = sqrt ( var_1_qp ( x , opt_w )) return end procedure std_1_qp module procedure std_2_qp integer :: opt_w opt_w = 0 if ( present ( w )) opt_w = w if (. not . present ( dim )) then std_2_qp = sqrt ( var_2_qp ( A , opt_w )) else std_2_qp = sqrt ( var_2_qp ( A , opt_w , dim )) end if return end procedure std_2_qp end submodule forlab_stats_var","tags":"","loc":"sourcefile/forlab_stats_var.f90.html"},{"title":"forlab_linalg_svdsolve.f90 – FORLAB","text":"Contents Submodules forlab_linalg_svdsolve Source Code forlab_linalg_svdsolve.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_svdsolve implicit none contains module procedure svdsolve_sp integer :: i , k , n real ( sp ), dimension (:), allocatable :: w , xnorm , resnorm real ( sp ), dimension (:, :), allocatable :: U , V n = size ( A , 2 ) k = n if ( present ( cutoff )) k = k - cutoff xnorm = zeros ( n ) resnorm = zeros ( n ) call svd ( A , w , U , V ) do i = 1 , n x = matmul ( matmul ( matmul ( V (:, : i ), diag ( 1 / w (: i ))), transpose ( U (:, : i ))), b ) xnorm ( i ) = norm ( x ) resnorm ( i ) = norm ( matmul ( A , x ) - b ) end do x = matmul ( matmul ( matmul ( V (:, : k ), diag ( 1 / w (: k ))), transpose ( U (:, : k ))), b ) end procedure svdsolve_sp module procedure svdsolve_dp integer :: i , k , n real ( dp ), dimension (:), allocatable :: w , xnorm , resnorm real ( dp ), dimension (:, :), allocatable :: U , V n = size ( A , 2 ) k = n if ( present ( cutoff )) k = k - cutoff xnorm = zeros ( n ) resnorm = zeros ( n ) call svd ( A , w , U , V ) do i = 1 , n x = matmul ( matmul ( matmul ( V (:, : i ), diag ( 1 / w (: i ))), transpose ( U (:, : i ))), b ) xnorm ( i ) = norm ( x ) resnorm ( i ) = norm ( matmul ( A , x ) - b ) end do x = matmul ( matmul ( matmul ( V (:, : k ), diag ( 1 / w (: k ))), transpose ( U (:, : k ))), b ) end procedure svdsolve_dp module procedure svdsolve_qp integer :: i , k , n real ( qp ), dimension (:), allocatable :: w , xnorm , resnorm real ( qp ), dimension (:, :), allocatable :: U , V n = size ( A , 2 ) k = n if ( present ( cutoff )) k = k - cutoff xnorm = zeros ( n ) resnorm = zeros ( n ) call svd ( A , w , U , V ) do i = 1 , n x = matmul ( matmul ( matmul ( V (:, : i ), diag ( 1 / w (: i ))), transpose ( U (:, : i ))), b ) xnorm ( i ) = norm ( x ) resnorm ( i ) = norm ( matmul ( A , x ) - b ) end do x = matmul ( matmul ( matmul ( V (:, : k ), diag ( 1 / w (: k ))), transpose ( U (:, : k ))), b ) end procedure svdsolve_qp end submodule forlab_linalg_svdsolve","tags":"","loc":"sourcefile/forlab_linalg_svdsolve.f90.html"},{"title":"forlab_linalg_lu.f90 – FORLAB","text":"Contents Submodules forlab_linalg_lu Source Code forlab_linalg_lu.f90 Source Code submodule ( forlab_linalg ) forlab_linalg_lu implicit none contains module procedure lu_sp integer :: i , j , k , m if ( is_square ( A )) then m = size ( A , 1 ) if (. not . allocated ( L )) then allocate ( L ( m , m )) call eye ( L ) endif if (. not . allocated ( U )) then U = zeros ( m , m ) endif do i = 1 , m do j = 1 , m U ( i , j ) = A ( i , j ) do k = 1 , i - 1 U ( i , j ) = U ( i , j ) - L ( i , k ) * U ( k , j ) end do end do do j = i + 1 , m L ( j , i ) = A ( j , i ) do k = 1 , i - 1 L ( j , i ) = L ( j , i ) - L ( j , k ) * U ( k , i ) end do L ( j , i ) = L ( j , i ) / U ( i , i ) end do end do else call error_stop ( \"Error: in A = LU, A should be square.\" ) end if return end procedure module procedure lu_dp integer :: i , j , k , m if ( is_square ( A )) then m = size ( A , 1 ) if (. not . allocated ( L )) then allocate ( L ( m , m )) call eye ( L ) endif if (. not . allocated ( U )) then U = zeros ( m , m ) endif do i = 1 , m do j = 1 , m U ( i , j ) = A ( i , j ) do k = 1 , i - 1 U ( i , j ) = U ( i , j ) - L ( i , k ) * U ( k , j ) end do end do do j = i + 1 , m L ( j , i ) = A ( j , i ) do k = 1 , i - 1 L ( j , i ) = L ( j , i ) - L ( j , k ) * U ( k , i ) end do L ( j , i ) = L ( j , i ) / U ( i , i ) end do end do else call error_stop ( \"Error: in A = LU, A should be square.\" ) end if return end procedure module procedure lu_qp integer :: i , j , k , m if ( is_square ( A )) then m = size ( A , 1 ) if (. not . allocated ( L )) then allocate ( L ( m , m )) call eye ( L ) endif if (. not . allocated ( U )) then U = zeros ( m , m ) endif do i = 1 , m do j = 1 , m U ( i , j ) = A ( i , j ) do k = 1 , i - 1 U ( i , j ) = U ( i , j ) - L ( i , k ) * U ( k , j ) end do end do do j = i + 1 , m L ( j , i ) = A ( j , i ) do k = 1 , i - 1 L ( j , i ) = L ( j , i ) - L ( j , k ) * U ( k , i ) end do L ( j , i ) = L ( j , i ) / U ( i , i ) end do end do else call error_stop ( \"Error: in A = LU, A should be square.\" ) end if return end procedure end submodule forlab_linalg_lu","tags":"","loc":"sourcefile/forlab_linalg_lu.f90.html"},{"title":"forlab_math_degcir.f90 – FORLAB","text":"Contents Submodules forlab_math_degcir Source Code forlab_math_degcir.f90 Source Code submodule ( forlab_math ) forlab_math_degcir implicit none real ( sp ), parameter :: pi_sp = acos ( - 1.0_sp ) real ( dp ), parameter :: pi_dp = acos ( - 1.0_dp ) real ( qp ), parameter :: pi_qp = acos ( - 1.0_qp ) contains module procedure acosd_sp acosd_sp = acos ( x ) * 180 / pi_sp end procedure module procedure acosd_dp acosd_dp = acos ( x ) * 180 / pi_dp end procedure module procedure acosd_qp acosd_qp = acos ( x ) * 180 / pi_qp end procedure module procedure asind_sp asind_sp = asin ( x ) * 180 / pi_sp end procedure module procedure asind_dp asind_dp = asin ( x ) * 180 / pi_dp end procedure module procedure asind_qp asind_qp = asin ( x ) * 180 / pi_qp end procedure module procedure atand_sp atand_sp = atan ( x ) * 180 / pi_sp end procedure module procedure atand_dp atand_dp = atan ( x ) * 180 / pi_dp end procedure module procedure atand_qp atand_qp = atan ( x ) * 180 / pi_qp end procedure module procedure cosd_sp cosd_sp = cos ( x * pi_sp / 180 ) end procedure module procedure cosd_dp cosd_dp = cos ( x * pi_dp / 180 ) end procedure module procedure cosd_qp cosd_qp = cos ( x * pi_qp / 180 ) end procedure module procedure sind_sp sind_sp = sin ( x * pi_sp / 180 ) end procedure module procedure sind_dp sind_dp = sin ( x * pi_dp / 180 ) end procedure module procedure sind_qp sind_qp = sin ( x * pi_qp / 180 ) end procedure module procedure tand_sp tand_sp = tan ( x * pi_sp / 180 ) end procedure module procedure tand_dp tand_dp = tan ( x * pi_dp / 180 ) end procedure module procedure tand_qp tand_qp = tan ( x * pi_qp / 180 ) end procedure end submodule forlab_math_degcir","tags":"","loc":"sourcefile/forlab_math_degcir.f90.html"},{"title":"file – FORLAB ","text":"type, public :: file forlab file derived type.\n( Specification ) Contents Constructor file Type-Bound Procedures close countlines exist open Source Code file Constructor public interface file private function init_file(filename, mode) File constructs a File object. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: mode Return Value type( file ) Type-Bound Procedures procedure, public :: close private subroutine close(self) close closes a file object, deallocate file%filename .\n( Specification ) Arguments Type Intent Optional Attributes Name class( file ), intent(inout) :: self procedure, public :: countlines => countlines1 private subroutine countlines1(self) countlines counts the number of lines in a txt file.\n( Specification ) Arguments Type Intent Optional Attributes Name class( file ), intent(inout) :: self procedure, public :: exist => file_exist1 private function file_exist1(self) result(result) file_exist determines whether a file object already exists.\n( Specification ) Arguments Type Intent Optional Attributes Name class( file ), intent(inout) :: self Return Value logical procedure, public :: open => open_file private subroutine open_file(self) Open the file. ( Specification ) Arguments Type Intent Optional Attributes Name class( file ), intent(inout) :: self Source Code type file character (:), allocatable :: filename character ( 3 ) :: mode integer :: unit integer :: lines contains procedure :: exist => file_exist1 procedure :: open => open_file procedure :: countlines => countlines1 procedure :: close end type file","tags":"","loc":"type/file.html"},{"title":"acosd – FORLAB","text":"public interface acosd degree circular functions Contents Functions acosd_dp acosd_qp acosd_sp Functions private pure elemental module function acosd_dp(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function acosd_qp(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private pure elemental module function acosd_sp(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp)","tags":"","loc":"interface/acosd.html"},{"title":"all_close – FORLAB","text":"public interface all_close Returns a boolean scalar where two arrays are element-wise equal within a tolerance.\n( Specification ) Contents Functions all_close_cdp all_close_cqp all_close_csp all_close_rdp all_close_rqp all_close_rsp Functions private module function all_close_cdp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: a (..) complex(kind=dp), intent(in) :: b (..) real(kind=dp), intent(in), optional :: rel_tol real(kind=dp), intent(in), optional :: abs_tol Return Value logical private module function all_close_cqp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: a (..) complex(kind=qp), intent(in) :: b (..) real(kind=qp), intent(in), optional :: rel_tol real(kind=qp), intent(in), optional :: abs_tol Return Value logical private module function all_close_csp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: a (..) complex(kind=sp), intent(in) :: b (..) real(kind=sp), intent(in), optional :: rel_tol real(kind=sp), intent(in), optional :: abs_tol Return Value logical private module function all_close_rdp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a (..) real(kind=dp), intent(in) :: b (..) real(kind=dp), intent(in), optional :: rel_tol real(kind=dp), intent(in), optional :: abs_tol Return Value logical private module function all_close_rqp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: a (..) real(kind=qp), intent(in) :: b (..) real(kind=qp), intent(in), optional :: rel_tol real(kind=qp), intent(in), optional :: abs_tol Return Value logical private module function all_close_rsp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a (..) real(kind=sp), intent(in) :: b (..) real(kind=sp), intent(in), optional :: rel_tol real(kind=sp), intent(in), optional :: abs_tol Return Value logical","tags":"","loc":"interface/all_close.html"},{"title":"angle – FORLAB","text":"public interface angle angle compute the phase angle.\n( Interface ) Contents Module Procedures angle_sp angle_dp angle_qp Module Procedures private elemental function angle_sp(value) result(angle) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: value Return Value real(kind=sp) private elemental function angle_dp(value) result(angle) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: value Return Value real(kind=dp) private elemental function angle_qp(value) result(angle) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: value Return Value real(kind=qp)","tags":"","loc":"interface/angle.html"},{"title":"arange – FORLAB","text":"public interface arange arange creates a rank-1 array of the integer/real type \n with fixed-spaced values of given spacing, within a given interval.\n( Specification ) Contents Functions arange_i_int16 arange_i_int32 arange_i_int64 arange_i_int8 arange_r_dp arange_r_qp arange_r_sp Functions private pure module function arange_i_int16(start, end, step) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: start integer(kind=int16), intent(in), optional :: end integer(kind=int16), intent(in), optional :: step Return Value integer(kind=int16),\n  allocatable, (:) private pure module function arange_i_int32(start, end, step) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: start integer(kind=int32), intent(in), optional :: end integer(kind=int32), intent(in), optional :: step Return Value integer(kind=int32),\n  allocatable, (:) private pure module function arange_i_int64(start, end, step) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: start integer(kind=int64), intent(in), optional :: end integer(kind=int64), intent(in), optional :: step Return Value integer(kind=int64),\n  allocatable, (:) private pure module function arange_i_int8(start, end, step) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: start integer(kind=int8), intent(in), optional :: end integer(kind=int8), intent(in), optional :: step Return Value integer(kind=int8),\n  allocatable, (:) private pure module function arange_r_dp(start, end, step) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in), optional :: end real(kind=dp), intent(in), optional :: step Return Value real(kind=dp),\n  allocatable, (:) private pure module function arange_r_qp(start, end, step) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in), optional :: end real(kind=qp), intent(in), optional :: step Return Value real(kind=qp),\n  allocatable, (:) private pure module function arange_r_sp(start, end, step) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in), optional :: end real(kind=sp), intent(in), optional :: step Return Value real(kind=sp),\n  allocatable, (:)","tags":"","loc":"interface/arange.html"},{"title":"asind – FORLAB","text":"public interface asind degree circular functions Contents Functions asind_dp asind_qp asind_sp Functions private pure elemental module function asind_dp(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function asind_qp(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private pure elemental module function asind_sp(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp)","tags":"","loc":"interface/asind.html"},{"title":"atand – FORLAB","text":"public interface atand degree circular functions Contents Functions atand_dp atand_qp atand_sp Functions private pure elemental module function atand_dp(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function atand_qp(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private pure elemental module function atand_sp(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp)","tags":"","loc":"interface/atand.html"},{"title":"cosd – FORLAB","text":"public interface cosd Contents Functions cosd_dp cosd_qp cosd_sp Functions private pure elemental module function cosd_dp(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function cosd_qp(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private pure elemental module function cosd_sp(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp)","tags":"","loc":"interface/cosd.html"},{"title":"is_close – FORLAB","text":"public interface is_close Returns a boolean scalar/array where two scalar/arrays are element-wise equal within a tolerance.\n( Specification ) Contents Functions is_close_cdp is_close_cqp is_close_csp is_close_rdp is_close_rqp is_close_rsp Functions private elemental module function is_close_cdp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: a complex(kind=dp), intent(in) :: b real(kind=dp), intent(in), optional :: rel_tol real(kind=dp), intent(in), optional :: abs_tol Return Value logical private elemental module function is_close_cqp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: a complex(kind=qp), intent(in) :: b real(kind=qp), intent(in), optional :: rel_tol real(kind=qp), intent(in), optional :: abs_tol Return Value logical private elemental module function is_close_csp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: a complex(kind=sp), intent(in) :: b real(kind=sp), intent(in), optional :: rel_tol real(kind=sp), intent(in), optional :: abs_tol Return Value logical private elemental module function is_close_rdp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b real(kind=dp), intent(in), optional :: rel_tol real(kind=dp), intent(in), optional :: abs_tol Return Value logical private elemental module function is_close_rqp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: a real(kind=qp), intent(in) :: b real(kind=qp), intent(in), optional :: rel_tol real(kind=qp), intent(in), optional :: abs_tol Return Value logical private elemental module function is_close_rsp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a real(kind=sp), intent(in) :: b real(kind=sp), intent(in), optional :: rel_tol real(kind=sp), intent(in), optional :: abs_tol Return Value logical","tags":"","loc":"interface/is_close.html"},{"title":"signum – FORLAB","text":"public interface signum signum returns the sign of variables.\n( Specification ) Contents Functions signum_cdp signum_cqp signum_csp signum_iint16 signum_iint32 signum_iint64 signum_iint8 signum_rdp signum_rqp signum_rsp Functions private elemental module function signum_cdp(x) result(sign) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x Return Value complex(kind=dp) private elemental module function signum_cqp(x) result(sign) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x Return Value complex(kind=qp) private elemental module function signum_csp(x) result(sign) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x Return Value complex(kind=sp) private elemental module function signum_iint16(x) result(sign) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x Return Value integer(kind=int16) private elemental module function signum_iint32(x) result(sign) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x Return Value integer(kind=int32) private elemental module function signum_iint64(x) result(sign) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x Return Value integer(kind=int64) private elemental module function signum_iint8(x) result(sign) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x Return Value integer(kind=int8) private elemental module function signum_rdp(x) result(sign) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private elemental module function signum_rqp(x) result(sign) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private elemental module function signum_rsp(x) result(sign) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp)","tags":"","loc":"interface/signum.html"},{"title":"sind – FORLAB","text":"public interface sind Contents Functions sind_dp sind_qp sind_sp Functions private pure elemental module function sind_dp(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function sind_qp(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private pure elemental module function sind_sp(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp)","tags":"","loc":"interface/sind.html"},{"title":"tand – FORLAB","text":"public interface tand Contents Functions tand_dp tand_qp tand_sp Functions private pure elemental module function tand_dp(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function tand_qp(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private pure elemental module function tand_sp(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp)","tags":"","loc":"interface/tand.html"},{"title":"color – FORLAB","text":"interface color sets color for console text.\n( Specification ) public module module subroutine color(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string","tags":"","loc":"interface/color.html"},{"title":"countlines – FORLAB","text":"public interface countlines Contents Module Procedures countlines2 Module Procedures private function countlines2(filename) The countlines2 function returns the number of lines of the file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer","tags":"","loc":"interface/countlines.html"},{"title":"disp – FORLAB","text":"public interface disp Display a scalar, vector or matrix.\n( Specification ) Contents Subroutines disp_0_cdp disp_0_cqp disp_0_csp disp_0_iint16 disp_0_iint32 disp_0_iint64 disp_0_iint8 disp_0_lc_bool disp_0_llk disp_0_rdp disp_0_rqp disp_0_rsp disp_1_cdp disp_1_cqp disp_1_csp disp_1_iint16 disp_1_iint32 disp_1_iint64 disp_1_iint8 disp_1_lc_bool disp_1_llk disp_1_rdp disp_1_rqp disp_1_rsp disp_2_cdp disp_2_cqp disp_2_csp disp_2_iint16 disp_2_iint32 disp_2_iint64 disp_2_iint8 disp_2_lc_bool disp_2_llk disp_2_rdp disp_2_rqp disp_2_rsp disp_character disp_string_type Subroutines private module subroutine disp_0_cdp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_cqp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_csp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_iint16(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_iint32(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_iint64(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_iint8(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_lc_bool(x, header, unit, brief) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_llk(x, header, unit, brief) Arguments Type Intent Optional Attributes Name logical(kind=lk), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_rdp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_rqp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_rsp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_cdp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_cqp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_csp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_iint16(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_iint32(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_iint64(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_iint8(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_lc_bool(x, header, unit, brief) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_llk(x, header, unit, brief) Arguments Type Intent Optional Attributes Name logical(kind=lk), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_rdp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_rqp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_rsp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_cdp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_cqp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_csp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_iint16(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_iint32(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_iint64(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_iint8(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_lc_bool(x, header, unit, brief) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_llk(x, header, unit, brief) Arguments Type Intent Optional Attributes Name logical(kind=lk), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_rdp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_rqp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_rsp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_character(x, header, unit, brief) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_string_type(x, header, unit, brief) Arguments Type Intent Optional Attributes Name type(string_type), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief","tags":"","loc":"interface/disp.html"},{"title":"file – FORLAB","text":"public interface file Contents Module Procedures init_file Module Procedures private function init_file(filename, mode) File constructs a File object. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: mode Return Value type( file )","tags":"","loc":"interface/file.html"},{"title":"file_exist – FORLAB","text":"public interface file_exist Contents Module Procedures file_exist2 Module Procedures private function file_exist2(filename) The countlines2 function returns the number of lines of the file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical","tags":"","loc":"interface/file_exist.html"},{"title":"loadbin – FORLAB","text":"public interface loadbin Contents Subroutines loadbin_1_cdp loadbin_1_cqp loadbin_1_csp loadbin_1_iint16 loadbin_1_iint32 loadbin_1_iint64 loadbin_1_iint8 loadbin_1_rdp loadbin_1_rqp loadbin_1_rsp loadbin_2_cdp loadbin_2_cqp loadbin_2_csp loadbin_2_iint16 loadbin_2_iint32 loadbin_2_iint64 loadbin_2_iint8 loadbin_2_rdp loadbin_2_rqp loadbin_2_rsp loadbin_3_cdp loadbin_3_cqp loadbin_3_csp loadbin_3_iint16 loadbin_3_iint32 loadbin_3_iint64 loadbin_3_iint8 loadbin_3_rdp loadbin_3_rqp loadbin_3_rsp Subroutines private module subroutine loadbin_1_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_2_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_3_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(out), dimension(:, :, :), allocatable :: X","tags":"","loc":"interface/loadbin.html"},{"title":"loadtxt – FORLAB","text":"public interface loadtxt Contents Subroutines loadtxt_1_cdp loadtxt_1_cqp loadtxt_1_csp loadtxt_1_iint16 loadtxt_1_iint32 loadtxt_1_iint64 loadtxt_1_iint8 loadtxt_1_rdp loadtxt_1_rqp loadtxt_1_rsp loadtxt_2_cdp loadtxt_2_cqp loadtxt_2_csp loadtxt_2_iint16 loadtxt_2_iint32 loadtxt_2_iint64 loadtxt_2_iint8 loadtxt_2_rdp loadtxt_2_rqp loadtxt_2_rsp Subroutines private module subroutine loadtxt_1_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_2_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(out), dimension(:, :), allocatable :: X","tags":"","loc":"interface/loadtxt.html"},{"title":"progress_bar – FORLAB","text":"public interface progress_bar Print a progress_bar.\n( Specification ) Contents Subroutines progress_bar_int16 progress_bar_int32 progress_bar_int64 progress_bar_int8 Subroutines private module subroutine progress_bar_int16(iter, itermax, step, symbol) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: iter integer(kind=int16), intent(in) :: itermax integer(kind=int16), intent(in), optional :: step character, intent(in), optional :: symbol private module subroutine progress_bar_int32(iter, itermax, step, symbol) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter integer(kind=int32), intent(in) :: itermax integer(kind=int32), intent(in), optional :: step character, intent(in), optional :: symbol private module subroutine progress_bar_int64(iter, itermax, step, symbol) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: iter integer(kind=int64), intent(in) :: itermax integer(kind=int64), intent(in), optional :: step character, intent(in), optional :: symbol private module subroutine progress_bar_int8(iter, itermax, step, symbol) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: iter integer(kind=int8), intent(in) :: itermax integer(kind=int8), intent(in), optional :: step character, intent(in), optional :: symbol","tags":"","loc":"interface/progress_bar.html"},{"title":"progress_perc – FORLAB","text":"public interface progress_perc Print a progress percentage message.\n( Specification ) Contents Subroutines progress_perc_int16 progress_perc_int32 progress_perc_int64 progress_perc_int8 Subroutines private module subroutine progress_perc_int16(iter, itermax, prefix) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: iter integer(kind=int16), intent(in) :: itermax character, intent(in), optional :: prefix private module subroutine progress_perc_int32(iter, itermax, prefix) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter integer(kind=int32), intent(in) :: itermax character, intent(in), optional :: prefix private module subroutine progress_perc_int64(iter, itermax, prefix) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: iter integer(kind=int64), intent(in) :: itermax character, intent(in), optional :: prefix private module subroutine progress_perc_int8(iter, itermax, prefix) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: iter integer(kind=int8), intent(in) :: itermax character, intent(in), optional :: prefix","tags":"","loc":"interface/progress_perc.html"},{"title":"savebin – FORLAB","text":"public interface savebin Contents Subroutines savebin_1_cdp savebin_1_cqp savebin_1_csp savebin_1_iint16 savebin_1_iint32 savebin_1_iint64 savebin_1_iint8 savebin_1_rdp savebin_1_rqp savebin_1_rsp savebin_2_cdp savebin_2_cqp savebin_2_csp savebin_2_iint16 savebin_2_iint32 savebin_2_iint64 savebin_2_iint8 savebin_2_rdp savebin_2_rqp savebin_2_rsp savebin_3_cdp savebin_3_cqp savebin_3_csp savebin_3_iint16 savebin_3_iint32 savebin_3_iint64 savebin_3_iint8 savebin_3_rdp savebin_3_rqp savebin_3_rsp Subroutines private module subroutine savebin_1_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in), dimension(:) :: X private module subroutine savebin_1_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in), dimension(:) :: X private module subroutine savebin_1_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in), dimension(:) :: X private module subroutine savebin_1_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in), dimension(:) :: X private module subroutine savebin_1_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in), dimension(:) :: X private module subroutine savebin_1_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in), dimension(:) :: X private module subroutine savebin_1_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in), dimension(:) :: X private module subroutine savebin_1_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in), dimension(:) :: X private module subroutine savebin_1_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in), dimension(:) :: X private module subroutine savebin_1_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in), dimension(:) :: X private module subroutine savebin_2_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in), dimension(:, :) :: X private module subroutine savebin_2_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in), dimension(:, :) :: X private module subroutine savebin_2_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in), dimension(:, :) :: X private module subroutine savebin_2_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in), dimension(:, :) :: X private module subroutine savebin_2_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in), dimension(:, :) :: X private module subroutine savebin_2_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in), dimension(:, :) :: X private module subroutine savebin_2_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in), dimension(:, :) :: X private module subroutine savebin_2_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in), dimension(:, :) :: X private module subroutine savebin_2_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in), dimension(:, :) :: X private module subroutine savebin_2_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in), dimension(:, :) :: X private module subroutine savebin_3_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in), dimension(:, :, :) :: X","tags":"","loc":"interface/savebin.html"},{"title":"savetxt – FORLAB","text":"public interface savetxt Contents Subroutines savetxt_1_cdp savetxt_1_cqp savetxt_1_csp savetxt_1_iint16 savetxt_1_iint32 savetxt_1_iint64 savetxt_1_iint8 savetxt_1_rdp savetxt_1_rqp savetxt_1_rsp savetxt_2_cdp savetxt_2_cqp savetxt_2_csp savetxt_2_iint16 savetxt_2_iint32 savetxt_2_iint64 savetxt_2_iint8 savetxt_2_rdp savetxt_2_rqp savetxt_2_rsp Subroutines private module subroutine savetxt_1_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in), dimension(:) :: X private module subroutine savetxt_1_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in), dimension(:) :: X private module subroutine savetxt_1_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in), dimension(:) :: X private module subroutine savetxt_1_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in), dimension(:) :: X private module subroutine savetxt_1_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in), dimension(:) :: X private module subroutine savetxt_1_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in), dimension(:) :: X private module subroutine savetxt_1_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in), dimension(:) :: X private module subroutine savetxt_1_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in), dimension(:) :: X private module subroutine savetxt_1_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in), dimension(:) :: X private module subroutine savetxt_1_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in), dimension(:) :: X private module subroutine savetxt_2_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in), dimension(:, :) :: X","tags":"","loc":"interface/savetxt.html"},{"title":"time_string – FORLAB","text":"public function time_string() Arguments None Return Value character(len=19) Contents Source Code time_string Source Code character ( 19 ) function time_string () implicit none character ( 10 ) :: data , time call date_and_time ( data , time ) time_string = data ( 1 : 4 ) // '-' // data ( 5 : 6 ) // '-' // data ( 7 : 8 ) // ' ' // time ( 1 : 2 ) & // ':' // time ( 3 : 4 ) // ':' // time ( 5 : 6 ) end function time_string","tags":"","loc":"proc/time_string.html"},{"title":"datenum – FORLAB","text":"public interface datenum Contents Functions datenum0 Functions private module function datenum0(year, month, day, hour, minute, second, microsecond) Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(in) :: month integer, intent(in) :: day integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: microsecond Return Value real(kind=dp)","tags":"","loc":"interface/datenum.html"},{"title":"is_leap – FORLAB","text":"public interface is_leap Contents Module Procedures is_leap_int8 is_leap_int16 is_leap_int32 is_leap_int64 Module Procedures private function is_leap_int8(year) result(is_leap) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: year Return Value logical private function is_leap_int16(year) result(is_leap) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: year Return Value logical private function is_leap_int32(year) result(is_leap) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: year Return Value logical private function is_leap_int64(year) result(is_leap) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: year Return Value logical","tags":"","loc":"interface/is_leap.html"},{"title":"tic – FORLAB","text":"interface public module module subroutine tic() Arguments None","tags":"","loc":"interface/tic.html"},{"title":"toc – FORLAB","text":"public interface toc Contents Subroutines toc_default toc_dp toc_qp toc_sp Subroutines private module subroutine toc_default() Arguments None private module subroutine toc_dp(time) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: time private module subroutine toc_qp(time) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(out) :: time private module subroutine toc_sp(time) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: time","tags":"","loc":"interface/toc.html"},{"title":"chol – FORLAB","text":"public interface chol chol computes Cholesky's decomposition of a symmetric positive\ndefinite matrix. Contents Functions chol_dp chol_qp chol_sp Functions private module function chol_dp(A) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function chol_qp(A) result(L) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function chol_sp(A) result(L) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A Return Value real(kind=sp),\n  dimension(:, :), allocatable","tags":"","loc":"interface/chol.html"},{"title":"det – FORLAB","text":"public interface det det computes the matrix determinant. Contents Functions det_dp det_qp det_sp Functions private module function det_dp(A, outL, outU) result(det) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(inout), optional dimension(:, :), allocatable :: outL real(kind=dp), intent(inout), optional dimension(:, :), allocatable :: outU Return Value real(kind=dp) private module function det_qp(A, outL, outU) result(det) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A real(kind=qp), intent(inout), optional dimension(:, :), allocatable :: outL real(kind=qp), intent(inout), optional dimension(:, :), allocatable :: outU Return Value real(kind=qp) private module function det_sp(A, outL, outU) result(det) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A real(kind=sp), intent(inout), optional dimension(:, :), allocatable :: outL real(kind=sp), intent(inout), optional dimension(:, :), allocatable :: outU Return Value real(kind=sp)","tags":"","loc":"interface/det.html"},{"title":"diag – FORLAB","text":"public interface diag diag creates diagonal matrix or get the diagonal of a matrix. Contents Functions diag1_dp diag1_qp diag1_sp diag2_dp diag2_qp diag2_sp Functions private module function diag1_dp(A) result(diag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp),\n  dimension(:), allocatable private module function diag1_qp(A) result(diag) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A Return Value real(kind=qp),\n  dimension(:), allocatable private module function diag1_sp(A) result(diag) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A Return Value real(kind=sp),\n  dimension(:), allocatable private module function diag2_dp(x) result(diag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function diag2_qp(x) result(diag) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function diag2_sp(x) result(diag) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp),\n  dimension(:, :), allocatable","tags":"","loc":"interface/diag.html"},{"title":"diff – FORLAB","text":"public interface diff diff computes differences of arrays.\n( Specification ) Contents Functions diff_1_dp diff_1_int16 diff_1_int32 diff_1_int64 diff_1_int8 diff_1_qp diff_1_sp diff_2_dp diff_2_int16 diff_2_int32 diff_2_int64 diff_2_int8 diff_2_qp diff_2_sp Functions private pure module function diff_1_dp(x, n) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value real(kind=dp),\n  dimension(:), allocatable private pure module function diff_1_int16(x, n) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value integer(kind=int16),\n  dimension(:), allocatable private pure module function diff_1_int32(x, n) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value integer(kind=int32),\n  dimension(:), allocatable private pure module function diff_1_int64(x, n) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value integer(kind=int64),\n  dimension(:), allocatable private pure module function diff_1_int8(x, n) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value integer(kind=int8),\n  dimension(:), allocatable private pure module function diff_1_qp(x, n) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value real(kind=qp),\n  dimension(:), allocatable private pure module function diff_1_sp(x, n) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value real(kind=sp),\n  dimension(:), allocatable private pure module function diff_2_dp(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value real(kind=dp),\n  dimension(:, :), allocatable private pure module function diff_2_int16(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value integer(kind=int16),\n  dimension(:, :), allocatable private pure module function diff_2_int32(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value integer(kind=int32),\n  dimension(:, :), allocatable private pure module function diff_2_int64(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value integer(kind=int64),\n  dimension(:, :), allocatable private pure module function diff_2_int8(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value integer(kind=int8),\n  dimension(:, :), allocatable private pure module function diff_2_qp(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value real(kind=qp),\n  dimension(:, :), allocatable private pure module function diff_2_sp(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value real(kind=sp),\n  dimension(:, :), allocatable","tags":"","loc":"interface/diff.html"},{"title":"eye – FORLAB","text":"public interface eye Contents Subroutines eye_dp eye_qp eye_sp Subroutines private module subroutine eye_dp(X) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: X (:,:) private module subroutine eye_qp(X) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(out) :: X (:,:) private module subroutine eye_sp(X) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: X (:,:)","tags":"","loc":"interface/eye.html"},{"title":"horzcat – FORLAB","text":"public interface horzcat Contents Functions horzcat_c_12_dp horzcat_c_12_qp horzcat_c_12_sp horzcat_c_1_dp horzcat_c_1_qp horzcat_c_1_sp horzcat_c_21_dp horzcat_c_21_qp horzcat_c_21_sp horzcat_c_2_dp horzcat_c_2_qp horzcat_c_2_sp horzcat_i_12_int16 horzcat_i_12_int32 horzcat_i_12_int64 horzcat_i_12_int8 horzcat_i_1_int16 horzcat_i_1_int32 horzcat_i_1_int64 horzcat_i_1_int8 horzcat_i_21_int16 horzcat_i_21_int32 horzcat_i_21_int64 horzcat_i_21_int8 horzcat_i_2_int16 horzcat_i_2_int32 horzcat_i_2_int64 horzcat_i_2_int8 horzcat_r_12_dp horzcat_r_12_qp horzcat_r_12_sp horzcat_r_1_dp horzcat_r_1_qp horzcat_r_1_sp horzcat_r_21_dp horzcat_r_21_qp horzcat_r_21_sp horzcat_r_2_dp horzcat_r_2_qp horzcat_r_2_sp Functions private module function horzcat_c_12_dp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: x1 complex(kind=dp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_c_12_qp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:) :: x1 complex(kind=qp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_c_12_sp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:) :: x1 complex(kind=sp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_c_1_dp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: x1 complex(kind=dp), intent(in), dimension(:) :: x2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_c_1_qp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:) :: x1 complex(kind=qp), intent(in), dimension(:) :: x2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_c_1_sp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:) :: x1 complex(kind=sp), intent(in), dimension(:) :: x2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_c_21_dp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A1 complex(kind=dp), intent(in), dimension(:) :: x2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_c_21_qp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A1 complex(kind=qp), intent(in), dimension(:) :: x2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_c_21_sp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A1 complex(kind=sp), intent(in), dimension(:) :: x2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_c_2_dp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A1 complex(kind=dp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_c_2_qp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A1 complex(kind=qp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_c_2_sp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A1 complex(kind=sp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_i_12_int16(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x1 integer(kind=int16), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function horzcat_i_12_int32(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x1 integer(kind=int32), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function horzcat_i_12_int64(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x1 integer(kind=int64), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function horzcat_i_12_int8(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x1 integer(kind=int8), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function horzcat_i_1_int16(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x1 integer(kind=int16), intent(in), dimension(:) :: x2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function horzcat_i_1_int32(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x1 integer(kind=int32), intent(in), dimension(:) :: x2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function horzcat_i_1_int64(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x1 integer(kind=int64), intent(in), dimension(:) :: x2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function horzcat_i_1_int8(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x1 integer(kind=int8), intent(in), dimension(:) :: x2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function horzcat_i_21_int16(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A1 integer(kind=int16), intent(in), dimension(:) :: x2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function horzcat_i_21_int32(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A1 integer(kind=int32), intent(in), dimension(:) :: x2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function horzcat_i_21_int64(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A1 integer(kind=int64), intent(in), dimension(:) :: x2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function horzcat_i_21_int8(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A1 integer(kind=int8), intent(in), dimension(:) :: x2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function horzcat_i_2_int16(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A1 integer(kind=int16), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function horzcat_i_2_int32(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A1 integer(kind=int32), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function horzcat_i_2_int64(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A1 integer(kind=int64), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function horzcat_i_2_int8(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A1 integer(kind=int8), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function horzcat_r_12_dp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x1 real(kind=dp), intent(in), dimension(:, :) :: A2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_r_12_qp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x1 real(kind=qp), intent(in), dimension(:, :) :: A2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_r_12_sp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x1 real(kind=sp), intent(in), dimension(:, :) :: A2 Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_r_1_dp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x1 real(kind=dp), intent(in), dimension(:) :: x2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_r_1_qp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x1 real(kind=qp), intent(in), dimension(:) :: x2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_r_1_sp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x1 real(kind=sp), intent(in), dimension(:) :: x2 Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_r_21_dp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A1 real(kind=dp), intent(in), dimension(:) :: x2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_r_21_qp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A1 real(kind=qp), intent(in), dimension(:) :: x2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_r_21_sp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A1 real(kind=sp), intent(in), dimension(:) :: x2 Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_r_2_dp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A1 real(kind=dp), intent(in), dimension(:, :) :: A2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_r_2_qp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A1 real(kind=qp), intent(in), dimension(:, :) :: A2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_r_2_sp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A1 real(kind=sp), intent(in), dimension(:, :) :: A2 Return Value real(kind=sp),\n  dimension(:, :), allocatable","tags":"","loc":"interface/horzcat.html"},{"title":"inv – FORLAB","text":"public interface inv Contents Functions inv_cdp inv_cqp inv_csp inv_rdp inv_rqp inv_rsp Functions private module function inv_cdp(A) result(inv) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function inv_cqp(A) result(inv) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function inv_csp(A) result(inv) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function inv_rdp(A) result(inv) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function inv_rqp(A) result(inv) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function inv_rsp(A) result(inv) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A Return Value real(kind=sp),\n  dimension(:, :), allocatable","tags":"","loc":"interface/inv.html"},{"title":"is_square – FORLAB","text":"public interface is_square Contents Module Procedures is_square_rsp is_square_rdp is_square_rqp is_square_csp is_square_cdp is_square_cqp Module Procedures private function is_square_rsp(A) result(is_square) real(sp) matrix is square or not. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value logical private function is_square_rdp(A) result(is_square) real(dp) matrix is square or not. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value logical private function is_square_rqp(A) result(is_square) real(qp) matrix is square or not. Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value logical private function is_square_csp(A) result(is_square) complex(sp) matrix is square or not. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value logical private function is_square_cdp(A) result(is_square) complex(dp) matrix is square or not. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value logical private function is_square_cqp(A) result(is_square) complex(qp) matrix is square or not. Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value logical","tags":"","loc":"interface/is_square.html"},{"title":"is_symmetric – FORLAB","text":"public interface is_symmetric Contents Module Procedures is_symmetric_rsp is_symmetric_rdp is_symmetric_rqp is_symmetric_csp is_symmetric_cdp is_symmetric_cqp Module Procedures private function is_symmetric_rsp(A) result(is_symmetric) real(sp) matrix is symmetric or not. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value logical private function is_symmetric_rdp(A) result(is_symmetric) real(dp) matrix is symmetric or not. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value logical private function is_symmetric_rqp(A) result(is_symmetric) real(qp) matrix is symmetric or not. Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value logical private function is_symmetric_csp(A) result(is_symmetric) complex(sp) matrix is symmetric or not. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value logical private function is_symmetric_cdp(A) result(is_symmetric) complex(dp) matrix is symmetric or not. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value logical private function is_symmetric_cqp(A) result(is_symmetric) complex(qp) matrix is symmetric or not. Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value logical","tags":"","loc":"interface/is_symmetric.html"},{"title":"linspace – FORLAB","text":"public interface linspace Contents Subroutines linspace_dp linspace_qp linspace_sp Subroutines private pure module subroutine linspace_dp(X, from, to) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: X (:) real(kind=dp), intent(in) :: from real(kind=dp), intent(in) :: to private pure module subroutine linspace_qp(X, from, to) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(out) :: X (:) real(kind=qp), intent(in) :: from real(kind=qp), intent(in) :: to private pure module subroutine linspace_sp(X, from, to) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: X (:) real(kind=sp), intent(in) :: from real(kind=sp), intent(in) :: to","tags":"","loc":"interface/linspace.html"},{"title":"logspace – FORLAB","text":"public interface logspace Contents Subroutines logspace_dp logspace_qp logspace_sp Subroutines private pure module subroutine logspace_dp(X, from, to) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: X (:) real(kind=dp), intent(in) :: from real(kind=dp), intent(in) :: to private pure module subroutine logspace_qp(X, from, to) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(out) :: X (:) real(kind=qp), intent(in) :: from real(kind=qp), intent(in) :: to private pure module subroutine logspace_sp(X, from, to) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: X (:) real(kind=sp), intent(in) :: from real(kind=sp), intent(in) :: to","tags":"","loc":"interface/logspace.html"},{"title":"lu – FORLAB","text":"public interface lu lu computes the LU matrix factorization. Contents Subroutines lu_dp lu_qp lu_sp Subroutines private module subroutine lu_dp(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(:, :), allocatable :: L real(kind=dp), intent(out), dimension(:, :), allocatable :: U private module subroutine lu_qp(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A real(kind=qp), intent(out), dimension(:, :), allocatable :: L real(kind=qp), intent(out), dimension(:, :), allocatable :: U private module subroutine lu_sp(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A real(kind=sp), intent(out), dimension(:, :), allocatable :: L real(kind=sp), intent(out), dimension(:, :), allocatable :: U","tags":"","loc":"interface/lu.html"},{"title":"matpow – FORLAB","text":"public interface matpow Calculat matrix power Contents Functions matpow_dp matpow_qp matpow_sp Functions private module function matpow_dp(a, num) result(c) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:,:) :: a integer :: num Return Value real(kind=dp),\n  allocatable, (:,:) private module function matpow_qp(a, num) result(c) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:,:) :: a integer :: num Return Value real(kind=qp),\n  allocatable, (:,:) private module function matpow_sp(a, num) result(c) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:,:) :: a integer :: num Return Value real(kind=sp),\n  allocatable, (:,:)","tags":"","loc":"interface/matpow.html"},{"title":"norm – FORLAB","text":"public interface norm norm computes vector and matrix norms. Contents Functions norm1_dp norm1_qp norm1_sp norm2_dp norm2_qp norm2_sp Functions private module function norm1_dp(x, p) result(norm1) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), optional :: p Return Value real(kind=dp) private module function norm1_qp(x, p) result(norm1) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x real(kind=qp), intent(in), optional :: p Return Value real(kind=qp) private module function norm1_sp(x, p) result(norm1) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x real(kind=sp), intent(in), optional :: p Return Value real(kind=sp) private module function norm2_dp(A, p) result(norm2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:,:) :: A real(kind=dp), intent(in), optional :: p Return Value real(kind=dp) private module function norm2_qp(A, p) result(norm2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:,:) :: A real(kind=qp), intent(in), optional :: p Return Value real(kind=qp) private module function norm2_sp(A, p) result(norm2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:,:) :: A real(kind=sp), intent(in), optional :: p Return Value real(kind=sp)","tags":"","loc":"interface/norm.html"},{"title":"ones – FORLAB","text":"public interface ones Creates a rank-1 or rank-2 array filled ones.\n( Specification ) Contents Module Procedures ones_1_default ones_2_default Module Procedures private pure function ones_1_default(dim) result(result) ones creates a rank-1 array, filled completely with 1 integer type values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim Return Value integer(kind=int8),\n  allocatable, (:) private pure function ones_2_default(dim1, dim2) result(result) ones creates a rank-2 array, filled completely with 1 integer type values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim1 integer, intent(in) :: dim2 Return Value integer(kind=int8),\n  allocatable, (:,:)","tags":"","loc":"interface/ones.html"},{"title":"operator(.i.) – FORLAB","text":"public interface operator(.i.) Calculate the inverse of a real matrix. Contents Module Procedures inv_rsp inv_rdp inv_rqp inv_csp inv_cdp inv_cqp Module Procedures private module function inv_rsp(A) result(inv) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function inv_rdp(A) result(inv) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function inv_rqp(A) result(inv) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function inv_csp(A) result(inv) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function inv_cdp(A) result(inv) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function inv_cqp(A) result(inv) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A Return Value complex(kind=qp),\n  dimension(:, :), allocatable","tags":"","loc":"interface/operator(.i.).html"},{"title":"operator(.x.) – FORLAB","text":"public interface operator(.x.) Contents Module Procedures rmut_sp rmut_dp rmut_qp cmut_sp cmut_dp cmut_qp rcmut_sp rcmut_dp rcmut_qp crmut_sp crmut_dp crmut_qp Module Procedures private function rmut_sp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: m1 (:,:) real(kind=sp), intent(in) :: m2 (:,:) Return Value real(kind=sp)\n  (size(m1,1),size(m2,2)) private function rmut_dp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: m1 (:,:) real(kind=dp), intent(in) :: m2 (:,:) Return Value real(kind=dp)\n  (size(m1,1),size(m2,2)) private function rmut_qp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: m1 (:,:) real(kind=qp), intent(in) :: m2 (:,:) Return Value real(kind=qp)\n  (size(m1,1),size(m2,2)) private function cmut_sp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: m1 (:,:) complex(kind=sp), intent(in) :: m2 (:,:) Return Value complex(kind=sp)\n  (size(m1,1),size(m2,2)) private function cmut_dp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: m1 (:,:) complex(kind=dp), intent(in) :: m2 (:,:) Return Value complex(kind=dp)\n  (size(m1,1),size(m2,2)) private function cmut_qp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: m1 (:,:) complex(kind=qp), intent(in) :: m2 (:,:) Return Value complex(kind=qp)\n  (size(m1,1),size(m2,2)) private function rcmut_sp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: m1 (:,:) complex(kind=sp), intent(in) :: m2 (:,:) Return Value complex(kind=sp)\n  (size(m1,1),size(m2,2)) private function rcmut_dp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: m1 (:,:) complex(kind=dp), intent(in) :: m2 (:,:) Return Value complex(kind=dp)\n  (size(m1,1),size(m2,2)) private function rcmut_qp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: m1 (:,:) complex(kind=qp), intent(in) :: m2 (:,:) Return Value complex(kind=qp)\n  (size(m1,1),size(m2,2)) private function crmut_sp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: m1 (:,:) real(kind=sp), intent(in) :: m2 (:,:) Return Value complex(kind=sp)\n  (size(m1,1),size(m2,2)) private function crmut_dp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: m1 (:,:) real(kind=dp), intent(in) :: m2 (:,:) Return Value complex(kind=dp)\n  (size(m1,1),size(m2,2)) private function crmut_qp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: m1 (:,:) real(kind=qp), intent(in) :: m2 (:,:) Return Value complex(kind=qp)\n  (size(m1,1),size(m2,2))","tags":"","loc":"interface/operator(.x.).html"},{"title":"outer – FORLAB","text":"public interface outer Contents Functions outer_dp outer_int16 outer_int32 outer_int64 outer_int8 outer_qp outer_sp Functions private module function outer_dp(x, y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), dimension(:) :: y Return Value real(kind=dp),\n  dimension(:,:), allocatable private module function outer_int16(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x integer(kind=int16), intent(in), dimension(:) :: y Return Value integer(kind=int16),\n  dimension(:,:), allocatable private module function outer_int32(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x integer(kind=int32), intent(in), dimension(:) :: y Return Value integer(kind=int32),\n  dimension(:,:), allocatable private module function outer_int64(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x integer(kind=int64), intent(in), dimension(:) :: y Return Value integer(kind=int64),\n  dimension(:,:), allocatable private module function outer_int8(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x integer(kind=int8), intent(in), dimension(:) :: y Return Value integer(kind=int8),\n  dimension(:,:), allocatable private module function outer_qp(x, y) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x real(kind=qp), intent(in), dimension(:) :: y Return Value real(kind=qp),\n  dimension(:,:), allocatable private module function outer_sp(x, y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x real(kind=sp), intent(in), dimension(:) :: y Return Value real(kind=sp),\n  dimension(:,:), allocatable","tags":"","loc":"interface/outer.html"},{"title":"qr – FORLAB","text":"public interface qr Contents Subroutines qr_dp qr_qp qr_sp Subroutines private module subroutine qr_dp(a, q, r, l) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a (:,:) real(kind=dp), intent(out), allocatable :: q (:,:) real(kind=dp), intent(out), allocatable :: r (:,:) integer, optional :: l private module subroutine qr_qp(a, q, r, l) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: a (:,:) real(kind=qp), intent(out), allocatable :: q (:,:) real(kind=qp), intent(out), allocatable :: r (:,:) integer, optional :: l private module subroutine qr_sp(a, q, r, l) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a (:,:) real(kind=sp), intent(out), allocatable :: q (:,:) real(kind=sp), intent(out), allocatable :: r (:,:) integer, optional :: l","tags":"","loc":"interface/qr.html"},{"title":"seq – FORLAB","text":"public interface seq seq returns evenly spaced vector. Contents Subroutines seq_dp seq_int16 seq_int32 seq_int64 seq_int8 seq_qp seq_sp Subroutines private module subroutine seq_dp(X, from, to, by) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:), allocatable :: X real(kind=dp), intent(in) :: from real(kind=dp), intent(in) :: to real(kind=dp), intent(in), optional :: by private module subroutine seq_int16(X, from, to, by) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(out), dimension(:), allocatable :: X integer(kind=int16), intent(in) :: from integer(kind=int16), intent(in) :: to integer(kind=int16), intent(in), optional :: by private module subroutine seq_int32(X, from, to, by) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out), dimension(:), allocatable :: X integer(kind=int32), intent(in) :: from integer(kind=int32), intent(in) :: to integer(kind=int32), intent(in), optional :: by private module subroutine seq_int64(X, from, to, by) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(out), dimension(:), allocatable :: X integer(kind=int64), intent(in) :: from integer(kind=int64), intent(in) :: to integer(kind=int64), intent(in), optional :: by private module subroutine seq_int8(X, from, to, by) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(out), dimension(:), allocatable :: X integer(kind=int8), intent(in) :: from integer(kind=int8), intent(in) :: to integer(kind=int8), intent(in), optional :: by private module subroutine seq_qp(X, from, to, by) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(out), dimension(:), allocatable :: X real(kind=qp), intent(in) :: from real(kind=qp), intent(in) :: to real(kind=qp), intent(in), optional :: by private module subroutine seq_sp(X, from, to, by) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out), dimension(:), allocatable :: X real(kind=sp), intent(in) :: from real(kind=sp), intent(in) :: to real(kind=sp), intent(in), optional :: by","tags":"","loc":"interface/seq.html"},{"title":"solve – FORLAB","text":"public interface solve Contents Functions solve_dp solve_qp solve_sp Functions private module function solve_dp(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in), dimension(:) :: b Return Value real(kind=dp),\n  dimension(:), allocatable private module function solve_qp(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A real(kind=qp), intent(in), dimension(:) :: b Return Value real(kind=qp),\n  dimension(:), allocatable private module function solve_sp(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A real(kind=sp), intent(in), dimension(:) :: b Return Value real(kind=sp),\n  dimension(:), allocatable","tags":"","loc":"interface/solve.html"},{"title":"svd – FORLAB","text":"public interface svd Contents Subroutines svd_dp svd_qp svd_sp Subroutines private module subroutine svd_dp(a, w, u, v, d, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: a real(kind=dp), intent(out), dimension(:), allocatable :: w real(kind=dp), intent(out), optional dimension(:, :), allocatable :: u real(kind=dp), intent(out), optional dimension(:, :), allocatable :: v logical, intent(in), optional :: d integer, intent(out), optional :: ierr private module subroutine svd_qp(a, w, u, v, d, ierr) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: a real(kind=qp), intent(out), dimension(:), allocatable :: w real(kind=qp), intent(out), optional dimension(:, :), allocatable :: u real(kind=qp), intent(out), optional dimension(:, :), allocatable :: v logical, intent(in), optional :: d integer, intent(out), optional :: ierr private module subroutine svd_sp(a, w, u, v, d, ierr) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: a real(kind=sp), intent(out), dimension(:), allocatable :: w real(kind=sp), intent(out), optional dimension(:, :), allocatable :: u real(kind=sp), intent(out), optional dimension(:, :), allocatable :: v logical, intent(in), optional :: d integer, intent(out), optional :: ierr","tags":"","loc":"interface/svd.html"},{"title":"svdsolve – FORLAB","text":"public interface svdsolve Contents Functions svdsolve_dp svdsolve_qp svdsolve_sp Functions private module function svdsolve_dp(A, b, cutoff) result(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in), dimension(:) :: b integer, intent(in), optional :: cutoff Return Value real(kind=dp),\n  dimension(:), allocatable private module function svdsolve_qp(A, b, cutoff) result(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A real(kind=qp), intent(in), dimension(:) :: b integer, intent(in), optional :: cutoff Return Value real(kind=qp),\n  dimension(:), allocatable private module function svdsolve_sp(A, b, cutoff) result(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A real(kind=sp), intent(in), dimension(:) :: b integer, intent(in), optional :: cutoff Return Value real(kind=sp),\n  dimension(:), allocatable","tags":"","loc":"interface/svdsolve.html"},{"title":"trace – FORLAB","text":"public interface trace Contents Module Procedures trace_sp trace_dp trace_qp Module Procedures private function trace_sp(A) result(trace) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A Return Value real(kind=sp) private function trace_dp(A) result(trace) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp) private function trace_qp(A) result(trace) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A Return Value real(kind=qp)","tags":"","loc":"interface/trace.html"},{"title":"tril – FORLAB","text":"public interface tril Contents Functions tril_cdp tril_cqp tril_csp tril_dp tril_int16 tril_int32 tril_int64 tril_int8 tril_qp tril_sp Functions private module function tril_cdp(A, k) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function tril_cqp(A, k) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function tril_csp(A, k) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function tril_dp(A, k) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function tril_int16(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function tril_int32(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function tril_int64(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function tril_int8(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function tril_qp(A, k) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function tril_sp(A, k) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value real(kind=sp),\n  dimension(:, :), allocatable","tags":"","loc":"interface/tril.html"},{"title":"triu – FORLAB","text":"public interface triu Contents Functions triu_cdp triu_cqp triu_csp triu_dp triu_int16 triu_int32 triu_int64 triu_int8 triu_qp triu_sp Functions private module function triu_cdp(A, k) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function triu_cqp(A, k) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function triu_csp(A, k) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function triu_dp(A, k) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function triu_int16(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function triu_int32(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function triu_int64(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function triu_int8(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function triu_qp(A, k) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function triu_sp(A, k) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value real(kind=sp),\n  dimension(:, :), allocatable","tags":"","loc":"interface/triu.html"},{"title":"vertcat – FORLAB","text":"public interface vertcat Contents Functions vertcat_c_12_dp vertcat_c_12_qp vertcat_c_12_sp vertcat_c_1_dp vertcat_c_1_qp vertcat_c_1_sp vertcat_c_21_dp vertcat_c_21_qp vertcat_c_21_sp vertcat_c_2_dp vertcat_c_2_qp vertcat_c_2_sp vertcat_i_12_int16 vertcat_i_12_int32 vertcat_i_12_int64 vertcat_i_12_int8 vertcat_i_1_int16 vertcat_i_1_int32 vertcat_i_1_int64 vertcat_i_1_int8 vertcat_i_21_int16 vertcat_i_21_int32 vertcat_i_21_int64 vertcat_i_21_int8 vertcat_i_2_int16 vertcat_i_2_int32 vertcat_i_2_int64 vertcat_i_2_int8 vertcat_r_12_dp vertcat_r_12_qp vertcat_r_12_sp vertcat_r_1_dp vertcat_r_1_qp vertcat_r_1_sp vertcat_r_21_dp vertcat_r_21_qp vertcat_r_21_sp vertcat_r_2_dp vertcat_r_2_qp vertcat_r_2_sp Functions private module function vertcat_c_12_dp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: x1 complex(kind=dp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_c_12_qp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:) :: x1 complex(kind=qp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_c_12_sp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:) :: x1 complex(kind=sp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_c_1_dp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: x1 complex(kind=dp), intent(in), dimension(:) :: x2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_c_1_qp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:) :: x1 complex(kind=qp), intent(in), dimension(:) :: x2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_c_1_sp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:) :: x1 complex(kind=sp), intent(in), dimension(:) :: x2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_c_21_dp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A1 complex(kind=dp), intent(in), dimension(:) :: x2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_c_21_qp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A1 complex(kind=qp), intent(in), dimension(:) :: x2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_c_21_sp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A1 complex(kind=sp), intent(in), dimension(:) :: x2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_c_2_dp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A1 complex(kind=dp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_c_2_qp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A1 complex(kind=qp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_c_2_sp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A1 complex(kind=sp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_i_12_int16(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x1 integer(kind=int16), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function vertcat_i_12_int32(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x1 integer(kind=int32), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function vertcat_i_12_int64(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x1 integer(kind=int64), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function vertcat_i_12_int8(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x1 integer(kind=int8), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function vertcat_i_1_int16(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x1 integer(kind=int16), intent(in), dimension(:) :: x2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function vertcat_i_1_int32(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x1 integer(kind=int32), intent(in), dimension(:) :: x2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function vertcat_i_1_int64(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x1 integer(kind=int64), intent(in), dimension(:) :: x2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function vertcat_i_1_int8(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x1 integer(kind=int8), intent(in), dimension(:) :: x2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function vertcat_i_21_int16(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A1 integer(kind=int16), intent(in), dimension(:) :: x2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function vertcat_i_21_int32(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A1 integer(kind=int32), intent(in), dimension(:) :: x2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function vertcat_i_21_int64(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A1 integer(kind=int64), intent(in), dimension(:) :: x2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function vertcat_i_21_int8(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A1 integer(kind=int8), intent(in), dimension(:) :: x2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function vertcat_i_2_int16(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A1 integer(kind=int16), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function vertcat_i_2_int32(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A1 integer(kind=int32), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function vertcat_i_2_int64(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A1 integer(kind=int64), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function vertcat_i_2_int8(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A1 integer(kind=int8), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function vertcat_r_12_dp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x1 real(kind=dp), intent(in), dimension(:, :) :: A2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_r_12_qp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x1 real(kind=qp), intent(in), dimension(:, :) :: A2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_r_12_sp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x1 real(kind=sp), intent(in), dimension(:, :) :: A2 Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_r_1_dp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x1 real(kind=dp), intent(in), dimension(:) :: x2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_r_1_qp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x1 real(kind=qp), intent(in), dimension(:) :: x2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_r_1_sp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x1 real(kind=sp), intent(in), dimension(:) :: x2 Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_r_21_dp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A1 real(kind=dp), intent(in), dimension(:) :: x2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_r_21_qp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A1 real(kind=qp), intent(in), dimension(:) :: x2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_r_21_sp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A1 real(kind=sp), intent(in), dimension(:) :: x2 Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_r_2_dp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A1 real(kind=dp), intent(in), dimension(:, :) :: A2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_r_2_qp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A1 real(kind=qp), intent(in), dimension(:, :) :: A2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_r_2_sp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A1 real(kind=sp), intent(in), dimension(:, :) :: A2 Return Value real(kind=sp),\n  dimension(:, :), allocatable","tags":"","loc":"interface/vertcat.html"},{"title":"zeros – FORLAB","text":"public interface zeros Creates a rank-1 or rank-2 array filled zeros.\n( Specification ) Contents Module Procedures zeros_1_default zeros_2_default Module Procedures private pure function zeros_1_default(dim) result(result) zeros creates a rank-1 array, filled completely with 0 integer type values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim Return Value integer(kind=int8),\n  allocatable, (:) private pure function zeros_2_default(dim1, dim2) result(result) zeros creates a rank-2 array, filled completely with 0 integer type values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim1 integer, intent(in) :: dim2 Return Value integer(kind=int8),\n  allocatable, (:,:)","tags":"","loc":"interface/zeros.html"},{"title":"mean – FORLAB","text":"public interface mean mean computes the mean value of an array. Contents Functions mean_1_dp mean_1_qp mean_1_sp mean_2_dp mean_2_qp mean_2_sp Functions private module function mean_1_dp(x) result(mean) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp) private module function mean_1_qp(x) result(mean) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp) private module function mean_1_sp(x) result(mean) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp) private module function mean_2_dp(A, dim) result(mean) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: dim Return Value real(kind=dp),\n  dimension(:), allocatable private module function mean_2_qp(A, dim) result(mean) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: dim Return Value real(kind=qp),\n  dimension(:), allocatable private module function mean_2_sp(A, dim) result(mean) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: dim Return Value real(kind=sp),\n  dimension(:), allocatable","tags":"","loc":"interface/mean.html"},{"title":"randn – FORLAB","text":"public interface randn Generate a normal distributed data scalar or vector.\n( Specification ) Contents Functions randn_0_dp randn_0_qp randn_0_sp randn_1_dp randn_1_qp randn_1_sp Functions private module function randn_0_dp(mean, std) result(random) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mean real(kind=dp), intent(in) :: std Return Value real(kind=dp) private module function randn_0_qp(mean, std) result(random) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: mean real(kind=qp), intent(in) :: std Return Value real(kind=qp) private module function randn_0_sp(mean, std) result(random) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: mean real(kind=sp), intent(in) :: std Return Value real(kind=sp) private module function randn_1_dp(mean, std, ndim) result(random) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mean real(kind=dp), intent(in) :: std integer, intent(in) :: ndim Return Value real(kind=dp)\n  (ndim) private module function randn_1_qp(mean, std, ndim) result(random) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: mean real(kind=qp), intent(in) :: std integer, intent(in) :: ndim Return Value real(kind=qp)\n  (ndim) private module function randn_1_sp(mean, std, ndim) result(random) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: mean real(kind=sp), intent(in) :: std integer, intent(in) :: ndim Return Value real(kind=sp)\n  (ndim)","tags":"","loc":"interface/randn.html"},{"title":"randu – FORLAB","text":"public interface randu Generate an uniformly distributed data scalar or vector.\n( Specification ) Contents Functions randu_0_iint16 randu_0_iint32 randu_0_iint64 randu_0_iint8 randu_0_rdp randu_0_rqp randu_0_rsp randu_1_iint16 randu_1_iint32 randu_1_iint64 randu_1_iint8 randu_1_rdp randu_1_rqp randu_1_rsp Functions private module function randu_0_iint16(start, end) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: start integer(kind=int16), intent(in) :: end Return Value integer(kind=int16) private module function randu_0_iint32(start, end) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: start integer(kind=int32), intent(in) :: end Return Value integer(kind=int32) private module function randu_0_iint64(start, end) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: start integer(kind=int64), intent(in) :: end Return Value integer(kind=int64) private module function randu_0_iint8(start, end) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: start integer(kind=int8), intent(in) :: end Return Value integer(kind=int8) private module function randu_0_rdp(start, end) result(random) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end Return Value real(kind=dp) private module function randu_0_rqp(start, end) result(random) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end Return Value real(kind=qp) private module function randu_0_rsp(start, end) result(random) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end Return Value real(kind=sp) private module function randu_1_iint16(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: start integer(kind=int16), intent(in) :: end integer, intent(in) :: ndim Return Value integer(kind=int16)\n  (ndim) private module function randu_1_iint32(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: start integer(kind=int32), intent(in) :: end integer, intent(in) :: ndim Return Value integer(kind=int32)\n  (ndim) private module function randu_1_iint64(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: start integer(kind=int64), intent(in) :: end integer, intent(in) :: ndim Return Value integer(kind=int64)\n  (ndim) private module function randu_1_iint8(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: start integer(kind=int8), intent(in) :: end integer, intent(in) :: ndim Return Value integer(kind=int8)\n  (ndim) private module function randu_1_rdp(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end integer, intent(in) :: ndim Return Value real(kind=dp)\n  (ndim) private module function randu_1_rqp(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end integer, intent(in) :: ndim Return Value real(kind=qp)\n  (ndim) private module function randu_1_rsp(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end integer, intent(in) :: ndim Return Value real(kind=sp)\n  (ndim)","tags":"","loc":"interface/randu.html"},{"title":"rng – FORLAB","text":"interface public module module subroutine rng(seed) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: seed","tags":"","loc":"interface/rng.html"},{"title":"std – FORLAB","text":"public interface std std computes vector and matrix standard deviations.\n( Specification ) Contents Functions std_1_dp std_1_qp std_1_sp std_2_dp std_2_qp std_2_sp Functions private module function std_1_dp(x, w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: w Return Value real(kind=dp) private module function std_1_qp(x, w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: w Return Value real(kind=qp) private module function std_1_sp(x, w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: w Return Value real(kind=sp) private module function std_2_dp(A, w, dim) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: w integer, intent(in), optional :: dim Return Value real(kind=dp),\n  dimension(:), allocatable private module function std_2_qp(A, w, dim) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: w integer, intent(in), optional :: dim Return Value real(kind=qp),\n  dimension(:), allocatable private module function std_2_sp(A, w, dim) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: w integer, intent(in), optional :: dim Return Value real(kind=sp),\n  dimension(:), allocatable","tags":"","loc":"interface/std.html"},{"title":"var – FORLAB","text":"public interface var var computes vector and matrix variances.\n( Specification ) Contents Functions var_1_dp var_1_qp var_1_sp var_2_dp var_2_qp var_2_sp Functions private module function var_1_dp(x, w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: w Return Value real(kind=dp) private module function var_1_qp(x, w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: w Return Value real(kind=qp) private module function var_1_sp(x, w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: w Return Value real(kind=sp) private module function var_2_dp(A, w, dim) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: w integer, intent(in), optional :: dim Return Value real(kind=dp),\n  dimension(:), allocatable private module function var_2_qp(A, w, dim) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: w integer, intent(in), optional :: dim Return Value real(kind=qp),\n  dimension(:), allocatable private module function var_2_sp(A, w, dim) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: w integer, intent(in), optional :: dim Return Value real(kind=sp),\n  dimension(:), allocatable","tags":"","loc":"interface/var.html"},{"title":"argsort – FORLAB","text":"public interface argsort argsort generates the indices that would sort an array. Contents Functions argsort_dp argsort_int16 argsort_int32 argsort_int64 argsort_int8 argsort_qp argsort_sp Functions private module function argsort_dp(x, order) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) private module function argsort_int16(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) private module function argsort_int32(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) private module function argsort_int64(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) private module function argsort_int8(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) private module function argsort_qp(x, order) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) private module function argsort_sp(x, order) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:)","tags":"","loc":"interface/argsort.html"},{"title":"sort – FORLAB","text":"public interface sort Contents Functions sort_dp sort_int16 sort_int32 sort_int64 sort_int8 sort_qp sort_sp Functions private module function sort_dp(x, order) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in), optional :: order Return Value real(kind=dp),\n  allocatable, (:) private module function sort_int16(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer(kind=int16),\n  allocatable, (:) private module function sort_int32(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer(kind=int32),\n  allocatable, (:) private module function sort_int64(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer(kind=int64),\n  allocatable, (:) private module function sort_int8(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer(kind=int8),\n  allocatable, (:) private module function sort_qp(x, order) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in), optional :: order Return Value real(kind=qp),\n  allocatable, (:) private module function sort_sp(x, order) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in), optional :: order Return Value real(kind=sp),\n  allocatable, (:)","tags":"","loc":"interface/sort.html"},{"title":"forlab_color – FORLAB","text":"Contents Variables background_green blue bold bold_blink cyan default esc green grey magenta red yellow Variables Type Visibility Attributes Name Initial character, public, parameter :: background_green = esc//'[42m' character, public, parameter :: blue = esc//'[34m' character, public, parameter :: bold = esc//'[1m' character, public, parameter :: bold_blink = esc//'[1;5m' character, public, parameter :: cyan = esc//'[36m' character, public, parameter :: default = esc//'[0m' character, public, parameter :: esc = achar(27) character, public, parameter :: green = esc//'[32m' character, public, parameter :: grey = esc//'[90m' character, public, parameter :: magenta = esc//'[35m' character, public, parameter :: red = esc//'[31m' character, public, parameter :: yellow = esc//'[33m'","tags":"","loc":"module/forlab_color.html"},{"title":"forlab_math – FORLAB","text":"Uses stdlib_kinds stdlib_optval Used by Descendants: forlab_math_all_close forlab_math_arange forlab_math_degcir forlab_math_is_close forlab_math_signum Contents Interfaces acosd all_close angle arange asind atand cosd is_close signum sind tand Interfaces public interface acosd degree circular functions private pure elemental module function acosd_dp(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function acosd_qp(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private pure elemental module function acosd_sp(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) public interface all_close Returns a boolean scalar where two arrays are element-wise equal within a tolerance.\n( Specification ) private module function all_close_cdp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: a (..) complex(kind=dp), intent(in) :: b (..) real(kind=dp), intent(in), optional :: rel_tol real(kind=dp), intent(in), optional :: abs_tol Return Value logical private module function all_close_cqp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: a (..) complex(kind=qp), intent(in) :: b (..) real(kind=qp), intent(in), optional :: rel_tol real(kind=qp), intent(in), optional :: abs_tol Return Value logical private module function all_close_csp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: a (..) complex(kind=sp), intent(in) :: b (..) real(kind=sp), intent(in), optional :: rel_tol real(kind=sp), intent(in), optional :: abs_tol Return Value logical private module function all_close_rdp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a (..) real(kind=dp), intent(in) :: b (..) real(kind=dp), intent(in), optional :: rel_tol real(kind=dp), intent(in), optional :: abs_tol Return Value logical private module function all_close_rqp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: a (..) real(kind=qp), intent(in) :: b (..) real(kind=qp), intent(in), optional :: rel_tol real(kind=qp), intent(in), optional :: abs_tol Return Value logical private module function all_close_rsp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a (..) real(kind=sp), intent(in) :: b (..) real(kind=sp), intent(in), optional :: rel_tol real(kind=sp), intent(in), optional :: abs_tol Return Value logical public interface angle angle compute the phase angle.\n( Interface ) private elemental function angle_sp(value) result(angle) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: value Return Value real(kind=sp) private elemental function angle_dp(value) result(angle) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: value Return Value real(kind=dp) private elemental function angle_qp(value) result(angle) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: value Return Value real(kind=qp) public interface arange arange creates a rank-1 array of the integer/real type \n with fixed-spaced values of given spacing, within a given interval.\n( Specification ) private pure module function arange_i_int16(start, end, step) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: start integer(kind=int16), intent(in), optional :: end integer(kind=int16), intent(in), optional :: step Return Value integer(kind=int16),\n  allocatable, (:) private pure module function arange_i_int32(start, end, step) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: start integer(kind=int32), intent(in), optional :: end integer(kind=int32), intent(in), optional :: step Return Value integer(kind=int32),\n  allocatable, (:) private pure module function arange_i_int64(start, end, step) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: start integer(kind=int64), intent(in), optional :: end integer(kind=int64), intent(in), optional :: step Return Value integer(kind=int64),\n  allocatable, (:) private pure module function arange_i_int8(start, end, step) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: start integer(kind=int8), intent(in), optional :: end integer(kind=int8), intent(in), optional :: step Return Value integer(kind=int8),\n  allocatable, (:) private pure module function arange_r_dp(start, end, step) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in), optional :: end real(kind=dp), intent(in), optional :: step Return Value real(kind=dp),\n  allocatable, (:) private pure module function arange_r_qp(start, end, step) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in), optional :: end real(kind=qp), intent(in), optional :: step Return Value real(kind=qp),\n  allocatable, (:) private pure module function arange_r_sp(start, end, step) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in), optional :: end real(kind=sp), intent(in), optional :: step Return Value real(kind=sp),\n  allocatable, (:) public interface asind degree circular functions private pure elemental module function asind_dp(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function asind_qp(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private pure elemental module function asind_sp(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) public interface atand degree circular functions private pure elemental module function atand_dp(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function atand_qp(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private pure elemental module function atand_sp(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) public interface cosd private pure elemental module function cosd_dp(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function cosd_qp(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private pure elemental module function cosd_sp(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) public interface is_close Returns a boolean scalar/array where two scalar/arrays are element-wise equal within a tolerance.\n( Specification ) private elemental module function is_close_cdp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: a complex(kind=dp), intent(in) :: b real(kind=dp), intent(in), optional :: rel_tol real(kind=dp), intent(in), optional :: abs_tol Return Value logical private elemental module function is_close_cqp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: a complex(kind=qp), intent(in) :: b real(kind=qp), intent(in), optional :: rel_tol real(kind=qp), intent(in), optional :: abs_tol Return Value logical private elemental module function is_close_csp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: a complex(kind=sp), intent(in) :: b real(kind=sp), intent(in), optional :: rel_tol real(kind=sp), intent(in), optional :: abs_tol Return Value logical private elemental module function is_close_rdp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b real(kind=dp), intent(in), optional :: rel_tol real(kind=dp), intent(in), optional :: abs_tol Return Value logical private elemental module function is_close_rqp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: a real(kind=qp), intent(in) :: b real(kind=qp), intent(in), optional :: rel_tol real(kind=qp), intent(in), optional :: abs_tol Return Value logical private elemental module function is_close_rsp(a, b, rel_tol, abs_tol) result(close) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a real(kind=sp), intent(in) :: b real(kind=sp), intent(in), optional :: rel_tol real(kind=sp), intent(in), optional :: abs_tol Return Value logical public interface signum signum returns the sign of variables.\n( Specification ) private elemental module function signum_cdp(x) result(sign) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x Return Value complex(kind=dp) private elemental module function signum_cqp(x) result(sign) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x Return Value complex(kind=qp) private elemental module function signum_csp(x) result(sign) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x Return Value complex(kind=sp) private elemental module function signum_iint16(x) result(sign) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x Return Value integer(kind=int16) private elemental module function signum_iint32(x) result(sign) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x Return Value integer(kind=int32) private elemental module function signum_iint64(x) result(sign) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x Return Value integer(kind=int64) private elemental module function signum_iint8(x) result(sign) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x Return Value integer(kind=int8) private elemental module function signum_rdp(x) result(sign) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private elemental module function signum_rqp(x) result(sign) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private elemental module function signum_rsp(x) result(sign) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) public interface sind private pure elemental module function sind_dp(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function sind_qp(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private pure elemental module function sind_sp(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) public interface tand private pure elemental module function tand_dp(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) private pure elemental module function tand_qp(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x Return Value real(kind=qp) private pure elemental module function tand_sp(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp)","tags":"","loc":"module/forlab_math.html"},{"title":"forlab_io – FORLAB","text":"Uses stdlib_strings stdlib_kinds stdlib_io stdlib_string_type stdlib_optval stdlib_error Used by Descendants: forlab_io_bin forlab_io_color forlab_io_disp forlab_io_progress_bar forlab_io_progress_perc forlab__io_txt Contents Interfaces color countlines disp file file_exist loadbin loadtxt progress_bar progress_perc savebin savetxt Derived Types file Interfaces interface color sets color for console text.\n( Specification ) public module module subroutine color(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string public interface countlines private function countlines2(filename) The countlines2 function returns the number of lines of the file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value integer public interface disp Display a scalar, vector or matrix.\n( Specification ) private module subroutine disp_0_cdp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_cqp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_csp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_iint16(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_iint32(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_iint64(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_iint8(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_lc_bool(x, header, unit, brief) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_llk(x, header, unit, brief) Arguments Type Intent Optional Attributes Name logical(kind=lk), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_rdp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_rqp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_0_rsp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_cdp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_cqp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_csp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_iint16(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_iint32(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_iint64(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_iint8(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_lc_bool(x, header, unit, brief) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_llk(x, header, unit, brief) Arguments Type Intent Optional Attributes Name logical(kind=lk), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_rdp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_rqp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_1_rsp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_cdp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_cqp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_csp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_iint16(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_iint32(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_iint64(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_iint8(x, header, unit, brief) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_lc_bool(x, header, unit, brief) Arguments Type Intent Optional Attributes Name logical(kind=c_bool), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_llk(x, header, unit, brief) Arguments Type Intent Optional Attributes Name logical(kind=lk), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_rdp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_rqp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_2_rsp(x, header, unit, brief) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_character(x, header, unit, brief) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief private module subroutine disp_string_type(x, header, unit, brief) Arguments Type Intent Optional Attributes Name type(string_type), intent(in) :: x character(len=*), intent(in), optional :: header integer, intent(in), optional :: unit logical, intent(in), optional :: brief public interface file private function init_file(filename, mode) File constructs a File object. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: mode Return Value type( file ) public interface file_exist private function file_exist2(filename) The countlines2 function returns the number of lines of the file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical public interface loadbin private module subroutine loadbin_1_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_1_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(out), dimension(:), allocatable :: X private module subroutine loadbin_2_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_2_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadbin_3_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(out), dimension(:, :, :), allocatable :: X private module subroutine loadbin_3_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(out), dimension(:, :, :), allocatable :: X public interface loadtxt private module subroutine loadtxt_1_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_1_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(out), dimension(:), allocatable :: X private module subroutine loadtxt_2_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(out), dimension(:, :), allocatable :: X private module subroutine loadtxt_2_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(out), dimension(:, :), allocatable :: X public interface progress_bar Print a progress_bar.\n( Specification ) private module subroutine progress_bar_int16(iter, itermax, step, symbol) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: iter integer(kind=int16), intent(in) :: itermax integer(kind=int16), intent(in), optional :: step character, intent(in), optional :: symbol private module subroutine progress_bar_int32(iter, itermax, step, symbol) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter integer(kind=int32), intent(in) :: itermax integer(kind=int32), intent(in), optional :: step character, intent(in), optional :: symbol private module subroutine progress_bar_int64(iter, itermax, step, symbol) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: iter integer(kind=int64), intent(in) :: itermax integer(kind=int64), intent(in), optional :: step character, intent(in), optional :: symbol private module subroutine progress_bar_int8(iter, itermax, step, symbol) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: iter integer(kind=int8), intent(in) :: itermax integer(kind=int8), intent(in), optional :: step character, intent(in), optional :: symbol public interface progress_perc Print a progress percentage message.\n( Specification ) private module subroutine progress_perc_int16(iter, itermax, prefix) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: iter integer(kind=int16), intent(in) :: itermax character, intent(in), optional :: prefix private module subroutine progress_perc_int32(iter, itermax, prefix) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter integer(kind=int32), intent(in) :: itermax character, intent(in), optional :: prefix private module subroutine progress_perc_int64(iter, itermax, prefix) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: iter integer(kind=int64), intent(in) :: itermax character, intent(in), optional :: prefix private module subroutine progress_perc_int8(iter, itermax, prefix) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: iter integer(kind=int8), intent(in) :: itermax character, intent(in), optional :: prefix public interface savebin private module subroutine savebin_1_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in), dimension(:) :: X private module subroutine savebin_1_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in), dimension(:) :: X private module subroutine savebin_1_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in), dimension(:) :: X private module subroutine savebin_1_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in), dimension(:) :: X private module subroutine savebin_1_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in), dimension(:) :: X private module subroutine savebin_1_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in), dimension(:) :: X private module subroutine savebin_1_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in), dimension(:) :: X private module subroutine savebin_1_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in), dimension(:) :: X private module subroutine savebin_1_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in), dimension(:) :: X private module subroutine savebin_1_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in), dimension(:) :: X private module subroutine savebin_2_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in), dimension(:, :) :: X private module subroutine savebin_2_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in), dimension(:, :) :: X private module subroutine savebin_2_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in), dimension(:, :) :: X private module subroutine savebin_2_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in), dimension(:, :) :: X private module subroutine savebin_2_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in), dimension(:, :) :: X private module subroutine savebin_2_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in), dimension(:, :) :: X private module subroutine savebin_2_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in), dimension(:, :) :: X private module subroutine savebin_2_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in), dimension(:, :) :: X private module subroutine savebin_2_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in), dimension(:, :) :: X private module subroutine savebin_2_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in), dimension(:, :) :: X private module subroutine savebin_3_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in), dimension(:, :, :) :: X private module subroutine savebin_3_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in), dimension(:, :, :) :: X public interface savetxt private module subroutine savetxt_1_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in), dimension(:) :: X private module subroutine savetxt_1_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in), dimension(:) :: X private module subroutine savetxt_1_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in), dimension(:) :: X private module subroutine savetxt_1_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in), dimension(:) :: X private module subroutine savetxt_1_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in), dimension(:) :: X private module subroutine savetxt_1_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in), dimension(:) :: X private module subroutine savetxt_1_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in), dimension(:) :: X private module subroutine savetxt_1_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in), dimension(:) :: X private module subroutine savetxt_1_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in), dimension(:) :: X private module subroutine savetxt_1_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in), dimension(:) :: X private module subroutine savetxt_2_cdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_cqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_csp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_iint16(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_iint32(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_iint64(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_iint8(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_rdp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_rqp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in), dimension(:, :) :: X private module subroutine savetxt_2_rsp(filename, X) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in), dimension(:, :) :: X Derived Types type, public :: file forlab file derived type.\n( Specification ) Constructor private  function init_file (filename, mode) File constructs a File object. Read more… Type-Bound Procedures procedure, public :: close procedure, public :: countlines => countlines1 procedure, public :: exist => file_exist1 procedure, public :: open => open_file","tags":"","loc":"module/forlab_io.html"},{"title":"forlab_time – FORLAB","text":"Uses stdlib_kinds forlab_io Used by Descendants: forlab_time_datenum forlab_time_tioc Contents Interfaces datenum is_leap tic toc Functions time_string Interfaces public interface datenum private module function datenum0(year, month, day, hour, minute, second, microsecond) Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(in) :: month integer, intent(in) :: day integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: microsecond Return Value real(kind=dp) public interface is_leap private function is_leap_int8(year) result(is_leap) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: year Return Value logical private function is_leap_int16(year) result(is_leap) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: year Return Value logical private function is_leap_int32(year) result(is_leap) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: year Return Value logical private function is_leap_int64(year) result(is_leap) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: year Return Value logical interface public module module subroutine tic() Arguments None public interface toc private module subroutine toc_default() Arguments None private module subroutine toc_dp(time) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: time private module subroutine toc_qp(time) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(out) :: time private module subroutine toc_sp(time) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: time Functions public function time_string () Arguments None Return Value character(len=19)","tags":"","loc":"module/forlab_time.html"},{"title":"forlab_linalg – FORLAB","text":"Uses stdlib_error stdlib_kinds stdlib_optval forlab_sorting Used by Descendants: forlab_linalg_cat forlab_linalg_chol forlab_linalg_det forlab_linalg_diag forlab_linalg_diff forlab_linalg_eig forlab_linalg_eye forlab_linalg_inv forlab_linalg_linspace forlab_linalg_lu forlab_linalg_matpow forlab_linalg_norm forlab_linalg_outer forlab_linalg_qr forlab_linalg_seq forlab_linalg_solve forlab_linalg_svd forlab_linalg_svdsolve forlab_linalg_tri Contents Interfaces chol det diag diff eye horzcat inv is_square is_symmetric linspace logspace lu matpow norm ones operator(.i.) operator(.x.) outer qr seq solve svd svdsolve trace tril triu vertcat zeros Interfaces public interface chol chol computes Cholesky's decomposition of a symmetric positive\ndefinite matrix. private module function chol_dp(A) result(L) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function chol_qp(A) result(L) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function chol_sp(A) result(L) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A Return Value real(kind=sp),\n  dimension(:, :), allocatable public interface det det computes the matrix determinant. private module function det_dp(A, outL, outU) result(det) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(inout), optional dimension(:, :), allocatable :: outL real(kind=dp), intent(inout), optional dimension(:, :), allocatable :: outU Return Value real(kind=dp) private module function det_qp(A, outL, outU) result(det) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A real(kind=qp), intent(inout), optional dimension(:, :), allocatable :: outL real(kind=qp), intent(inout), optional dimension(:, :), allocatable :: outU Return Value real(kind=qp) private module function det_sp(A, outL, outU) result(det) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A real(kind=sp), intent(inout), optional dimension(:, :), allocatable :: outL real(kind=sp), intent(inout), optional dimension(:, :), allocatable :: outU Return Value real(kind=sp) public interface diag diag creates diagonal matrix or get the diagonal of a matrix. private module function diag1_dp(A) result(diag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp),\n  dimension(:), allocatable private module function diag1_qp(A) result(diag) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A Return Value real(kind=qp),\n  dimension(:), allocatable private module function diag1_sp(A) result(diag) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A Return Value real(kind=sp),\n  dimension(:), allocatable private module function diag2_dp(x) result(diag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function diag2_qp(x) result(diag) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function diag2_sp(x) result(diag) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp),\n  dimension(:, :), allocatable public interface diff diff computes differences of arrays.\n( Specification ) private pure module function diff_1_dp(x, n) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value real(kind=dp),\n  dimension(:), allocatable private pure module function diff_1_int16(x, n) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value integer(kind=int16),\n  dimension(:), allocatable private pure module function diff_1_int32(x, n) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value integer(kind=int32),\n  dimension(:), allocatable private pure module function diff_1_int64(x, n) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value integer(kind=int64),\n  dimension(:), allocatable private pure module function diff_1_int8(x, n) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value integer(kind=int8),\n  dimension(:), allocatable private pure module function diff_1_qp(x, n) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value real(kind=qp),\n  dimension(:), allocatable private pure module function diff_1_sp(x, n) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: n Return Value real(kind=sp),\n  dimension(:), allocatable private pure module function diff_2_dp(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value real(kind=dp),\n  dimension(:, :), allocatable private pure module function diff_2_int16(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value integer(kind=int16),\n  dimension(:, :), allocatable private pure module function diff_2_int32(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value integer(kind=int32),\n  dimension(:, :), allocatable private pure module function diff_2_int64(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value integer(kind=int64),\n  dimension(:, :), allocatable private pure module function diff_2_int8(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value integer(kind=int8),\n  dimension(:, :), allocatable private pure module function diff_2_qp(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value real(kind=qp),\n  dimension(:, :), allocatable private pure module function diff_2_sp(A, n, dim) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: n integer, intent(in), optional :: dim Return Value real(kind=sp),\n  dimension(:, :), allocatable public interface eye private module subroutine eye_dp(X) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: X (:,:) private module subroutine eye_qp(X) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(out) :: X (:,:) private module subroutine eye_sp(X) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: X (:,:) public interface horzcat private module function horzcat_c_12_dp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: x1 complex(kind=dp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_c_12_qp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:) :: x1 complex(kind=qp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_c_12_sp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:) :: x1 complex(kind=sp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_c_1_dp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: x1 complex(kind=dp), intent(in), dimension(:) :: x2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_c_1_qp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:) :: x1 complex(kind=qp), intent(in), dimension(:) :: x2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_c_1_sp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:) :: x1 complex(kind=sp), intent(in), dimension(:) :: x2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_c_21_dp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A1 complex(kind=dp), intent(in), dimension(:) :: x2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_c_21_qp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A1 complex(kind=qp), intent(in), dimension(:) :: x2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_c_21_sp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A1 complex(kind=sp), intent(in), dimension(:) :: x2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_c_2_dp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A1 complex(kind=dp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_c_2_qp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A1 complex(kind=qp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_c_2_sp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A1 complex(kind=sp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_i_12_int16(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x1 integer(kind=int16), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function horzcat_i_12_int32(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x1 integer(kind=int32), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function horzcat_i_12_int64(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x1 integer(kind=int64), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function horzcat_i_12_int8(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x1 integer(kind=int8), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function horzcat_i_1_int16(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x1 integer(kind=int16), intent(in), dimension(:) :: x2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function horzcat_i_1_int32(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x1 integer(kind=int32), intent(in), dimension(:) :: x2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function horzcat_i_1_int64(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x1 integer(kind=int64), intent(in), dimension(:) :: x2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function horzcat_i_1_int8(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x1 integer(kind=int8), intent(in), dimension(:) :: x2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function horzcat_i_21_int16(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A1 integer(kind=int16), intent(in), dimension(:) :: x2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function horzcat_i_21_int32(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A1 integer(kind=int32), intent(in), dimension(:) :: x2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function horzcat_i_21_int64(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A1 integer(kind=int64), intent(in), dimension(:) :: x2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function horzcat_i_21_int8(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A1 integer(kind=int8), intent(in), dimension(:) :: x2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function horzcat_i_2_int16(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A1 integer(kind=int16), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function horzcat_i_2_int32(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A1 integer(kind=int32), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function horzcat_i_2_int64(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A1 integer(kind=int64), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function horzcat_i_2_int8(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A1 integer(kind=int8), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function horzcat_r_12_dp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x1 real(kind=dp), intent(in), dimension(:, :) :: A2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_r_12_qp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x1 real(kind=qp), intent(in), dimension(:, :) :: A2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_r_12_sp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x1 real(kind=sp), intent(in), dimension(:, :) :: A2 Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_r_1_dp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x1 real(kind=dp), intent(in), dimension(:) :: x2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_r_1_qp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x1 real(kind=qp), intent(in), dimension(:) :: x2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_r_1_sp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x1 real(kind=sp), intent(in), dimension(:) :: x2 Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_r_21_dp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A1 real(kind=dp), intent(in), dimension(:) :: x2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_r_21_qp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A1 real(kind=qp), intent(in), dimension(:) :: x2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_r_21_sp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A1 real(kind=sp), intent(in), dimension(:) :: x2 Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function horzcat_r_2_dp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A1 real(kind=dp), intent(in), dimension(:, :) :: A2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function horzcat_r_2_qp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A1 real(kind=qp), intent(in), dimension(:, :) :: A2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function horzcat_r_2_sp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A1 real(kind=sp), intent(in), dimension(:, :) :: A2 Return Value real(kind=sp),\n  dimension(:, :), allocatable public interface inv private module function inv_cdp(A) result(inv) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function inv_cqp(A) result(inv) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function inv_csp(A) result(inv) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function inv_rdp(A) result(inv) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function inv_rqp(A) result(inv) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function inv_rsp(A) result(inv) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A Return Value real(kind=sp),\n  dimension(:, :), allocatable public interface is_square private function is_square_rsp(A) result(is_square) real(sp) matrix is square or not. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value logical private function is_square_rdp(A) result(is_square) real(dp) matrix is square or not. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value logical private function is_square_rqp(A) result(is_square) real(qp) matrix is square or not. Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value logical private function is_square_csp(A) result(is_square) complex(sp) matrix is square or not. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value logical private function is_square_cdp(A) result(is_square) complex(dp) matrix is square or not. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value logical private function is_square_cqp(A) result(is_square) complex(qp) matrix is square or not. Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value logical public interface is_symmetric private function is_symmetric_rsp(A) result(is_symmetric) real(sp) matrix is symmetric or not. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value logical private function is_symmetric_rdp(A) result(is_symmetric) real(dp) matrix is symmetric or not. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value logical private function is_symmetric_rqp(A) result(is_symmetric) real(qp) matrix is symmetric or not. Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value logical private function is_symmetric_csp(A) result(is_symmetric) complex(sp) matrix is symmetric or not. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value logical private function is_symmetric_cdp(A) result(is_symmetric) complex(dp) matrix is symmetric or not. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value logical private function is_symmetric_cqp(A) result(is_symmetric) complex(qp) matrix is symmetric or not. Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value logical public interface linspace private pure module subroutine linspace_dp(X, from, to) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: X (:) real(kind=dp), intent(in) :: from real(kind=dp), intent(in) :: to private pure module subroutine linspace_qp(X, from, to) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(out) :: X (:) real(kind=qp), intent(in) :: from real(kind=qp), intent(in) :: to private pure module subroutine linspace_sp(X, from, to) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: X (:) real(kind=sp), intent(in) :: from real(kind=sp), intent(in) :: to public interface logspace private pure module subroutine logspace_dp(X, from, to) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: X (:) real(kind=dp), intent(in) :: from real(kind=dp), intent(in) :: to private pure module subroutine logspace_qp(X, from, to) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(out) :: X (:) real(kind=qp), intent(in) :: from real(kind=qp), intent(in) :: to private pure module subroutine logspace_sp(X, from, to) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: X (:) real(kind=sp), intent(in) :: from real(kind=sp), intent(in) :: to public interface lu lu computes the LU matrix factorization. private module subroutine lu_dp(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(out), dimension(:, :), allocatable :: L real(kind=dp), intent(out), dimension(:, :), allocatable :: U private module subroutine lu_qp(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A real(kind=qp), intent(out), dimension(:, :), allocatable :: L real(kind=qp), intent(out), dimension(:, :), allocatable :: U private module subroutine lu_sp(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A real(kind=sp), intent(out), dimension(:, :), allocatable :: L real(kind=sp), intent(out), dimension(:, :), allocatable :: U public interface matpow Calculat matrix power private module function matpow_dp(a, num) result(c) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:,:) :: a integer :: num Return Value real(kind=dp),\n  allocatable, (:,:) private module function matpow_qp(a, num) result(c) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:,:) :: a integer :: num Return Value real(kind=qp),\n  allocatable, (:,:) private module function matpow_sp(a, num) result(c) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:,:) :: a integer :: num Return Value real(kind=sp),\n  allocatable, (:,:) public interface norm norm computes vector and matrix norms. private module function norm1_dp(x, p) result(norm1) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), optional :: p Return Value real(kind=dp) private module function norm1_qp(x, p) result(norm1) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x real(kind=qp), intent(in), optional :: p Return Value real(kind=qp) private module function norm1_sp(x, p) result(norm1) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x real(kind=sp), intent(in), optional :: p Return Value real(kind=sp) private module function norm2_dp(A, p) result(norm2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:,:) :: A real(kind=dp), intent(in), optional :: p Return Value real(kind=dp) private module function norm2_qp(A, p) result(norm2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:,:) :: A real(kind=qp), intent(in), optional :: p Return Value real(kind=qp) private module function norm2_sp(A, p) result(norm2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:,:) :: A real(kind=sp), intent(in), optional :: p Return Value real(kind=sp) public interface ones Creates a rank-1 or rank-2 array filled ones.\n( Specification ) private pure function ones_1_default(dim) result(result) ones creates a rank-1 array, filled completely with 1 integer type values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim Return Value integer(kind=int8),\n  allocatable, (:) private pure function ones_2_default(dim1, dim2) result(result) ones creates a rank-2 array, filled completely with 1 integer type values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim1 integer, intent(in) :: dim2 Return Value integer(kind=int8),\n  allocatable, (:,:) public interface operator(.i.) Calculate the inverse of a real matrix. private module function inv_rsp(A) result(inv) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function inv_rdp(A) result(inv) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function inv_rqp(A) result(inv) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function inv_csp(A) result(inv) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function inv_cdp(A) result(inv) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function inv_cqp(A) result(inv) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A Return Value complex(kind=qp),\n  dimension(:, :), allocatable public interface operator(.x.) private function rmut_sp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: m1 (:,:) real(kind=sp), intent(in) :: m2 (:,:) Return Value real(kind=sp)\n  (size(m1,1),size(m2,2)) private function rmut_dp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: m1 (:,:) real(kind=dp), intent(in) :: m2 (:,:) Return Value real(kind=dp)\n  (size(m1,1),size(m2,2)) private function rmut_qp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: m1 (:,:) real(kind=qp), intent(in) :: m2 (:,:) Return Value real(kind=qp)\n  (size(m1,1),size(m2,2)) private function cmut_sp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: m1 (:,:) complex(kind=sp), intent(in) :: m2 (:,:) Return Value complex(kind=sp)\n  (size(m1,1),size(m2,2)) private function cmut_dp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: m1 (:,:) complex(kind=dp), intent(in) :: m2 (:,:) Return Value complex(kind=dp)\n  (size(m1,1),size(m2,2)) private function cmut_qp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: m1 (:,:) complex(kind=qp), intent(in) :: m2 (:,:) Return Value complex(kind=qp)\n  (size(m1,1),size(m2,2)) private function rcmut_sp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: m1 (:,:) complex(kind=sp), intent(in) :: m2 (:,:) Return Value complex(kind=sp)\n  (size(m1,1),size(m2,2)) private function rcmut_dp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: m1 (:,:) complex(kind=dp), intent(in) :: m2 (:,:) Return Value complex(kind=dp)\n  (size(m1,1),size(m2,2)) private function rcmut_qp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: m1 (:,:) complex(kind=qp), intent(in) :: m2 (:,:) Return Value complex(kind=qp)\n  (size(m1,1),size(m2,2)) private function crmut_sp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: m1 (:,:) real(kind=sp), intent(in) :: m2 (:,:) Return Value complex(kind=sp)\n  (size(m1,1),size(m2,2)) private function crmut_dp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: m1 (:,:) real(kind=dp), intent(in) :: m2 (:,:) Return Value complex(kind=dp)\n  (size(m1,1),size(m2,2)) private function crmut_qp(m1, m2) result(res) complex(qp) matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: m1 (:,:) real(kind=qp), intent(in) :: m2 (:,:) Return Value complex(kind=qp)\n  (size(m1,1),size(m2,2)) public interface outer private module function outer_dp(x, y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x real(kind=dp), intent(in), dimension(:) :: y Return Value real(kind=dp),\n  dimension(:,:), allocatable private module function outer_int16(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x integer(kind=int16), intent(in), dimension(:) :: y Return Value integer(kind=int16),\n  dimension(:,:), allocatable private module function outer_int32(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x integer(kind=int32), intent(in), dimension(:) :: y Return Value integer(kind=int32),\n  dimension(:,:), allocatable private module function outer_int64(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x integer(kind=int64), intent(in), dimension(:) :: y Return Value integer(kind=int64),\n  dimension(:,:), allocatable private module function outer_int8(x, y) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x integer(kind=int8), intent(in), dimension(:) :: y Return Value integer(kind=int8),\n  dimension(:,:), allocatable private module function outer_qp(x, y) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x real(kind=qp), intent(in), dimension(:) :: y Return Value real(kind=qp),\n  dimension(:,:), allocatable private module function outer_sp(x, y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x real(kind=sp), intent(in), dimension(:) :: y Return Value real(kind=sp),\n  dimension(:,:), allocatable public interface qr private module subroutine qr_dp(a, q, r, l) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a (:,:) real(kind=dp), intent(out), allocatable :: q (:,:) real(kind=dp), intent(out), allocatable :: r (:,:) integer, optional :: l private module subroutine qr_qp(a, q, r, l) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: a (:,:) real(kind=qp), intent(out), allocatable :: q (:,:) real(kind=qp), intent(out), allocatable :: r (:,:) integer, optional :: l private module subroutine qr_sp(a, q, r, l) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a (:,:) real(kind=sp), intent(out), allocatable :: q (:,:) real(kind=sp), intent(out), allocatable :: r (:,:) integer, optional :: l public interface seq seq returns evenly spaced vector. private module subroutine seq_dp(X, from, to, by) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), dimension(:), allocatable :: X real(kind=dp), intent(in) :: from real(kind=dp), intent(in) :: to real(kind=dp), intent(in), optional :: by private module subroutine seq_int16(X, from, to, by) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(out), dimension(:), allocatable :: X integer(kind=int16), intent(in) :: from integer(kind=int16), intent(in) :: to integer(kind=int16), intent(in), optional :: by private module subroutine seq_int32(X, from, to, by) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(out), dimension(:), allocatable :: X integer(kind=int32), intent(in) :: from integer(kind=int32), intent(in) :: to integer(kind=int32), intent(in), optional :: by private module subroutine seq_int64(X, from, to, by) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(out), dimension(:), allocatable :: X integer(kind=int64), intent(in) :: from integer(kind=int64), intent(in) :: to integer(kind=int64), intent(in), optional :: by private module subroutine seq_int8(X, from, to, by) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(out), dimension(:), allocatable :: X integer(kind=int8), intent(in) :: from integer(kind=int8), intent(in) :: to integer(kind=int8), intent(in), optional :: by private module subroutine seq_qp(X, from, to, by) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(out), dimension(:), allocatable :: X real(kind=qp), intent(in) :: from real(kind=qp), intent(in) :: to real(kind=qp), intent(in), optional :: by private module subroutine seq_sp(X, from, to, by) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out), dimension(:), allocatable :: X real(kind=sp), intent(in) :: from real(kind=sp), intent(in) :: to real(kind=sp), intent(in), optional :: by public interface solve private module function solve_dp(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in), dimension(:) :: b Return Value real(kind=dp),\n  dimension(:), allocatable private module function solve_qp(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A real(kind=qp), intent(in), dimension(:) :: b Return Value real(kind=qp),\n  dimension(:), allocatable private module function solve_sp(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A real(kind=sp), intent(in), dimension(:) :: b Return Value real(kind=sp),\n  dimension(:), allocatable public interface svd private module subroutine svd_dp(a, w, u, v, d, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: a real(kind=dp), intent(out), dimension(:), allocatable :: w real(kind=dp), intent(out), optional dimension(:, :), allocatable :: u real(kind=dp), intent(out), optional dimension(:, :), allocatable :: v logical, intent(in), optional :: d integer, intent(out), optional :: ierr private module subroutine svd_qp(a, w, u, v, d, ierr) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: a real(kind=qp), intent(out), dimension(:), allocatable :: w real(kind=qp), intent(out), optional dimension(:, :), allocatable :: u real(kind=qp), intent(out), optional dimension(:, :), allocatable :: v logical, intent(in), optional :: d integer, intent(out), optional :: ierr private module subroutine svd_sp(a, w, u, v, d, ierr) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: a real(kind=sp), intent(out), dimension(:), allocatable :: w real(kind=sp), intent(out), optional dimension(:, :), allocatable :: u real(kind=sp), intent(out), optional dimension(:, :), allocatable :: v logical, intent(in), optional :: d integer, intent(out), optional :: ierr public interface svdsolve private module function svdsolve_dp(A, b, cutoff) result(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A real(kind=dp), intent(in), dimension(:) :: b integer, intent(in), optional :: cutoff Return Value real(kind=dp),\n  dimension(:), allocatable private module function svdsolve_qp(A, b, cutoff) result(x) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A real(kind=qp), intent(in), dimension(:) :: b integer, intent(in), optional :: cutoff Return Value real(kind=qp),\n  dimension(:), allocatable private module function svdsolve_sp(A, b, cutoff) result(x) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A real(kind=sp), intent(in), dimension(:) :: b integer, intent(in), optional :: cutoff Return Value real(kind=sp),\n  dimension(:), allocatable public interface trace private function trace_sp(A) result(trace) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A Return Value real(kind=sp) private function trace_dp(A) result(trace) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A Return Value real(kind=dp) private function trace_qp(A) result(trace) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A Return Value real(kind=qp) public interface tril private module function tril_cdp(A, k) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function tril_cqp(A, k) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function tril_csp(A, k) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function tril_dp(A, k) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function tril_int16(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function tril_int32(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function tril_int64(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function tril_int8(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function tril_qp(A, k) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function tril_sp(A, k) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value real(kind=sp),\n  dimension(:, :), allocatable public interface triu private module function triu_cdp(A, k) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function triu_cqp(A, k) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function triu_csp(A, k) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function triu_dp(A, k) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function triu_int16(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function triu_int32(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function triu_int64(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function triu_int8(A, k) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function triu_qp(A, k) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function triu_sp(A, k) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: k Return Value real(kind=sp),\n  dimension(:, :), allocatable public interface vertcat private module function vertcat_c_12_dp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: x1 complex(kind=dp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_c_12_qp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:) :: x1 complex(kind=qp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_c_12_sp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:) :: x1 complex(kind=sp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_c_1_dp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: x1 complex(kind=dp), intent(in), dimension(:) :: x2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_c_1_qp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:) :: x1 complex(kind=qp), intent(in), dimension(:) :: x2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_c_1_sp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:) :: x1 complex(kind=sp), intent(in), dimension(:) :: x2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_c_21_dp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A1 complex(kind=dp), intent(in), dimension(:) :: x2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_c_21_qp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A1 complex(kind=qp), intent(in), dimension(:) :: x2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_c_21_sp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A1 complex(kind=sp), intent(in), dimension(:) :: x2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_c_2_dp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: A1 complex(kind=dp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_c_2_qp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), dimension(:, :) :: A1 complex(kind=qp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_c_2_sp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), dimension(:, :) :: A1 complex(kind=sp), intent(in), dimension(:, :) :: A2 Return Value complex(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_i_12_int16(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x1 integer(kind=int16), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function vertcat_i_12_int32(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x1 integer(kind=int32), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function vertcat_i_12_int64(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x1 integer(kind=int64), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function vertcat_i_12_int8(x1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x1 integer(kind=int8), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function vertcat_i_1_int16(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x1 integer(kind=int16), intent(in), dimension(:) :: x2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function vertcat_i_1_int32(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x1 integer(kind=int32), intent(in), dimension(:) :: x2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function vertcat_i_1_int64(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x1 integer(kind=int64), intent(in), dimension(:) :: x2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function vertcat_i_1_int8(x1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x1 integer(kind=int8), intent(in), dimension(:) :: x2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function vertcat_i_21_int16(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A1 integer(kind=int16), intent(in), dimension(:) :: x2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function vertcat_i_21_int32(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A1 integer(kind=int32), intent(in), dimension(:) :: x2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function vertcat_i_21_int64(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A1 integer(kind=int64), intent(in), dimension(:) :: x2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function vertcat_i_21_int8(A1, x2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A1 integer(kind=int8), intent(in), dimension(:) :: x2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function vertcat_i_2_int16(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:, :) :: A1 integer(kind=int16), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int16),\n  dimension(:, :), allocatable private module function vertcat_i_2_int32(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:, :) :: A1 integer(kind=int32), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int32),\n  dimension(:, :), allocatable private module function vertcat_i_2_int64(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:, :) :: A1 integer(kind=int64), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int64),\n  dimension(:, :), allocatable private module function vertcat_i_2_int8(A1, A2) result(result) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:, :) :: A1 integer(kind=int8), intent(in), dimension(:, :) :: A2 Return Value integer(kind=int8),\n  dimension(:, :), allocatable private module function vertcat_r_12_dp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x1 real(kind=dp), intent(in), dimension(:, :) :: A2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_r_12_qp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x1 real(kind=qp), intent(in), dimension(:, :) :: A2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_r_12_sp(x1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x1 real(kind=sp), intent(in), dimension(:, :) :: A2 Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_r_1_dp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x1 real(kind=dp), intent(in), dimension(:) :: x2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_r_1_qp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x1 real(kind=qp), intent(in), dimension(:) :: x2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_r_1_sp(x1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x1 real(kind=sp), intent(in), dimension(:) :: x2 Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_r_21_dp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A1 real(kind=dp), intent(in), dimension(:) :: x2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_r_21_qp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A1 real(kind=qp), intent(in), dimension(:) :: x2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_r_21_sp(A1, x2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A1 real(kind=sp), intent(in), dimension(:) :: x2 Return Value real(kind=sp),\n  dimension(:, :), allocatable private module function vertcat_r_2_dp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A1 real(kind=dp), intent(in), dimension(:, :) :: A2 Return Value real(kind=dp),\n  dimension(:, :), allocatable private module function vertcat_r_2_qp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A1 real(kind=qp), intent(in), dimension(:, :) :: A2 Return Value real(kind=qp),\n  dimension(:, :), allocatable private module function vertcat_r_2_sp(A1, A2) result(result) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A1 real(kind=sp), intent(in), dimension(:, :) :: A2 Return Value real(kind=sp),\n  dimension(:, :), allocatable public interface zeros Creates a rank-1 or rank-2 array filled zeros.\n( Specification ) private pure function zeros_1_default(dim) result(result) zeros creates a rank-1 array, filled completely with 0 integer type values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim Return Value integer(kind=int8),\n  allocatable, (:) private pure function zeros_2_default(dim1, dim2) result(result) zeros creates a rank-2 array, filled completely with 0 integer type values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: dim1 integer, intent(in) :: dim2 Return Value integer(kind=int8),\n  allocatable, (:,:)","tags":"","loc":"module/forlab_linalg.html"},{"title":"forlab_stats – FORLAB","text":"Uses stdlib_kinds Used by Descendants: forlab_stats_mean forlab_stats_randn forlab_stats_randu forlab_stats_rng forlab_stats_var Contents Interfaces mean randn randu rng std var Interfaces public interface mean mean computes the mean value of an array. private module function mean_1_dp(x) result(mean) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp) private module function mean_1_qp(x) result(mean) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp) private module function mean_1_sp(x) result(mean) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp) private module function mean_2_dp(A, dim) result(mean) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: dim Return Value real(kind=dp),\n  dimension(:), allocatable private module function mean_2_qp(A, dim) result(mean) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: dim Return Value real(kind=qp),\n  dimension(:), allocatable private module function mean_2_sp(A, dim) result(mean) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: dim Return Value real(kind=sp),\n  dimension(:), allocatable public interface randn Generate a normal distributed data scalar or vector.\n( Specification ) private module function randn_0_dp(mean, std) result(random) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mean real(kind=dp), intent(in) :: std Return Value real(kind=dp) private module function randn_0_qp(mean, std) result(random) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: mean real(kind=qp), intent(in) :: std Return Value real(kind=qp) private module function randn_0_sp(mean, std) result(random) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: mean real(kind=sp), intent(in) :: std Return Value real(kind=sp) private module function randn_1_dp(mean, std, ndim) result(random) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mean real(kind=dp), intent(in) :: std integer, intent(in) :: ndim Return Value real(kind=dp)\n  (ndim) private module function randn_1_qp(mean, std, ndim) result(random) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: mean real(kind=qp), intent(in) :: std integer, intent(in) :: ndim Return Value real(kind=qp)\n  (ndim) private module function randn_1_sp(mean, std, ndim) result(random) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: mean real(kind=sp), intent(in) :: std integer, intent(in) :: ndim Return Value real(kind=sp)\n  (ndim) public interface randu Generate an uniformly distributed data scalar or vector.\n( Specification ) private module function randu_0_iint16(start, end) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: start integer(kind=int16), intent(in) :: end Return Value integer(kind=int16) private module function randu_0_iint32(start, end) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: start integer(kind=int32), intent(in) :: end Return Value integer(kind=int32) private module function randu_0_iint64(start, end) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: start integer(kind=int64), intent(in) :: end Return Value integer(kind=int64) private module function randu_0_iint8(start, end) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: start integer(kind=int8), intent(in) :: end Return Value integer(kind=int8) private module function randu_0_rdp(start, end) result(random) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end Return Value real(kind=dp) private module function randu_0_rqp(start, end) result(random) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end Return Value real(kind=qp) private module function randu_0_rsp(start, end) result(random) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end Return Value real(kind=sp) private module function randu_1_iint16(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: start integer(kind=int16), intent(in) :: end integer, intent(in) :: ndim Return Value integer(kind=int16)\n  (ndim) private module function randu_1_iint32(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: start integer(kind=int32), intent(in) :: end integer, intent(in) :: ndim Return Value integer(kind=int32)\n  (ndim) private module function randu_1_iint64(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: start integer(kind=int64), intent(in) :: end integer, intent(in) :: ndim Return Value integer(kind=int64)\n  (ndim) private module function randu_1_iint8(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: start integer(kind=int8), intent(in) :: end integer, intent(in) :: ndim Return Value integer(kind=int8)\n  (ndim) private module function randu_1_rdp(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: start real(kind=dp), intent(in) :: end integer, intent(in) :: ndim Return Value real(kind=dp)\n  (ndim) private module function randu_1_rqp(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: start real(kind=qp), intent(in) :: end integer, intent(in) :: ndim Return Value real(kind=qp)\n  (ndim) private module function randu_1_rsp(start, end, ndim) result(random) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: start real(kind=sp), intent(in) :: end integer, intent(in) :: ndim Return Value real(kind=sp)\n  (ndim) interface public module module subroutine rng(seed) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: seed public interface std std computes vector and matrix standard deviations.\n( Specification ) private module function std_1_dp(x, w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: w Return Value real(kind=dp) private module function std_1_qp(x, w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: w Return Value real(kind=qp) private module function std_1_sp(x, w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: w Return Value real(kind=sp) private module function std_2_dp(A, w, dim) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: w integer, intent(in), optional :: dim Return Value real(kind=dp),\n  dimension(:), allocatable private module function std_2_qp(A, w, dim) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: w integer, intent(in), optional :: dim Return Value real(kind=qp),\n  dimension(:), allocatable private module function std_2_sp(A, w, dim) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: w integer, intent(in), optional :: dim Return Value real(kind=sp),\n  dimension(:), allocatable public interface var var computes vector and matrix variances.\n( Specification ) private module function var_1_dp(x, w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: w Return Value real(kind=dp) private module function var_1_qp(x, w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: w Return Value real(kind=qp) private module function var_1_sp(x, w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: w Return Value real(kind=sp) private module function var_2_dp(A, w, dim) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: w integer, intent(in), optional :: dim Return Value real(kind=dp),\n  dimension(:), allocatable private module function var_2_qp(A, w, dim) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: w integer, intent(in), optional :: dim Return Value real(kind=qp),\n  dimension(:), allocatable private module function var_2_sp(A, w, dim) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:, :) :: A integer, intent(in), optional :: w integer, intent(in), optional :: dim Return Value real(kind=sp),\n  dimension(:), allocatable","tags":"","loc":"module/forlab_stats.html"},{"title":"forlab_sorting – FORLAB","text":"Uses forlab_stats stdlib_kinds Used by Descendants: forlab_sorting_argsort forlab_sorting_sort Contents Interfaces argsort sort Interfaces public interface argsort argsort generates the indices that would sort an array. private module function argsort_dp(x, order) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) private module function argsort_int16(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) private module function argsort_int32(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) private module function argsort_int64(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) private module function argsort_int8(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) private module function argsort_qp(x, order) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) private module function argsort_sp(x, order) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer,\n  allocatable, (:) public interface sort private module function sort_dp(x, order) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in), optional :: order Return Value real(kind=dp),\n  allocatable, (:) private module function sort_int16(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer(kind=int16),\n  allocatable, (:) private module function sort_int32(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer(kind=int32),\n  allocatable, (:) private module function sort_int64(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer(kind=int64),\n  allocatable, (:) private module function sort_int8(x, order) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in), optional :: order Return Value integer(kind=int8),\n  allocatable, (:) private module function sort_qp(x, order) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in), optional :: order Return Value real(kind=qp),\n  allocatable, (:) private module function sort_sp(x, order) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in), optional :: order Return Value real(kind=sp),\n  allocatable, (:)","tags":"","loc":"module/forlab_sorting.html"},{"title":"forlab_linalg_outer – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_outer.html"},{"title":"forlab_io_bin – FORLAB","text":"Uses Ancestors: forlab_io Contents None","tags":"","loc":"module/forlab_io_bin.html"},{"title":"forlab_math_arange – FORLAB","text":"Uses Ancestors: forlab_math Contents None","tags":"","loc":"module/forlab_math_arange.html"},{"title":"forlab_math_all_close – FORLAB","text":"Uses Ancestors: forlab_math Contents None","tags":"","loc":"module/forlab_math_all_close.html"},{"title":"forlab_stats_rng – FORLAB","text":"Uses Ancestors: forlab_stats Contents None","tags":"","loc":"module/forlab_stats_rng.html"},{"title":"forlab_linalg_qr – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_qr.html"},{"title":"forlab_stats_randn – FORLAB","text":"Uses Ancestors: forlab_stats Contents None","tags":"","loc":"module/forlab_stats_randn.html"},{"title":"forlab_linalg_matpow – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_matpow.html"},{"title":"forlab_sorting_argsort – FORLAB","text":"Uses Ancestors: forlab_sorting Contents None","tags":"","loc":"module/forlab_sorting_argsort.html"},{"title":"forlab_io_disp – FORLAB","text":"Uses iso_fortran_env stdlib_string_type Ancestors: forlab_io Contents None","tags":"","loc":"module/forlab_io_disp.html"},{"title":"forlab_sorting_sort – FORLAB","text":"Uses Ancestors: forlab_sorting Contents None","tags":"","loc":"module/forlab_sorting_sort.html"},{"title":"forlab_time_tioc – FORLAB","text":"Uses stdlib_strings Ancestors: forlab_time Contents None","tags":"","loc":"module/forlab_time_tioc.html"},{"title":"forlab_linalg_eig – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_eig.html"},{"title":"forlab_io_progress_perc – FORLAB","text":"Uses Ancestors: forlab_io Contents None","tags":"","loc":"module/forlab_io_progress_perc.html"},{"title":"forlab_linalg_solve – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_solve.html"},{"title":"forlab_io_progress_bar – FORLAB","text":"Uses Ancestors: forlab_io Contents None","tags":"","loc":"module/forlab_io_progress_bar.html"},{"title":"forlab_linalg_det – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_det.html"},{"title":"forlab_linalg_diff – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_diff.html"},{"title":"forlab_math_signum – FORLAB","text":"Uses Ancestors: forlab_math Contents None","tags":"","loc":"module/forlab_math_signum.html"},{"title":"forlab_linalg_chol – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_chol.html"},{"title":"forlab_stats_mean – FORLAB","text":"Uses Ancestors: forlab_stats Contents None","tags":"","loc":"module/forlab_stats_mean.html"},{"title":"forlab_linalg_inv – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_inv.html"},{"title":"forlab_linalg_diag – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_diag.html"},{"title":"forlab_time_datenum – FORLAB","text":"Uses stdlib_strings forlab_io Ancestors: forlab_time Contents None","tags":"","loc":"module/forlab_time_datenum.html"},{"title":"forlab_linalg_eye – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_eye.html"},{"title":"forlab_linalg_cat – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_cat.html"},{"title":"forlab_stats_randu – FORLAB","text":"Uses Ancestors: forlab_stats Contents None","tags":"","loc":"module/forlab_stats_randu.html"},{"title":"forlab_io_color – FORLAB","text":"Some prepared color to choosed.\nhttps://rosettacode.org/wiki/Terminal_control/Coloured_text#Fortran Uses Ancestors: forlab_io Contents None","tags":"","loc":"module/forlab_io_color.html"},{"title":"forlab__io_txt – FORLAB","text":"Uses forlab_time Ancestors: forlab_io Contents None","tags":"","loc":"module/forlab__io_txt.html"},{"title":"forlab_linalg_seq – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_seq.html"},{"title":"forlab_math_is_close – FORLAB","text":"Uses Ancestors: forlab_math Contents None","tags":"","loc":"module/forlab_math_is_close.html"},{"title":"forlab_linalg_svd – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_svd.html"},{"title":"forlab_linalg_tri – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_tri.html"},{"title":"forlab_linalg_linspace – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_linspace.html"},{"title":"forlab_linalg_norm – FORLAB","text":"Uses forlab_linalg Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_norm.html"},{"title":"forlab_stats_var – FORLAB","text":"Uses Ancestors: forlab_stats Contents None","tags":"","loc":"module/forlab_stats_var.html"},{"title":"forlab_linalg_svdsolve – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_svdsolve.html"},{"title":"forlab_linalg_lu – FORLAB","text":"Uses Ancestors: forlab_linalg Contents None","tags":"","loc":"module/forlab_linalg_lu.html"},{"title":"forlab_math_degcir – FORLAB","text":"Uses Ancestors: forlab_math Contents None","tags":"","loc":"module/forlab_math_degcir.html"},{"title":"Contributing and specs – FORLAB","text":"Warning This page is currently under construction! Todo Improve the title of this FORD \"pages\" section, and\nimprove the organization of pages\nto separate end-user, high-level documentation and examples from developer documentation and specs.","tags":"","loc":"page//index.html"},{"title":"Fortran FORLAB License (MIT) – FORLAB","text":"MIT License Copyright (c) 2018-2021 FORLAB Contributors Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","tags":"","loc":"page/./License.html"},{"title":"Specifications (specs) – FORLAB","text":"Fortran forlab Specifications (specs) Fortran forlab Specifications (specs) Experimental Features & Modules Released/Stable Features & Modules Experimental Features & Modules IO - Input/output helper & convenience math - Math functions linalg - Linear Algebra stats - Descriptive Statistics Released/Stable Features & Modules (None yet)","tags":"","loc":"page/specs/index.html"},{"title":"IO – FORLAB","text":"IO IO file - File Constructor and File Derived Type Status Class Description Syntax Arguments Return value Examples file%exist Description Status Class Syntax Arguments Return value Example file%open Description Status Class Syntax Arguments Example file%countlines Description Status Class Syntax Arguments Example file%close Description Status Class Syntax Arguments Example color Description Status Class Syntax Argument Output Example disp - display your data Status Class Description More details Syntax Arguments Output Example progress_bar Description Status Class Syntax Arguments Output Example progress_perc Description Status Class Syntax Arguments Output Example file - File Constructor and File Derived Type Status Experimental Class Impure function. Description file function constructs a file entity of file type, including some file operation methods. Syntax ofile = file (filename [, mode]) Arguments filename : Shall be a character(len=*) scalar.\nThis argument is intent(in) . \nContains the file name. mode : Shall be a character(len=*) scalar.\nThis argument is intent(in) and optional .\nContains characters describing the way in which the file will be used (see stdlib_io:open ). The available modes are: Character Meaning 'r' construct a file for reading (default) 'w' construct a file for writing, truncating the file first 'x' construct a file for exclusive creation, failing if the file already exists 'a' construct a file for writing, appending to the end of the file if it exists '+' construct a file for updating (reading and writing) 'b' binary mode 't' text mode (default) The default mode is 'rt' (i.e. construct a file for reading a text file). The mode may include one of the four different methods for opening a file (i.e., 'r' , 'w' , 'x' , and 'a' ). These four methods can be associated with the character '+' to open the file for updating. In addition, it can be specified if the file should be handled as a binary file ( 'b' ) or a text file ( 't' ). Return value Returns a file entity of file type, in which the following are defined: type file character (:), allocatable :: filename character ( 3 ) :: mode integer :: unit integer :: lines contains procedure :: exist procedure :: open procedure :: countlines procedure :: close end type file Examples program demo_io_file_1 use forlab_io , only : file , disp use stdlib_error , only : check type ( file ) :: infile infile = file ( 'DP.txt' , 'r' ) call check ( infile % exist (), msg = \"File not exist, \" // infile % filename ) call infile % open () call infile % countlines () call disp ( infile % lines , 'Linenumber in file is: ' ) call infile % close () !! `infile` is closed, `infile%filename` is deallocated. end program demo_io_file_1 program demo_io_file_2 use forlab_io , only : file , disp use stdlib_error , only : check type ( file ), allocatable :: infile !! To create a `file` type scalar to read: !! !!```fortran !! infile = file(\"somefile.txt\")        ! The default `mode` is \"rt\" !! infile = file(\"somefile.txt\", \"r\") !!``` !! !! To create a `file` type scalar to write: !!    infile = file(\"somefile.txt\", \"w\") !! !! To append to the end of the file if it exists: !! !!    infile = file(\"somefile.txt\", \"a\") infile = file ( 'DP.txt' , 'r' ) call check ( infile % exist (), msg = \"File not exist, \" // infile % filename ) call infile % open () call infile % countlines () call disp ( infile % lines , 'Linenumber in file is: ' ) call infile % close () !! It is optional. `infile` is closed, `infile%filename` is deallocated. deallocate ( infile ) !! `infile` is deallocated. end program demo_io_file_2 file%exist Description Checks the file is exist or not. Status Experimental. Class Impure function. Syntax result = self % exist () Arguments None. Return value Returns a logical scalar: the file exists as .true. , the file does not exist as .false. . Example program demo_io_file_exist use forlab_io , only : file use stdlib_error , only : check type ( file ), allocatable :: infile infile = file ( \"filename.txt\" , \"r\" ) call check ( infile % exist (), msg = \"File not exist: \" // infile % filename ) deallocate ( infile ) end program demo_io_file_exist file%open Description Open the file object. Status Experimental. Class Impure function. Syntax call self % open () Arguments None. Example program demo_io_file_open use forlab_io , only : file use stdlib_error , only : check type ( file ), allocatable :: infile infile = file ( \"filename.txt\" , \"r\" ) call check ( infile % exist (), msg = \"File not exist: \" // infile % filename ) call infile % open () !! Open file operation deallocate ( infile ) end program demo_io_file_open file%countlines Description Counts the number of lines in a txt file, the number of file lines is stored in file%lines . Status Experimental. Class Impure function. Syntax call self % countlines () Arguments None. Example program demo_io_file_countlines use forlab_io , only : file , disp type ( file ), allocatable :: infile infile = file ( \"filename.txt\" , \"r\" ) call infile % countlines () !! Counts the number of lines in a txt file, the number of file lines is stored in `infile%lines`. call disp ( infile % lines , \"The number of file lines : \" ) deallocate ( infile ) end program demo_io_file_countlines file%close Description Closes the file object, deallocate file%filename . Status Experimental. Class Impure function. Syntax call self % close () Arguments None. Example program demo_io_file_close use forlab_io , only : file , disp type ( file ) :: infile infile = file ( \"filename.txt\" , \"r\" ) call infile % open () call infile % close () !! Closes the `infile` object, deallocate `infile%filename`. end program demo_io_file_close color Description Prints a PS code at default output_unit. Status Experimental. Class Impure subroutine. Syntax call color ( [string=achar(27) // '[0m'] ) Argument string : Shall be a character(len=*) scalar.\nThis argument is intent(in) and optional . The default value is achar(27) // '[0m' . Output Prints a PS code at default output_unit. Example program demo_io_color use forlab_io , only : color use forlab_color , only : red , green character ( len =* ), parameter :: char = \"It is Fortran Color: \" call color ( green ) print * , char // 'green.' print * , red // char // 'red.' call color () print * , char // \"default.\" end program demo_io_color disp - display your data Status Experimental Class Impure subroutine. Description Outputs a logical/integer/real/complex/character/string_type scalar or logical/integer/real/complex and rank-1/rank-2 array to the screen or a file unit . More details call disp ( A ( i , j , 2 , :, 1 : 10 ) [, header , unit , brief ] ) !! `i, j, ...` can be determined by `do` loop. For complex type, the output format is *(A25, 1X) ; \nFor    other types, the output format is *(A12, 1X) . To prevent users from accidentally passing large-length arrays to disp , causing unnecessary io blockage:\n1. If the brief argument is not specified, disp will print the brief array content with a length of 10*50 by default .\n2. Specify brief=.true. , disp will print the brief array content with a length of 5*5 ;\n3. Specify brief=.false. , disp will print all the contents of the array . Syntax call disp ([x, header, unit, brief]) Arguments x : Shall be a logical/integer/real/complex/string_type scalar or logical/integer/real/complex and rank-1/rank-2 array.\nThis argument is intent(in) and optional . header : Shall be a character(len=*) scalar. \nThis argument is intent(in) and optional . unit : Shall be an integer scalar linked to an IO stream.\nThis argument is intent(in) and optional . brief : Shall be a logical scalar.\nThis argument is intent(in) and optional . Controls an abridged version of the x object is printed. Output The result is to print header and x on the screen (or another output unit/file ) in this order. If x is a rank-1/rank-2 array type, the dimension length information of the array will also be outputted. If disp is not passed any arguments, a blank line is printed. If the x is present and of real/complex type, the data will retain four significant decimal places, like (g0.4) . Example program demo_io_disp use forlab_io , only : disp real ( 8 ) :: r ( 2 , 3 ) complex :: c ( 2 , 3 ), c_3d ( 2 , 100 , 20 ) integer :: i ( 2 , 3 ) logical :: l ( 10 , 10 ) r = 1. ; c = 1. ; c_3d = 2. ; i = 1 ; l = . true . r ( 1 , 1 ) = - 1.e-11 r ( 1 , 2 ) = - 1.e10 c ( 2 , 2 ) = ( - 1.e10 , - 1.e10 ) c_3d ( 1 , 3 , 1 ) = ( 1000 , 0.001 ) c_3d ( 1 , 3 , 2 ) = ( 1.e4 , 10 0. ) call disp ( 'string' , header = 'disp(string):' ) call disp ( 'It is a note.' ) call disp () call disp ( r , header = 'disp(r):' ) call disp ( r ( 1 ,:), header = 'disp(r(1,:))' ) call disp ( c , header = 'disp(c):' ) call disp ( i , header = 'disp(i):' ) call disp ( l , header = 'disp(l):' , brief = . true .) call disp ( c_3d (:,:, 3 ), header = 'disp(c_3d(:,:,3)):' , brief = . true .) call disp ( c_3d ( 2 ,:,:), header = 'disp(c_3d(2,:,:)):' , brief = . true .) end program demo_io_disp Results: disp ( string ): string It is a note . disp ( r ): [ matrix size : 2 × 3 ] - 0.1000E-10 - 0.1000E+11 1.000 1.000 1.000 1.000 disp ( r ( 1 ,:)) [ vector size : 3 ] - 0.1000E-10 - 0.1000E+11 1.000 disp ( c ): [ matrix size : 2 × 3 ] ( 1.000 , 0.000 ) ( 1.000 , 0.000 ) ( 1.000 , 0.000 ) ( 1.000 , 0.000 ) ( - 0.1000E+11 , - 0.1000E+11 ) ( 1.000 , 0.000 ) disp ( i ): [ matrix size : 2 × 3 ] 1 1 1 1 1 1 disp ( l ): [ matrix size : 10 × 10 ] T T T ... T T T T ... T T T T ... T : : : : : T T T ... T disp ( c_3d (:,:, 3 )): [ matrix size : 2 × 100 ] ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ... ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ... ( 2.000 , 0.000 ) disp ( c_3d ( 2 ,:,:)): [ matrix size : 100 × 20 ] ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ... ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ... ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ... ( 2.000 , 0.000 ) : : : : : ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ( 2.000 , 0.000 ) ... ( 2.000 , 0.000 ) progress_bar Description Prints a progress bar. Status Experimental Class Impure subroutine. Syntax call progress_bar (iter, itermax [, step, symbol]) Arguments iter/itermax/step shall be the same kind. iter : Shall be an integer scalar.\nThis argument is intent(in) . itermax : Shall be an integer scalar.\nThis argument is intent(in) . step : Shall be an integer scalar.\nThis argument is intent(in) and optional . symbol : Shall be a character(len=*) scalar.\nThis argument is intent(in) and optional . Output Prints a line of progress bar on the screen. Example program demo_io_progress_bar use forlab_io , only : progress_bar use forlab_stats , only : randu do i = 0 , 100 , 10 call progress_bar ( i , 100 ) call sleep ( randu ( 1 , 2 )) end do write ( * , \"(3A)\" , advance = \"no\" ) char ( 13 ), \"Calculation Done!\" , repeat ( \" \" , 55 ) end program demo_io_progress_bar progress_perc Description Prints a progress percentage message. Status Experimental Class Impure subroutine. Syntax call progress_perc (iter, itermax [, prefix]) Arguments iter/itermax shall be the same kind. iter : Shall be an integer scalar.\nThis argument is intent(in) . itermax : Shall be an integer scalar.\nThis argument is intent(in) . prefix : Shall be a character(len=*) scalar.\nThis argument is intent(in) and optional . Output Prints a line of progress percentage on the screen. Example program demo_io_progress_perc use forlab_io , only : progress_perc use forlab_stats , only : randu do i = 0 , 100 , 10 call progress_perc ( i , 100 , \">>\" ) call sleep ( randu ( 1 , 3 )) end do end program demo_io_progress_perc","tags":"","loc":"page/specs/forlab_io.html"},{"title":"LINALG – FORLAB","text":"LINALG LINALG diff - diff computes differences of arrays. Status Class Description Syntax Arguments Return value Example zeros/ones Description Warning Status Class Syntax Arguments Return value Warning Example diff - diff computes differences of arrays. Status Experimental Class Pure function. Description y = diff(x) returns differences between adjacent elements of vector x. y = diff(x, n) returns the nth difference by applying the diff(x) operator recursively n times. B = diff(A) returns differences between adjacent elements of array A along the first dimension. B = diff(A, n) returns the nth difference by applying the diff(A) operator recursively n times. B = diff(A, dim) returns differences between adjacent elements of array A along the dimension given by dim. B = diff(A, n, dim) returns the nth difference along the dimension given by dim by applying the diff(A, dim) operator recursively n times. Syntax For vector: result = diff (x [, n]) For matrix: result = diff (A [, n, dim]) Arguments x : Shall be a real type of verctor. A : Shall be a real type of matrix. n (optional): Shall be a integer type. dim (optional): Shall be a integer type. Return value Return differences between adjacent elements of vector x or matrix A . Example program test_linalg_diff use forlab_linalg , only : diff use forlab_linalg , only : linspace use forlab_io , only : disp real :: x ( 10 ) call linspace ( x , 0.0 , 9.0 ) call disp ( x , \"linspace(x) : \" ) call disp ( diff ( x ), \"test_linalg_diff : \" ) end program test_linalg_diff zeros/ones Description zeros creates a rank-1 or rank-2 array of the given shape, filled completely with 0 integer type values. ones creates a rank-1 or rank-2 array of the given shape, filled completely with 1 integer type values. Warning It is not recommended to use the zeros/ones function, it is recommended to use allocate(array(dim1, dim2, ..), source=0.0/1.0) . Status Experimental Class Pure function. Syntax For rank-1 array: result = zeros (dim) result = ones (dim) For rank-2 array: result = zeros (dim1, dim2) result = ones (dim1, dim2) Arguments dim/dim1 : Shall be an integer type.\nThis is an intent(in) argument. dim2 : Shall be an integer type.\nThis is an intent(in) argument. Return value Returns a rank-1 or rank-2 array of the given shape, filled completely with either 0 or 1 integer type values. Warning Since the result of ones is of integer type, one should be careful about using it in arithmetic expressions. For example: real :: A (:,:) !> Be careful A = ones ( 2 , 2 ) / 2 !! A = 1/2 = 0.0 !> Recommend A = ones ( 2 , 2 ) / 2.0 !! A = 1/2.0 = 0.5 Example program demo_linalg_zerosones use forlab_linalg , only : zeros , ones use forlab_io , only : disp real , allocatable :: zero (:, :), one (:, :) real , allocatable :: array (:, :) zero = zeros ( 1 , 2 ) one = ones ( 2 , 1 ) call disp ( zero , \"zeros: \" ) call disp ( one , \"ones : \" ) call disp ( ones ( 2 , 2 ) / 2 , \"!attention: `ones(2, 2)/2` is like `1/2 == 0`\" ) array = zeros ( 2 , 2 ) call disp ( array , \"array with zeros: \" ) array = ones ( 2 , 2 ) call disp ( array , \"array with ones :\" ) end program demo_linalg_zerosones","tags":"","loc":"page/specs/forlab_linalg.html"},{"title":"MATH – FORLAB","text":"MATH MATH arange Status Class Description Syntax Arguments Warning Return value Example signum Status Class Description Syntax Argument Return value Example is_close Description Syntax Status Class Arguments Result value Example all_close Description Syntax Status Class Arguments Result value Example arange Status Experimental Class Pure function. Description Creates a rank-1 array of the integer/real type with fixed-spaced values of given spacing, within a given interval. Syntax result = arange (start [, end, step]) Arguments All arguments should be the same type and kind. start : Shall be an integer/real scalar.\nThis is an intent(in) argument. The default start value is 1 . end : Shall be an integer/real scalar.\nThis is an intent(in) and optional argument. The default end value is the inputted start value. step : Shall be an integer/real scalar and large than 0 . \nThis is an intent(in) and optional argument. The default step value is 1 . Warning If step = 0 , the step argument will be corrected to 1/1.0 by the internal process of the arange function. If step < 0 , the step argument will be corrected to abs(step) by the internal process of the arange function. Return value Returns a rank-1 array of fixed-spaced values. For integer type arguments, the length of the result vector is (end - start)/step + 1 . For real type arguments, the length of the result vector is floor((end - start)/step) + 1 . Example program demo_math_arange use forlab_math , only : arange print * , arange ( 3 ) !! [1,2,3] print * , arange ( - 1 ) !! [1,0,-1] print * , arange ( 0 , 2 ) !! [0,1,2] print * , arange ( 1 , - 1 ) !! [1,0,-1] print * , arange ( 0 , 2 , 2 ) !! [0,2] print * , arange ( 3.0 ) !! [1.0,2.0,3.0] print * , arange ( 0.0 , 5.0 ) !! [0.0,1.0,2.0,3.0,4.0,5.0] print * , arange ( 0.0 , 6.0 , 2.5 ) !! [0.0,2.5,5.0] print * , ( 1.0 , 1.0 ) * arange ( 3 ) !! [(1.0,1.0),(2.0,2.0),[3.0,3.0]] print * , arange ( 0.0 , 2.0 , - 2.0 ) !! [0.0,2.0].     Not recommended: `step` argument is negative! print * , arange ( 0.0 , 2.0 , 0.0 ) !! [0.0,1.0,2.0]. Not recommended: `step` argument is zero! end program demo_math_arange signum Status Experimental Class Elemental function. Description Returns the sign of variables. Syntax sign = signum (x) Argument x : Shall be an integer/real/complex elemental variable.\nThis is an intent(in) argument. Return value Returns the sign of variables. For complex types, return the regularization result: sign = x/abs(x) . Example !> fpm run --example math_signum program demo_math_signum use forlab_math , only : signum print * , signum ( 1 - 2 ) print * , signum ([ 0.0 , 2.1 ]) print * , signum (( 1.0 , - 2.0 )) !>    -1 !>   0.00000000       1.00000000 !>          (0.447213590,-0.894427180) end program demo_math_signum is_close Description Returns a boolean scalar/array where two scalars/arrays are element-wise equal within a tolerance, behaves like isclose in Python stdlib. !> For `real` type is_close ( a , b , rel_tol , abs_tol ) = abs ( a - b ) <= max ( rel_tol * ( abs ( a ), abs ( b )), abs_tol ) !> For `complex` type is_close ( a , b , rel_tol , abs_tol ) = is_close ( a % re , b % re , rel_tol , abs_tol ) . and . & is_close ( a % im , b % im , rel_tol , abs_tol ) Syntax bool = is_close (a, b [, rel_tol, abs_tol]) Status Experimental. Class Elemental function. Arguments a : Shall be a real/complex scalar/array.\nThis argument is intent(in) . b : Shall be a real/complex scalar/array.\nThis argument is intent(in) . rel_tol : Shall be a real scalar.\nThis argument is intent(in) and optional , which is 1.0e-9 by default. abs_tol : Shall be a real scalar.\nThis argument is intent(in) and optional , which is 0.0 by default. Note: All real/complex arguments must have same kind . If the value of rel_tol/abs_tol is negative (not recommended), \nit will be corrected to abs(rel_tol/abs_tol) by the internal process of is_close . Result value Returns a logical scalar/array. Example program demo_math_is_close use forlab_math , only : is_close use stdlib_error , only : check real :: x ( 2 ) = [ 1 , 2 ] print * , is_close ( x ,[ real :: 1 , 2.1 ]) !! [T, F] print * , is_close ( 2.0 , 2.1 , abs_tol = 0.1 ) !! T call check ( all ( is_close ( x , [ 2.0 , 2.0 ])), msg = \"all(is_close(x, [2.0, 2.0])) failed.\" , warn = . true .) !! all(is_close(x, [2.0, 2.0])) failed. end program demo_math_is_close all_close Description Returns a boolean scalar where two arrays are element-wise equal within a tolerance, behaves like all(is_close(a, b [, rel_tol, abs_tol])) . Syntax bool = all_close (a, b [, rel_tol, abs_tol]) Status Experimental. Class Impure function. Arguments a : Shall be a real/complex array.\nThis argument is intent(in) . b : Shall be a real/complex array.\nThis argument is intent(in) . rel_tol : Shall be a real scalar.\nThis argument is intent(in) and optional , which is 1.0e-9 by default. abs_tol : Shall be a real scalar.\nThis argument is intent(in) and optional , which is 0.0 by default. Note: All real/complex arguments must have same kind . If the value of rel_tol/abs_tol is negative (not recommended), \nit will be corrected to abs(rel_tol/abs_tol) by the internal process of all_close . Result value Returns a logical scalar. Example program demo_math_all_close use forlab_math , only : all_close use stdlib_error , only : check real :: x ( 2 ) = [ 1 , 2 ], random ( 4 , 4 ) complex :: z ( 4 , 4 ) call check ( all_close ( x , [ 2.0 , 2.0 ], rel_tol = 1.0e-6 , abs_tol = 1.0e-3 ), & msg = \"all_close(x, [2.0, 2.0]) failed.\" , warn = . true .) !! all_close(x, [2.0, 2.0]) failed. call random_number ( random ( 4 , 4 )) z = 1.0 print * , all_close ( z + 1.0e-11 * random , z ) !! T end program demo_math_all_close","tags":"","loc":"page/specs/forlab_math.html"},{"title":"STATS – FORLAB","text":"STATS Notes In daily use, vectors and matrices are more practical than higher-order arrays, \nand Fortran does not support array generics, we can use reshape to reshape vectors into higher-order arrays. real :: x ( 2 , 3 , 4 ) x = reshape ( randn ( mean = 0.0 , std = 1.0 , ndim = 2 * 3 * 4 ), [ 2 , 3 , 4 ]) STATS Notes randu Description Status Class Syntax Arguments Result value Example randn Description Status Class Syntax Arguments Result value Example randu Description Generate an uniformly distributed data scalar or vector. Status Experimental. Class Impure function. Syntax random = randu (start, end [, ndim]) Arguments random/start/end should keep the same type and kind. start : Shall be an integer/real scalar.\nThis argument is intenet(in) . end : Shall be an integer/real scalar.\nThis argument is inetent(in) . ndim : Shall be an integer scalar.\nThis argument is intent(in) and optional . Result value Returns an integer/real scalar or rank-1 array. Example program demo_stats_randu use forlab_stats , only : randu print * , \"running `demo_stats_randu`..\" print * , randu ( start = 1 , end = 2 ) print * , randu ( start = 1.0 , end = 2.0 , ndim = 3 ) print * , reshape ( randu ( 1.0 , 2.0 , 2 * 2 ), [ 2 , 2 ]) !> Possible output: !! 2 !! 1.65676987       1.11625218       1.03502560 !! 1.74973476       1.82997108       1.77998054       1.14384007 end program demo_stats_randu randn Description Generate a normal distributed data scalar or vector. Status Experimental. Class Impure function. Syntax random = randn (mean, std [, ndim]) Arguments random/mean/std should keep the same type and kind. mean : Shall be an integer/real scalar.\nThis argument is intenet(in) . std : Shall be an integer/real scalar.\nThis argument is inetent(in) . ndim : Shall be an integer scalar.\nThis argument is intent(in) and optional . Result value Returns an integer/real scalar or rank-1 array. Example program demo_stats_randn use forlab_stats , only : randn print * , \"running `demo_stats_randn`..\" print * , randn ( mean = 0.0 , std = 2.0 ) print * , randn ( mean = 0.0 , std = 2.0 , ndim = 3 ) print * , reshape ( randn ( 0.0 , 2.0 , 2 * 2 ), [ 2 , 2 ]) !> Chi-square distribution of 3 degrees of freedom print * , sum ( randn ( mean = 0.0 , std = 1.0 , ndim = 3 ) ** 2 ) print * , sum ( reshape ( randn ( mean = 0.0 , std = 1.0 , ndim = 5 * 3 ), [ 5 , 3 ]) ** 2 , dim = 2 ) !> Possible output: !! -0.387298465 !! -1.37615824     -0.529266298       5.43095016 !! -1.35311902       1.81701779      0.772518456     -0.269844353 !! 9.45483303 !! 0.962645471      0.698421597      0.687875450       4.75956964       1.71025097 end program demo_stats_randn","tags":"","loc":"page/specs/forlab_stats.html"}]}