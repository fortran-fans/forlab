#:include 'common.fypp'

module forlab_io

    use stdlib_error,  only: error_stop
    use stdlib_io, only: open, parse_mode
        !!\TOCHECK: parse_mode public only for tests
    use stdlib_ascii, only: to_string
    use stdlib_kinds, only: sp, dp, qp, &
        int8, int16, int32, int64, lk, c_bool
    use stdlib_optval, only: optval
    use forlab_strings, only: format_string
    implicit none
    private

    public :: file
    public :: countlines, file_exist
    public :: savebin, loadbin, savetxt, loadtxt
    public :: set_color
    public :: disp

    type file
        integer :: unit
        character(:), allocatable :: filename
        character(3) :: mode
        integer :: lines
    contains
        procedure :: exist => file_exist1
        procedure :: open => open_file
        procedure :: countlines => countlines1
        procedure :: close
    end type file

    interface disp
        !! version: experimental
        !!
        !! Quickly display strings, scalars and low-dimensional arrays to the default output_unit
        !! ([Specification](../page/specs/stdlib_io.html#description))
        #:set DISP_KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES &
            & + CMPLX_KINDS_TYPES + LOG_KINDS_TYPES
        #:set DISP_RANKS = range(0, 4)
        #:for kind, type in DISP_KINDS_TYPES
        #:for rank in DISP_RANKS
        #:if rank != 3
        module subroutine disp_${rank}$_${type[0]}$${kind}$(value, string)
            ${type}$, intent(in) :: value${ranksuffix(rank)}$
            character(len=*), intent(in), optional :: string
        end subroutine disp_${rank}$_${type[0]}$${kind}$
        #:else
        module subroutine disp_${rank}$_${type[0]}$${kind}$(value, dim, string)
            ${type}$, intent(in) :: value${ranksuffix(rank)}$
            integer, intent(in) :: dim
            character(len=*), intent(in), optional :: string
        end subroutine disp_${rank}$_${type[0]}$${kind}$
        #:endif
        #:endfor
        #:endfor
        module subroutine disp_str(value, string)
            character(len=*), intent(in), optional :: value
            character(len=*), intent(in), optional :: string
        end subroutine disp_str
    end interface disp

    interface file
        procedure init_file
    end interface file

    interface countlines
        procedure countlines2
    end interface countlines

    interface file_exist
        procedure file_exist2
    end interface file_exist

    interface loadbin
        #:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CMPLX_KINDS_TYPES
        #:set RANKS = range(1,4)
        #:for RANK in RANKS
        #:for k1,t1 in RCI_KINDS_TYPES
        module subroutine loadbin_${RANK}$_${t1[0]}$${k1}$(filename, X)
            character(len=*), intent(in) :: filename
            #:if RANK == 1
            ${t1}$, dimension(:), allocatable, intent(out) :: X
            #:elif RANK == 2
            ${t1}$, dimension(:, :), allocatable, intent(out) :: X
            #:elif RANK == 3
            ${t1}$, dimension(:, :, :), allocatable, intent(out) :: X
            #:endif
        end subroutine
        #:endfor
        #:endfor
    end interface

    interface loadtxt
        #:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CMPLX_KINDS_TYPES
        #:set RANKS = range(1,3)
        #:for RANK in RANKS
        #:for k1,t1 in RCI_KINDS_TYPES
        module subroutine loadtxt_${RANK}$_${t1[0]}$${k1}$(filename, X)
            character(len=*), intent(in) :: filename
            #:if RANK == 1
            ${t1}$, dimension(:), allocatable, intent(out) :: X
            #:elif RANK == 2
            ${t1}$, dimension(:, :), allocatable, intent(out) :: X
            #:endif
        end subroutine
        #:endfor
        #:endfor
    end interface

    interface savebin
        #:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CMPLX_KINDS_TYPES
        #:set RANKS = range(1,4)
        #:for RANK in RANKS
        #:for k1,t1 in RCI_KINDS_TYPES
        module subroutine savebin_${RANK}$_${t1[0]}$${k1}$(filename, X)
            character(len=*), intent(in) :: filename
            #:if RANK == 1
            ${t1}$, dimension(:), intent(in) :: X
            #:elif RANK == 2
            ${t1}$, dimension(:, :), intent(in) :: X
            #:elif RANK == 3
            ${t1}$, dimension(:, :, :), intent(in) :: X
            #:endif
        end subroutine
        #:endfor
        #:endfor
    end interface savebin

    interface savetxt
        #:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CMPLX_KINDS_TYPES
        #:set RANKS = range(1,3)
        #:for RANK in RANKS
        #:for k1,t1 in RCI_KINDS_TYPES
        module subroutine savetxt_${RANK}$_${t1[0]}$${k1}$(filename, X)
            character(len=*), intent(in) :: filename
            #:if RANK == 1
            ${t1}$, dimension(:), intent(in) :: X
            #:elif RANK == 2
            ${t1}$, dimension(:, :), intent(in) :: X
            #:endif
        end subroutine
        #:endfor
        #:endfor
    end interface savetxt

    interface
        subroutine set_color(value) bind(c, name="color")
            use, intrinsic :: iso_c_binding, only: c_long
            integer(c_long), value, intent(in) :: value
        end subroutine
    end interface

contains

    subroutine open_file(self)
        !! Version: experimental
        !!
        !! Open a file
        !! ([Specification](../page/specs/forlab_io.html#description))
        !!
        !!##### Behavior
        !!
        !!
        !! To open a file to read:
        !!
        !!```fortran
        !! u = open("somefile.txt")        ! The default `mode` is "rt"
        !! u = open("somefile.txt", "r")
        !!```
        !!
        !! To open a file to write:
        !!    u = open("somefile.txt", "w")
        !!
        !! To append to the end of the file if it exists:
        !!
        !!    u = open("somefile.txt", "a")

        class(file) :: self
        integer :: stat

        self%unit = open(self%filename, self%mode, iostat=stat)
        if(stat /= 0) call error_stop('Error: File "'//self%filename//&
            '" open failed, iostat = '//to_string(stat))

    end subroutine open_file

    subroutine close (self)
        ! close
        !-----------------------------------------------------------------------
        ! close closes a File object.
        !
        ! Syntax
        !-----------------------------------------------------------------------
        ! call ofile%close()
        !
        ! Description
        !-----------------------------------------------------------------------
        ! call ofile%close() closes the File object ofile.
        class(file) :: self

        close (self%unit)
        return
    end subroutine close

    subroutine countlines1(self)
        !! countlines counts the number of lines in a txt file.
        class(file), intent(inout) :: self
        integer :: ierr
        logical :: ok
        
        self%lines = 0
        ok = .false.
        inquire (unit=self%unit, opened=ok)
        if (ok) then
            do
                read (self%unit, *, iostat=ierr)
                if (ierr < 0) exit
                self%lines = self%lines + 1
            end do
            rewind(self%unit)
        else
            call self%open()
            do
                read (self%unit, *, iostat=ierr)
                if (ierr < 0) exit
                self%lines = self%lines + 1
            end do
            call self%close()
        end if
        if (self%lines == 0) then
            call disp('Warn: linecounts is 0 in ', "'"//self%filename//"'")
        end if
        return
    end subroutine countlines1

    integer function countlines2(filename)
        !! The `countlines2` function returns the number of lines of the file
        character(len=*), intent(in) :: filename
        type(file) :: infile

        infile = file(trim(filename))
        if(.not.infile%exist()) call error_stop('Error: File "'//infile%filename &
                                        //'" open failed.')
        call infile%open()
        call infile%countlines()
        call infile%close()
        countlines2 = infile%lines
        return
    end function countlines2

    logical function file_exist1(self)
        ! file_exist
        !-----------------------------------------------------------------------
        ! file_exist determines whether a File object already exists.
        !
        ! Syntax
        !-----------------------------------------------------------------------
        ! exist = ofile % exist()
        !
        ! Description
        !-----------------------------------------------------------------------
        ! call ofile % exist() returns .true. if the File object ofile exists,
        ! .false. otherwise.
        class(File), intent(inout) :: self

        inquire (file=trim(self%filename), exist=file_exist1)
        return
    end function file_exist1

    logical function file_exist2(filename)
        !! The `countlines2` function returns the number of lines of the file
        character(len=*), intent(in) :: filename
        type(File) :: infile

        infile = File(filename)
        file_exist2 = infile%exist()
        return
    end function file_exist2

    type(file) function init_file(filename, mode)
        !!## File (constructor)
        !! File constructs a File object.
        !!
        !!### Syntax
        !! ofile = file(filename, mode)
        !!
        !!### Description
        !! `ofile = file(filename, mode)` returns a File object associated to the
        !! file filename with the identifier unit.
        !!
        !!### Examples
        !!    type(file) :: ofile
        !!
        !!    ofile = file("myfile.txt", "r")
        !!    call ofile%open()
        !!    !! ... some operations on this file ...
        !!    call ofile%close()
        character(len=*), intent(in) :: filename
        character(len=*), intent(in), optional :: mode
        character(len=3) :: mode_

        mode_ = parse_mode(optval(mode, ''))
        init_file%filename = filename
        init_file%mode = mode_

        return
    end function init_file
    
end module forlab_io
